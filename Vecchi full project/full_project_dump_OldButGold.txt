RAFTING REPUBLIC - PROJECT DUMP
GENERATED: 2026-02-06 09:47:08
==================================================

=== PROJECT STRUCTURE ===
./
    backend/
        dataset.yaml
        main.py
        app/
            __init__.py
            api/
                __init__.py
                v1/
                    api.py
                    __init__.py
                    endpoints/
                        registration.py
                        vision.py
                        waivers.py
                        __init__.py
            schemas/
                registration.py
                __init__.py
            services/
                document_specs.py
                image_utils.py
                local_vision_service.py
                waiver_mailer.py
                waiver_service.py
                __init__.py
                registration/
                    email_service.py
                    mrz_native.py
                    pdf_service.py
                    registration_service.py
                    storage_service.py
        assets/
            models/
            templates/
        storage/
            dataset_raw/
            debug_captures/
            registrations/
        test/
            check_libs.py
            check_models.py
            test_ocr_isolation.py
            test_ocr_noise.py
            test_ocr_refinement.py
            test_ocr_rotation.py
            test_tesseract.py
        tools/
            check_full_stack.py
            convert_labelstudio_to_yolo.py
            diagnose_env.py
            generate_synthetic_data.py
            project_export.json
            test_yolo_inference.py
            train_yolo.py
            verify_paddle.py
            zone_calibrator.py
    web-app/
        .prettierrc.json
        eslint.config.js
        index.html
        jsconfig.json
        package.json
        postcss.config.js
        quasar.config.js
        README.md
        public/
            icons/
        src/
            App.vue
            assets/
            boot/
                axios.js
            components/
                CameraCapture.vue
                ModuleCard.vue
                scanner/
                    PersonForm.vue
                    SignaturePad.vue
                    steps/
                        StepDocuments.vue
                        StepReview.vue
            constants/
                legal.js
                translations.js
            css/
                app.scss
                quasar.variables.scss
            layouts/
                MainLayout.vue
            pages/
                DashboardPage.vue
                ErrorNotFound.vue
                IndexPage.vue
                RegistrationPage.vue
                ScannerPage.vue
            router/
                index.js
                routes.js
            services/
                ImageQualityService.js
                VisionService.js
            stores/
                index.js
                registration-store.js

==================================================

=== FILE CONTENTS ===

<FILE_START path="backend\dataset.yaml">
# backend/dataset.yaml

# Percorso base dove si trovano i dati (relativo alla cartella backend)
path: datasets/id_cards

# Dove trovare le immagini di training (relativo a 'path')
train: train/images

# Dove trovare le immagini di validazione (relativo a 'path')
val: val/images

# Numero di classi (solo 1: il documento d'identit√† generico)
nc: 1

# Nomi delle classi
names:
  0: id_card
<FILE_END>

<FILE_START path="backend\main.py">
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.api.v1.endpoints import vision
from app.api.v1.endpoints import registration

app = FastAPI(title="AI Modular Backend", version="0.1.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
def read_root():
    return {"status": "active", "message": "Backend Operativo"}

# Rotte
app.include_router(vision.router, prefix="/api/v1/vision", tags=["AI Vision"])

# Nota: registration.router ha gi√† prefix interno "/registration"
# Risultato: /api/v1/registration/...
app.include_router(registration.router, prefix="/api/v1", tags=["Registration"])
<FILE_END>

<FILE_START path="backend\app\__init__.py">
<FILE_END>

<FILE_START path="backend\app\api\__init__.py">
<FILE_END>

<FILE_START path="backend\app\api\v1\api.py">
from fastapi import APIRouter

from app.api.v1.endpoints.ai import router as ai_router
from app.api.v1.endpoints.vision import router as vision_router

try:
    from app.api.v1.endpoints.registration import router as registration_router
except Exception:
    registration_router = None

try:
    from app.api.v1.endpoints.waivers import router as waivers_router
except Exception:
    waivers_router = None

api_router = APIRouter()

api_router.include_router(ai_router, prefix="/ai", tags=["ai"])
api_router.include_router(vision_router, prefix="/vision", tags=["vision"])

# IMPORTANTE: il router registration ha gi√† prefix interno "/registration"
# quindi qui NON aggiungiamo "/registration" per evitare doppio prefisso.
if registration_router:
    api_router.include_router(registration_router, prefix="", tags=["registration"])

if waivers_router:
    api_router.include_router(waivers_router, prefix="/waivers", tags=["waivers"])
<FILE_END>

<FILE_START path="backend\app\api\v1\__init__.py">
<FILE_END>

<FILE_START path="backend\app\api\v1\endpoints\registration.py">
from __future__ import annotations

from io import BytesIO
from typing import Optional

from fastapi import APIRouter, Body, File, Form, HTTPException, Query, UploadFile
from fastapi.responses import FileResponse
from PIL import Image

from app.schemas.registration import (
    DocumentScanResponse,
    RegistrationPayload,
    RegistrationSubmitResponse,
)
from app.services.local_vision_service import analyze_documents_locally
from app.services.registration.registration_service import RegistrationService

router = APIRouter(prefix="/registration", tags=["registration"])
service = RegistrationService()


def _open_image_bytes(content: bytes, filename: str) -> Image.Image:
    try:
        return Image.open(BytesIO(content)).convert("RGB")
    except Exception:
        raise HTTPException(status_code=400, detail=f"Immagine non valida: {filename}")


@router.post("/scan", response_model=DocumentScanResponse)
async def scan_document(
    front: UploadFile = File(...),
    back: Optional[UploadFile] = File(None),
    doc_type: str = Form("AUTO"),
):
    f_content = await front.read()
    front_img = _open_image_bytes(f_content, front.filename)

    back_img = None
    if back:
        b_content = await back.read()
        try:
            back_img = _open_image_bytes(b_content, back.filename)
        except Exception:
            back_img = None

    extracted = analyze_documents_locally(front_img, back_img, doc_type_hint=doc_type)

    if "error" in extracted:
        raise HTTPException(status_code=500, detail=extracted["error"])

    detected = extracted.get("tipo_documento", "ALTRO")
    mrz_nat = extracted.get("cittadinanza")

    return DocumentScanResponse(
        detected_doc_type=detected,
        mrz_nationality=mrz_nat,
        extracted=extracted,
    )


@router.post("/submit", response_model=RegistrationSubmitResponse)
async def submit_registration(
    payload: RegistrationPayload, 
    update_id: Optional[str] = Query(None, description="ID registrazione da aggiornare")
):
    try:
        # Passiamo update_id al service
        result = service.submit(payload, registration_id=update_id)
        return RegistrationSubmitResponse(
            registration_id=result.registration_id,
            timestamp_iso=result.timestamp_iso,
            pdf_filename=result.pdf_filename,
            emailed_to=result.emailed_to,
        )
    except FileNotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/details/{registration_id}")
async def get_registration_details(registration_id: str):
    """Restituisce il JSON completo per la modifica."""
    try:
        data = service.get_registration_details(registration_id)
        return data
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Registrazione non trovata")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/list")
async def list_registrations(
    limit: int = Query(200, ge=1, le=2000),
    offset: int = Query(0, ge=0),
    q: Optional[str] = Query(None, description="Filtro testuale (nome, cognome, email, id)"),
):
    items = service.list_registrations(limit=limit, offset=offset, query=q)
    return {"items": items}


@router.post("/{registration_id}/lock")
async def set_registration_lock(
    registration_id: str,
    body: dict = Body(...),
):
    locked = bool(body.get("locked", True))
    try:
        return service.set_locked(registration_id, locked)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Registrazione non trovata")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{registration_id}/pdf")
async def get_pdf(registration_id: str):
    try:
        pdf_path = service.find_pdf_path(registration_id)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="PDF non trovato")

    return FileResponse(
        pdf_path,
        media_type="application/pdf",
        filename=f"registrazione_{registration_id}.pdf",
    )
<FILE_END>

<FILE_START path="backend\app\api\v1\endpoints\vision.py">
from fastapi import APIRouter, UploadFile, File, Form, HTTPException
from PIL import Image
import io
from app.services.local_vision_service import analyze_documents_locally

router = APIRouter()


@router.post("/analyze")
async def analyze_document(
    front: UploadFile = File(...),
    back: UploadFile = File(None),
    doc_type: str = Form("AUTO"),  # default pi√π sensato
    use_local: bool = Form(True),  # compat
):
    """
    Riceve le immagini e un hint opzionale sul tipo di documento.
    """
    # 1. Leggi fronte
    try:
        f_content = await front.read()
        front_image = Image.open(io.BytesIO(f_content)).convert("RGB")
    except Exception:
        raise HTTPException(status_code=400, detail="Immagine Fronte non valida")

    # 2. Leggi retro (se c'√®)
    back_image = None
    if back:
        try:
            b_content = await back.read()
            back_image = Image.open(io.BytesIO(b_content)).convert("RGB")
        except Exception:
            back_image = None

    hint = (doc_type or "AUTO").strip()
    print(f"üß† Analisi Vision avviata. Hint: {hint}")

    # ‚úÖ Passaggio POSIZIONALE (anti 'unexpected keyword argument' se cambiano i nomi)
    result = analyze_documents_locally(front_image, back_image, hint)

    return result
<FILE_END>

<FILE_START path="backend\app\api\v1\endpoints\waivers.py">
from __future__ import annotations

import os
from fastapi import APIRouter, HTTPException, Request, Query
from fastapi.responses import FileResponse

from app.services.waiver_service import (
    WaiverService,
    WaiverDraftRequest,
    WaiverDraftResponse,
    WaiverFinalizeRequest,
    WaiverFinalizeResponse,
)

router = APIRouter()


def _public_base_url(request: Request) -> str:
    # Se sei dietro reverse proxy, in produzione metteremo header forward.
    # Per ora ok cos√¨ in locale.
    return str(request.base_url).rstrip("/")


@router.post("/waivers/draft", response_model=WaiverDraftResponse)
def create_draft(req: WaiverDraftRequest, request: Request):
    try:
        svc = WaiverService()
        return svc.create_draft(req=req, public_base_url=_public_base_url(request))
    except ValueError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Errore draft: {e}")


@router.post("/waivers/{waiver_id}/finalize", response_model=WaiverFinalizeResponse)
def finalize(waiver_id: str, req: WaiverFinalizeRequest, request: Request):
    try:
        svc = WaiverService()
        return svc.finalize(waiver_id=waiver_id, req=req, public_base_url=_public_base_url(request))
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="waiver_id non trovato")
    except ValueError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Errore finalize: {e}")


@router.get("/waivers/{waiver_id}/pdf")
def get_pdf(waiver_id: str, which: str = Query(default="final", pattern="^(draft|final)$")):
    # Nota: in produzione potresti voler mettere auth o token temporanei
    from pathlib import Path
    base = Path(__file__).resolve().parents[3] / "storage" / "waivers" / waiver_id
    pdf = base / ("draft.pdf" if which == "draft" else "final.pdf")
    if not pdf.exists():
        raise HTTPException(status_code=404, detail="PDF non trovato")
    return FileResponse(path=str(pdf), media_type="application/pdf", filename=f"{waiver_id}_{which}.pdf")
<FILE_END>

<FILE_START path="backend\app\api\v1\endpoints\__init__.py">
<FILE_END>

<FILE_START path="backend\app\schemas\registration.py">
from __future__ import annotations

from typing import Literal, Optional
from pydantic import BaseModel, Field, EmailStr, ConfigDict, model_validator
from datetime import datetime

CitizenshipChoice = Literal["ITALIANA", "NON_ITALIANA"]

DocType = Literal[
    "CIE",
    "CI_CARTACEA",
    "PATENTE_IT",
    "PASSAPORTO",
    "PERMESSO_SOGGIORNO",
    "ALTRO",
]

class LegalConsents(BaseModel):
    privacy: bool = False
    informed_consent: bool = Field(False, alias="informedConsent")
    responsibility: bool = False
    tesseramento: bool = False
    
    # Scelte obbligatorie Si/No
    photo: bool = False 
    newsletter: bool = False

    model_config = ConfigDict(populate_by_name=True)

class PersonData(BaseModel):
    # FIX: Aggiunto populate_by_name=True per accettare sia 'legal_consents' che 'legalConsents'
    model_config = ConfigDict(extra="allow", populate_by_name=True)

    nome: str = Field(..., min_length=1)
    cognome: str = Field(..., min_length=1)
    data_nascita: str = Field(..., description="dd/mm/yyyy")
    
    # Geografici
    stato_nascita: Optional[str] = None
    comune_nascita: Optional[str] = None
    
    stato_residenza: Optional[str] = None
    comune_residenza: Optional[str] = None
    indirizzo_residenza: Optional[str] = None 

    cittadinanza_scelta: Optional[CitizenshipChoice] = None

    # Documento
    tipo_documento: DocType = Field(..., description="Tipo documento obbligatorio")
    numero_documento: str = Field(..., min_length=2)
    scadenza_documento: str = Field(..., description="dd/mm/yyyy")

    source: Optional[str] = None
    
    # Firma specifica per questa persona
    signature_base64: Optional[str] = None

    # Consensi specifici per questa persona
    legal_consents: Optional[LegalConsents] = Field(default=None, alias="legalConsents")

class ContactData(BaseModel):
    email: EmailStr
    telefono: str = Field(..., min_length=5)

class RegistrationPayload(BaseModel):
    """
    Payload registrazione.
    """
    model_config = ConfigDict(populate_by_name=True)

    language: str = "it"
    booking_id: Optional[str] = None

    tutor_participates: Optional[bool] = Field(default=None, alias="tutorParticipates")
    has_minors: Optional[bool] = Field(default=None, alias="hasMinors")

    is_minor: bool = False
    participant: PersonData
    guardian: Optional[PersonData] = None

    contact: ContactData
    
    # Manteniamo il root legal per retrocompatibilit√†
    legal: Optional[LegalConsents] = None

    signature_base64: str = Field(..., alias="signatureBase64")

    @model_validator(mode="after")
    def _validate(self):
        # 1. Validazione Consensi (Priorit√† a quelli dentro participant)
        consents = self.participant.legal_consents or self.legal
        
        if not consents:
             raise ValueError(f"Consensi mancanti per {self.participant.nome}")

        if not consents.privacy:
            raise ValueError(f"Privacy Policy non accettata per {self.participant.nome}")
        if not consents.informed_consent:
            raise ValueError(f"Consenso informato non accettato per {self.participant.nome}")
        
        # 2. Minore e Guardian
        if self.is_minor and self.guardian is None:
            raise ValueError("Partecipante minorenne: guardian obbligatorio.")

        # 3. Validit√† Date
        self._check_date_format(self.participant.data_nascita, "Data nascita partecipante")
        self._check_date_format(self.participant.scadenza_documento, "Scadenza documento partecipante")
        
        if self.guardian:
            self._check_date_format(self.guardian.data_nascita, "Data nascita tutore")
            self._check_date_format(self.guardian.scadenza_documento, "Scadenza documento tutore")

        # 4. Firma
        if not self.signature_base64 or len(self.signature_base64.strip()) < 20:
            raise ValueError("Firma principale mancante o non valida.")

        return self

    def _check_date_format(self, date_str: str, field_name: str):
        try:
            datetime.strptime(date_str, "%d/%m/%Y")
        except ValueError:
            raise ValueError(f"{field_name}: formato data non valido (richiesto GG/MM/AAAA)")

class DocumentScanResponse(BaseModel):
    detected_doc_type: DocType
    mrz_nationality: Optional[str] = None
    extracted: dict = Field(default_factory=dict)

class RegistrationSubmitResponse(BaseModel):
    registration_id: str
    timestamp_iso: str
    pdf_filename: str
    emailed_to: Optional[EmailStr] = None
<FILE_END>

<FILE_START path="backend\app\schemas\__init__.py">
<FILE_END>

<FILE_START path="backend\app\services\document_specs.py">
from __future__ import annotations
import re

# ==============================================================================
# DOCUMENT SPECIFICATIONS & REGEX KNOWLEDGE BASE
# Reference: Configurazione Nuovi Campi Documenti Stranieri.pdf (Sez. 3, 6.1)
# ==============================================================================

# Regex universale per date (dd/mm/yyyy, dd.mm.yyyy, dd-mm-yyyy)
# Fonte: Tabella 1, Sez 6.1 [cite: 887]
GENERIC_DATE_REGEX = re.compile(r"\b(0[1-9]|[12]\d|3[01])[-/.](0[1-9]|1[0-2])[-/.](19|20)\d{2}\b")

DOCUMENT_SPECS = {
    "CIE": {
        # Keywords per il "Promo Step" (Validazione preliminare) [cite: 726]
        "keywords": [
            "CARTA D'IDENTITA", 
            "IDENTITY CARD", 
            "REPUBBLICA ITALIANA",
            "MINISTERO DELL'INTERNO"
        ],
        # Regex Rigida CIE 3.0: Inizia con C, 1 lettera, 5 numeri, 2 lettere 
        "doc_number_regex": re.compile(r"\b[C][A-Z]\d{5}[A-Z]{2}\b"),
        "has_mrz": True,
        "required_sides": ["FRONT", "BACK"], # Retro obbligatorio per indirizzo 
        "date_format": "%d/%m/%Y",
        "description": "Carta d'Identit√† Elettronica Italiana"
    },

    "PATENTE_IT": {
        # Keywords identificative [cite: 773]
        "keywords": [
            "PATENTE DI GUIDA", 
            "DRIVING LICENSE", 
            "REPUBBLICA ITALIANA"
        ],
        # Regex Unificata: Formato Card (2L 7N 1L) O Formato U1 (U1 + 7+ alfanum) [cite: 781, 886]
        "doc_number_regex": re.compile(r"(?i)\b(U1[0-9A-Z]{7,}|[A-Z]{2}\d{7}[A-Z])\b"),
        "has_mrz": False,
        "required_sides": ["FRONT"], # Dati principali solo fronte [cite: 833]
        "date_format": "%d/%m/%Y",
        "description": "Patente di Guida Italiana"
    },

    "PASSAPORTO": {
        "keywords": [
            "PASSAPORTO", 
            "PASSPORT"
        ],
        # Standard Internazionale Generico (9 chars) o Italiano (2L 7N) 
        # Usiamo il pattern ICAO 9 chars come baseline robusta
        "doc_number_regex": re.compile(r"\b[A-Z0-9]{9}\b"),
        "has_mrz": True,
        "required_sides": ["FRONT"], # Indirizzo non affidabile su passaporto [cite: 764]
        "date_format": "%d %b %Y", # Es. 22 JAN 2026
        "description": "Passaporto Internazionale/Italiano"
    },

    "CI_CARTACEA": {
        "keywords": [
            "CARTA D'IDENTITA", 
            "REPUBBLICA ITALIANA", 
            "CONNOTATI"
        ],
        # Vecchio formato cartaceo: 2 lettere + 7 numeri (spesso con spazi)
        "doc_number_regex": re.compile(r"\b[A-Z]{2}\s?\d{7}\b"),
        "has_mrz": False,
        "required_sides": ["FRONT", "BACK"], # Dati sparsi su due lati
        "date_format": "%d/%m/%Y",
        "description": "Carta d'Identit√† Cartacea (Vecchio Modello)"
    },

    "PERMESSO_SOGGIORNO": {
        "keywords": [
            "PERMESSO DI SOGGIORNO", 
            "RESIDENCE PERMIT"
        ],
        # Pattern generico alphanumeric
        "doc_number_regex": re.compile(r"\b[A-Z0-9]{8,12}\b"),
        "has_mrz": True,
        "required_sides": ["FRONT"],
        "date_format": "%d/%m/%Y",
        "description": "Permesso di Soggiorno"
    },

    "ALTRO": {
        "keywords": [],
        "doc_number_regex": None, # Nessuna validazione rigida, ci affidiamo a GLINER [cite: 892]
        "has_mrz": False,
        "required_sides": ["FRONT"],
        "date_format": "%d/%m/%Y",
        "description": "Documento Generico / Estero non classificato"
    }
}

# Alias per CIE Europee generiche (mappate come logica light)
DOCUMENT_SPECS["CIE_EU"] = {
    "keywords": ["IDENTITY CARD", "PERSONALAUSWEIS", "CARTE D'IDENTITE"],
    "doc_number_regex": re.compile(r"\b[A-Z0-9]{8,12}\b"), # [cite: 833]
    "has_mrz": True,
    "required_sides": ["FRONT", "BACK"],
    "date_format": "%d/%m/%Y",
    "description": "Carta d'Identit√† UE (Non Italiana)"
}
<FILE_END>

<FILE_START path="backend\app\services\image_utils.py">
# backend/app/services/image_utils.py
import cv2
import numpy as np
import os
import time
import uuid
from pathlib import Path
from PIL import Image

# [FASE 2] Integrazione Libreria YOLO
try:
    from ultralytics import YOLO
    YOLO_AVAILABLE = True
except ImportError:
    YOLO_AVAILABLE = False
    print("‚ö†Ô∏è Ultralytics non installato. YOLO non disponibile.")

# --- CONFIGURAZIONE PERCORSI ROBUSTA ---
BASE_DIR = Path(__file__).resolve().parent.parent.parent
DEBUG_DIR = BASE_DIR / "storage" / "debug_captures"
DATASET_DIR = BASE_DIR / "storage" / "dataset_raw"
MODELS_DIR = BASE_DIR / "assets" / "models"

# Costanti per la standardizzazione ID-1 (formato carta di credito/CIE/Patente)
# Rapporto aspetto standard: 85.60mm / 53.98mm ‚âà 1.585
TARGET_WIDTH = 1000
TARGET_HEIGHT = 630 # 1000 / 1.585

try:
    DEBUG_DIR.mkdir(parents=True, exist_ok=True)
    DATASET_DIR.mkdir(parents=True, exist_ok=True)
    MODELS_DIR.mkdir(parents=True, exist_ok=True)
except Exception as e:
    print(f"‚ùå ERRORE CREAZIONE DIR: {e}")

# --- SINGLETON MODELLO YOLO ---
_yolo_model = None

def get_yolo_model():
    """
    Carica il modello YOLOv11n-OBB una volta sola (Singleton).
    """
    global _yolo_model
    if not YOLO_AVAILABLE:
        return None
        
    if _yolo_model is None:
        model_path = MODELS_DIR / "id_card_detector_v11n.pt"
        if model_path.exists():
            print(f"üß† [SETUP] Caricamento Modello YOLO da: {model_path}")
            try:
                _yolo_model = YOLO(str(model_path))
                print("üß† [SETUP] Modello caricato correttamente.")
            except Exception as e:
                print(f"‚ùå [SETUP] Errore caricamento pesi YOLO: {e}")
                return None
        else:
            print(f"‚ö†Ô∏è [SETUP] Modello YOLO non trovato in {model_path}. Esegui il training prima!")
            return None
    return _yolo_model

def order_points(pts):
    """
    Ordina le coordinate (top-left, top-right, bottom-right, bottom-left)
    necessario per il perspective warp corretto.
    """
    rect = np.zeros((4, 2), dtype="float32")
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)] # TL
    rect[2] = pts[np.argmax(s)] # BR
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)] # TR
    rect[3] = pts[np.argmax(diff)] # BL
    return rect

def isolate_document_yolo(image: Image.Image, debug_prefix: str = "yolo") -> Image.Image | None:
    """
    [FASE 2 STRATEGIA]
    Usa YOLOv11-OBB per rilevare il documento, trovare i 4 angoli 
    e applicare la correzione prospettica (Warp) su una griglia standardizzata.
    Include LOG DETTAGLIATI per debug.
    """
    print(f"\nüîç [YOLO DETECT] Avvio analisi su immagine sorgente ({debug_prefix})")
    
    model = get_yolo_model()
    if model is None:
        print("   ‚ùå [YOLO] Modello non caricato. Salto.")
        return None
    
    if image is None:
        print("   ‚ùå [YOLO] Immagine input vuota (None).")
        return None

    img_cv = pil_to_cv2(image)
    if img_cv is None: 
        print("   ‚ùå [YOLO] Conversione PIL->CV2 fallita.")
        return None

    # Inferenza (verbose=False per pulizia log, li facciamo noi manuali)
    results = model(img_cv, verbose=False)
    
    if not results or len(results) == 0:
        print(f"   ‚ùå [YOLO] Nessun risultato restituito dal modello.")
        return None

    r = results[0]
    
    # Controllo se √® OBB
    if r.obb is None or len(r.obb) == 0:
        print(f"   ‚ö†Ô∏è [YOLO] Nessun oggetto rilevato (OBB vuoto).")
        return None

    # Prendi il box con confidenza maggiore
    best_idx = int(r.obb.conf.argmax())
    conf = float(r.obb.conf[best_idx])
    
    # LOG CONFIDENZA
    print(f"   ‚úÖ [YOLO] Documento TROVATO! Confidenza: {conf:.4f}")
    
    # Estrazione angoli (xyxyxyxy)
    corners = r.obb.xyxyxyxy[best_idx].cpu().numpy()
    
    # LOG COORDINATE GREZZE
    print(f"      [YOLO] Angoli grezzi rilevati:\n{corners}")
    
    # 1. Ordina i punti rilevati: TL, TR, BR, BL
    rect = order_points(corners)
    (tl, tr, br, bl) = rect

    # 2. Calcola larghezza e altezza reali rilevate (per decidere l'orientamento)
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    detected_width = max(int(widthA), int(widthB))

    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    detected_height = max(int(heightA), int(heightB))
    
    # LOG DIMENSIONI
    print(f"      [YOLO] Dimensioni stimate crop: {detected_width}x{detected_height} px")

    # 3. Logica "Smart Orientation"
    final_w, final_h = TARGET_WIDTH, TARGET_HEIGHT
    
    # Se l'altezza rilevata √® maggiore della larghezza, la carta √® verticale (ruotata di 90 o 270)
    is_vertical = detected_height > detected_width
    
    if is_vertical:
            print(f"      [YOLO] üîÑ Rilevata carta VERTICALE (H > W). Preparo rotazione per OCR...")
            # Impostiamo il target del warp verticale (630x1000)
            warp_w, warp_h = TARGET_HEIGHT, TARGET_WIDTH 
    else:
            print(f"      [YOLO] ‚û°Ô∏è Rilevata carta ORIZZONTALE. Procedo standard.")
            # Impostiamo il target del warp orizzontale (1000x630)
            warp_w, warp_h = TARGET_WIDTH, TARGET_HEIGHT

    # Punti sorgente (dal detection)
    src_pts = rect
    
    # Punti destinazione (rettangolo perfetto)
    dst_dynamic = np.array([
        [0, 0],
        [warp_w - 1, 0],
        [warp_w - 1, warp_h - 1],
        [0, warp_h - 1]], dtype="float32")

    # Calcolo matrice e Warp
    M = cv2.getPerspectiveTransform(src_pts, dst_dynamic)
    warped = cv2.warpPerspective(img_cv, M, (warp_w, warp_h))
    
    # Se abbiamo fatto il warp verticale, ora ruotiamo di 90¬∞ per averla orizzontale
    if is_vertical:
        warped = cv2.rotate(warped, cv2.ROTATE_90_CLOCKWISE)
        print("      [YOLO] üîÑ Rotazione 90¬∞ applicata post-warp.")

    # A questo punto abbiamo SEMPRE un'immagine ~1000x630 orizzontale.
    _save_debug_step(warped, debug_prefix, "YOLO_WARP_HD")
    
    print(f"      [YOLO] ‚úÖ Operazione completata. Immagine pronta per OCR.")
    return cv2_to_pil(warped)


def save_raw_dataset_image(img, label: str):
    """
    Salva l'immagine grezza in storage/dataset_raw per il futuro training di YOLOv11.
    """
    if img is None: return
    try:
        unique_id = str(uuid.uuid4())[:8]
        ts = int(time.time())
        filename = f"{ts}_{unique_id}_{label}.jpg"
        path = DATASET_DIR / filename
        if isinstance(img, Image.Image):
            img.save(str(path), quality=95)
        else:
            cv2.imwrite(str(path), img)
    except Exception as e:
        print(f"   ‚ö†Ô∏è [DATASET ERROR]: {e}")

def _save_debug_step(img, prefix, step_name):
    if img is None: return None
    try:
        ts = int(time.time() * 1000)
        safe_prefix = "".join(c for c in prefix if c.isalnum() or c in ('_', '-'))
        filename = f"debug_{safe_prefix}_{ts}_{step_name}.jpg"
        path = DEBUG_DIR / filename
        if isinstance(img, Image.Image):
            img.save(str(path))
        else:
            cv2.imwrite(str(path), img)
        return filename
    except Exception as e:
        print(f"   ‚ùå [DEBUG ERROR] {step_name}: {e}")
        return None

def cv2_to_pil(img_cv):
    if img_cv is None: return None
    try:
        if len(img_cv.shape) == 2: return Image.fromarray(img_cv)
        if len(img_cv.shape) == 3 and img_cv.shape[2] == 3:
            return Image.fromarray(cv2.cvtColor(img_cv, cv2.COLOR_BGR2RGB))
        if len(img_cv.shape) == 3 and img_cv.shape[2] == 4:
            return Image.fromarray(cv2.cvtColor(img_cv, cv2.COLOR_BGRA2RGBA))
        return Image.fromarray(img_cv)
    except: return None

def pil_to_cv2(img_pil):
    try:
        if img_pil.mode != "RGB":
            img_pil = img_pil.convert("RGB")
        return cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR)
    except: return None

# --- FUNZIONI LEGACY/HELPER (Mantenute per retrocompatibilit√†) ---
def apply_clahe(image):
    try:
        if len(image.shape) == 3:
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        else:
            gray = image
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        return clahe.apply(gray)
    except:
        return image

def align_images_orb(image, template, max_features=5000, debug_prefix="align", mask=None):
    # Deprecato in favore di YOLO, ma mantenuto per sicurezza
    try:
        if image is None or template is None: return None
        h_tpl, w_tpl = template.shape[:2]
        h_img, w_img = image.shape[:2]
        scale_factor = 1.0
        working_image = image.copy()
        if w_img > w_tpl * 1.5:
            scale_factor = w_tpl / w_img
            new_w = int(w_img * scale_factor)
            new_h = int(h_img * scale_factor)
            working_image = cv2.resize(image, (new_w, new_h), interpolation=cv2.INTER_AREA)

        imgGray = apply_clahe(working_image)
        tmplGray = apply_clahe(template)
        orb = cv2.ORB_create(nfeatures=max_features)
        kpsA, descsA = orb.detectAndCompute(imgGray, None)
        kpsB, descsB = orb.detectAndCompute(tmplGray, mask=mask)

        if descsA is None or descsB is None: return None
        matcher = cv2.DescriptorMatcher_create(cv2.DESCRIPTOR_MATCHER_BRUTEFORCE_HAMMING)
        knn_matches = matcher.knnMatch(descsA, descsB, 2)
        good_matches = []
        for m, n in knn_matches:
            if m.distance < 0.75 * n.distance: good_matches.append(m)

        if len(good_matches) < 10: return None
        ptsA = np.zeros((len(good_matches), 2), dtype="float")
        ptsB = np.zeros((len(good_matches), 2), dtype="float")
        for (i, m) in enumerate(good_matches):
            ptsA[i] = np.array(kpsA[m.queryIdx].pt) * (1.0 / scale_factor)
            ptsB[i] = kpsB[m.trainIdx].pt

        (H, mask_ransac) = cv2.findHomography(ptsA, ptsB, method=cv2.RANSAC, ransacReprojThreshold=5.0)
        if H is None: return None
        (h, w) = template.shape[:2]
        aligned = cv2.warpPerspective(image, H, (w, h))
        return aligned
    except Exception as e:
        print(f"‚ùå ALIGN CRASH: {e}")
        return None

def enhance_image_for_mrz(pil_image, debug_prefix="mrz"):
    try:
        image = pil_to_cv2(pil_image)
        if image is None: return pil_image
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) if len(image.shape) == 3 else image
        h, w = gray.shape[:2]
        if w < 1000:
            scale = 2.0
            gray = cv2.resize(gray, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        gray = clahe.apply(gray)
        _, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
        thresh = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=1)
        return cv2_to_pil(thresh)
    except Exception: return pil_image

def enhance_field_crop(pil_image, debug_prefix="field"):
    try:
        image = pil_to_cv2(pil_image)
        if image is None: return pil_image
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) if len(image.shape) == 3 else image
        h, w = gray.shape[:2]
        if h < 60:
            scale = 2.0
            gray = cv2.resize(gray, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)
        gray = cv2.fastNlMeansDenoising(gray, None, 10, 7, 21)
        blur = cv2.GaussianBlur(gray, (25, 25), 0)
        norm = cv2.divide(gray, blur, scale=255)
        binary = cv2.adaptiveThreshold(norm, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 15, 5)
        return cv2_to_pil(binary)
    except Exception: return pil_image

def assess_image_quality(image_cv):
    if image_cv is None: return False, {"error": "No image"}
    try:
        gray = cv2.cvtColor(image_cv, cv2.COLOR_BGR2GRAY)
        blur_score = cv2.Laplacian(gray, cv2.CV_64F).var()
        mean_brightness = np.mean(gray)
        return True, {"blur": blur_score, "brightness": mean_brightness}
    except: return False, {}
<FILE_END>

<FILE_START path="backend\app\services\local_vision_service.py">
# backend/app/services/local_vision_service.py
from __future__ import annotations
import os
import re
import time
import logging
import threading
import numpy as np
from datetime import datetime
from PIL import Image
from pathlib import Path

# Importiamo la Knowledge Base
from app.services.document_specs import DOCUMENT_SPECS, GENERIC_DATE_REGEX

# --- CONFIGURAZIONE AMBIENTALE ---
os.environ["FLAGS_use_mkldnn"] = "0"
os.environ["FLAGS_enable_mkldnn"] = "0"
os.environ["GLOG_minloglevel"] = "2"
os.environ["DISABLE_MODEL_SOURCE_CHECK"] = "True"

logger = logging.getLogger("vision_service")
logger.setLevel(logging.INFO)
if not logger.handlers:
    handler = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

# --- IMPORT MODULI AI ---
try:
    import paddle
    from paddleocr import PaddleOCR
    paddle.set_device('cpu') 
    PADDLE_AVAILABLE = True
except ImportError as e:
    PADDLE_AVAILABLE = False
    logger.error(f"PaddleOCR non disponibile: {e}")

try:
    from gliner import GLiNER
    GLINER_AVAILABLE = True
except ImportError as e:
    GLINER_AVAILABLE = False
    logger.warning(f"GLINER non disponibile: {e}")

from app.services.image_utils import (
    isolate_document_yolo, 
    pil_to_cv2, 
    save_raw_dataset_image
)

# --- CONFIGURAZIONE SCHEMI DI ESTRAZIONE ---
STANDARD_SCHEMA = {
    "cognome": {"labels": ["Cognome", "Surname", "Last Name"], "threshold": 0.40, "type": "text"},
    "nome": {"labels": ["Nome", "Name", "Given Names"], "threshold": 0.40, "type": "text"},
    "data_nascita": {"labels": ["Data di nascita", "Birth Date", "Nato il"], "threshold": 0.30, "type": "date"},
    "comune_nascita": {"labels": ["Luogo di nascita", "Comune di nascita", "Place of Birth", "Nato a"], "threshold": 0.25, "type": "text"},
    "comune_residenza": {"labels": ["Comune di residenza", "Citt√†", "Residenza", "Abitazione", "Living in"], "threshold": 0.20, "type": "text"},
    "codice_fiscale": {"labels": ["Codice Fiscale", "Tax Code", "CF"], "threshold": 0.35, "type": "alphanum"},
    "numero_documento": {"labels": ["Numero Documento", "Card Number", "Document No"], "threshold": 0.30, "type": "alphanum"},
    "scadenza_documento": {"labels": ["Scadenza", "Valid until", "Expiry Date"], "threshold": 0.30, "type": "date"},
    "cittadinanza": {"labels": ["Cittadinanza", "Nationality"], "threshold": 0.45, "type": "text"}
}

PATENTE_SCHEMA = {
    "cognome": {"labels": ["1.", "Cognome"], "threshold": 0.30, "type": "text"},
    "nome": {"labels": ["2.", "Nome"], "threshold": 0.30, "type": "text"},
    "data_nascita": {"labels": ["3.", "Data di nascita"], "threshold": 0.30, "type": "date"},
    "comune_nascita": {"labels": ["3.", "Luogo di nascita"], "threshold": 0.25, "type": "text"},
    "data_rilascio": {"labels": ["4a.", "Rilascio"], "threshold": 0.30, "type": "date"},
    "scadenza_documento": {"labels": ["4b.", "Scadenza"], "threshold": 0.30, "type": "date"},
    "numero_documento": {"labels": ["5.", "Numero Patente"], "threshold": 0.30, "type": "alphanum"},
    "ente_rilascio": {"labels": ["4c.", "Rilasciato da"], "threshold": 0.25, "type": "text"}
}

BLACKLIST_VALUES = [
    "COGNOME", "NOME", "NATO", "IL", "RESIDENZA", "CITTADINANZA", 
    "LUOGO", "COMUNE", "VIA", "PIAZZA", "SCADENZA", "RILASCIO", "EMISSIONE", 
    "SURNAME", "NAME", "DATE", "BIRTH", "PLACE", "ADDRESS", "SEX", "F", "M",
    "REPUBBLICA", "ITALIANA", "MINISTERO", "INTERNO", "FISCAL", "CODE",
    "DRIVING", "LICENSE", "PERMESSO", "SOGGIORNO"
]

FRONT_ONLY_KEYS = ["nome", "cognome", "data_nascita", "comune_nascita", "numero_documento", "scadenza_documento", "cittadinanza"]
BACK_ONLY_KEYS = ["comune_residenza", "codice_fiscale"]

# -------------------------
# BACKEND CLASSES
# -------------------------
class PaddleBackend:
    _instance = None
    _lock = threading.Lock()
    model = None

    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = cls()
        return cls._instance

    def __init__(self):
        if not PADDLE_AVAILABLE: return
        logger.info("‚ö° Init PaddleOCR...")
        try:
            self.model = PaddleOCR(use_angle_cls=True, lang='it', enable_mkldnn=False, show_log=False, use_gpu=False)
            self.model.ocr(np.zeros((100, 100, 3), dtype=np.uint8), cls=True)
            logger.info("‚úÖ PaddleOCR Pronto.")
        except Exception as e:
            logger.critical(f"‚ùå Errore Init PaddleOCR: {e}")
            self.model = None

    def infer(self, img_array: np.ndarray):
        if not self.model: return None
        with self._lock: 
            try:
                return self.model.ocr(img_array, cls=True)
            except Exception as e:
                logger.error(f"Paddle Inference Crash: {e}")
                return None

class GlinerBackend:
    _model = None
    @classmethod
    def get_model(cls):
        if not GLINER_AVAILABLE: return None
        if cls._model is None:
            logger.info("üß† Caricamento GLINER...")
            try:
                cls._model = GLiNER.from_pretrained("urchade/gliner_medium-v2.1")
            except Exception as e:
                logger.error(f"Errore GLINER: {e}")
        return cls._model

# -------------------------
# HELPERS
# -------------------------
def _mrz_char_value(c):
    if '0' <= c <= '9': return int(c)
    if 'A' <= c <= 'Z': return ord(c) - 55
    return 0

def _calculate_mrz_checksum(value_str):
    weights = [7, 3, 1]
    total = 0
    for i, char in enumerate(value_str):
        val = _mrz_char_value(char)
        weight = weights[i % 3]
        total += val * weight
    return total % 10

def _validate_and_fix_mrz_field(raw_value, expected_check_digit):
    if not raw_value or not expected_check_digit.isdigit():
        return None, False
    if str(_calculate_mrz_checksum(raw_value)) == expected_check_digit:
        return raw_value, True
    corrections = {'O': '0', 'I': '1', 'Z': '2', 'S': '5', 'B': '8', 'D': '0'}
    fixed_val = list(raw_value)
    for i, char in enumerate(fixed_val):
        if char in corrections: fixed_val[i] = corrections[char]
    fixed_str = "".join(fixed_val)
    if str(_calculate_mrz_checksum(fixed_str)) == expected_check_digit:
        print(f"      üîß MRZ Checksum Fix: {raw_value} -> {fixed_str}")
        return fixed_str, True
    return raw_value, False

def _extract_mrz_data(text_blob: str, label: str = "GENERIC") -> dict:
    if not text_blob or len(text_blob) < 30: return {}

    print(f"\n   üïµÔ∏è [MRZ SCANNER - {label}] Analisi e Ricostruzione...")
    schema = {}
    
    compact_text = text_blob.replace(" ", "").replace("\n", "").upper()
    fuzzy_mrz = re.sub(r"[K¬´\(\{\[\¬£]", "<", compact_text)
    
    # 1. Numeri e Date
    ita_anchor = re.search(r"([ACIPV]<|[ACIPV])ITA", fuzzy_mrz)
    
    if ita_anchor:
        start_idx = ita_anchor.start()
        stream = fuzzy_mrz[start_idx:]
        anchor_len = len(ita_anchor.group(0))
        
        raw_doc_num = stream[anchor_len : anchor_len+9]
        doc_check = stream[anchor_len+9 : anchor_len+10]
        
        val_doc, ok_doc = _validate_and_fix_mrz_field(raw_doc_num, doc_check)
        if ok_doc:
            schema["numero_documento"] = val_doc
            first_char = ita_anchor.group(0)[0]
            if first_char in ['C', 'I']: schema["tipo_documento"] = "CIE"
            elif first_char == 'P': schema["tipo_documento"] = "PASSAPORTO"
            print(f"      ‚úÖ DOC NUM VALIDATO: {val_doc}")
        elif re.match(r"^[A-Z0-9]{9}$", raw_doc_num):
            schema["numero_documento"] = raw_doc_num

        date_candidates = re.finditer(r"(\d{6})(\d)([MF<X])(\d{6})(\d)", stream)
        for match in date_candidates:
            birth_raw, birth_check, sex, expiry_raw, expiry_check = match.groups()
            
            # Data Nascita
            v_birth, ok_birth = _validate_and_fix_mrz_field(birth_raw, birth_check)
            if ok_birth:
                try:
                    yy, mm, dd = int(v_birth[:2]), int(v_birth[2:4]), int(v_birth[4:])
                    if 1 <= mm <= 12 and 1 <= dd <= 31:
                        curr_yy = int(datetime.now().strftime("%y"))
                        prefix = "19" if yy > (curr_yy + 5) else "20"
                        schema["data_nascita"] = f"{dd:02d}/{mm:02d}/{prefix}{yy:02d}"
                except: pass

            # Scadenza (Rilassiamo il check se il checksum fallisce ma la data √® valida e futura)
            v_exp, ok_exp = _validate_and_fix_mrz_field(expiry_raw, expiry_check)
            
            # Se la validazione fallisce, proviamo comunque a parsare la data grezza
            candidate_exp = v_exp if ok_exp else expiry_raw
            
            try:
                yy, mm, dd = int(candidate_exp[:2]), int(candidate_exp[2:4]), int(candidate_exp[4:])
                if 1 <= mm <= 12 and 1 <= dd <= 31:
                    full_year = 2000 + yy
                    # Accetta solo se √® nel futuro o recente passato (es. scaduta da poco)
                    if full_year >= datetime.now().year - 1:
                        schema["scadenza_documento"] = f"{dd:02d}/{mm:02d}/{full_year}"
                        if not ok_exp:
                            print(f"      ‚ö†Ô∏è MRZ EXPIRY Checksum Fail ma data valida: {schema['scadenza_documento']}")
            except: pass
                
            if sex in ['M', 'F']:
                schema['sesso'] = sex

    # 2. NOMI DA MRZ
    name_match = re.search(r"([A-Z]{2,})<<([A-Z]+)", fuzzy_mrz)
    if name_match:
        raw_sur = name_match.group(1)
        raw_names = name_match.group(2)
        if "ITA" not in raw_sur and "REPUBBLICA" not in raw_sur: 
            schema["cognome"] = raw_sur.replace("<", "").title()
            schema["nome"] = raw_names.replace("<", "").title()
            print(f"      ‚úÖ NOMI MRZ: {schema['cognome']} {schema['nome']}")

    return schema

def _inject_spaces_in_address(text: str) -> str:
    patterns = [
        (r'(?i)(VIA|PIAZZA|CORSO|L\.GO|LARGO|V\.LE|VIALE|STRADA)(?=[A-Z0-9])', r'\1 '),
        (r'(?i)(N\.|NUM\.)(?=[0-9])', r'\1 '), 
        (r'(?i)([a-z])(N\.|NUM\.)', r'\1 \2'),
    ]
    for p, r in patterns:
        text = re.sub(p, r, text)
    
    text = re.sub(r'(\d+)([A-Z]{3,})', r'\1 \2', text) 
    text = re.sub(r'([A-Z]{3,})(\d+)', r'\1 \2', text)
    
    return text

def _clean_text_blob(ocr_result, label="UNK") -> str:
    print(f"\n   üìù [OCR RAW {label}] Analisi righe grezze:")
    if not ocr_result: return ""
    raw_lines = ocr_result[0] if isinstance(ocr_result, list) and len(ocr_result) > 0 else []
    if not raw_lines: return ""

    sorted_lines = sorted(raw_lines, key=lambda line: sum([p[1] for p in line[0]]) / 4)
    text_parts = []
    for i, line in enumerate(sorted_lines):
        txt = line[1][0].strip()
        if len(txt) > 1:
            txt_fixed = _inject_spaces_in_address(txt)
            text_parts.append(txt_fixed)
            print(f"      Line {i}: {txt} -> {txt_fixed}")
            
    return "  ".join(text_parts)

def _smart_clean_field(raw_value: str, field_type: str, regex_pattern: re.Pattern | None = None) -> str | None:
    if not raw_value: return None
    val = raw_value.strip()
    
    # 1. VALIDAZIONE REGEX RIGIDA
    # Se viene passata una regex (es. per numero documento), DEVE matchare.
    # Altrimenti scartiamo il valore per evitare falsi positivi (es. "CARTA" invece di "CA12345AA")
    if regex_pattern:
        match = regex_pattern.search(val)
        if match:
            # Se la regex ha gruppi di cattura, preferiamo quelli (es. Patente U1...)
            if match.groups():
                for g in match.groups():
                    if g: return g
            return match.group(0)
        else:
            print(f"      ‚ö†Ô∏è RIGID CHECK FAIL: '{val}' non rispetta il pattern richiesto.")
            return None # Scarta il valore
    
    # 2. Pulizia standard per altri campi
    if field_type == "text":
        headers = ["CITTADINANZA", "LUOGO", "NASCITA", "NATA A", "TARTAA", "COMUNE", "RESIDENZA", "DI", "RILASCIATO", "DA"]
        for h in headers:
            val = re.sub(f"(?i){h}", "", val)
        val = re.sub(r"[^a-zA-Z√†√®√©√¨√≤√π√Ä√à√â√å√í√ô\s'\(\)-]", "", val) 
        return val.title().strip()
    elif field_type == "alphanum":
        return val.upper().replace(" ", "").replace(".", "").replace("-", "")
    elif field_type == "date":
        val = val.replace("-", "/").replace(".", "/").replace("\\", "/")
        val = re.sub(r"(\d{2})\s+(\d{2})\s+(\d{4})", r"\1/\2/\3", val)
        
        replacements = [('O', '0'), ('o', '0'), ('I', '1'), ('l', '1'), ('S', '5'), ('B', '8')]
        for old, new in replacements: val = val.replace(old, new)
        
        date_match = GENERIC_DATE_REGEX.search(val)
        if date_match: return date_match.group(0)
        return None
    elif field_type == "address":
        val = re.sub(r"\s+", " ", val)
        val = re.sub(r"^(RESIDENZA|ABITAZIONE|INDIRIZZO)\s*", "", val, flags=re.IGNORECASE)
        return val.strip()
    return val

def _run_gliner_extraction(text_blob: str, target_keys: list[str] | None = None, schema_map: dict = STANDARD_SCHEMA, doc_specs: dict = None) -> dict:
    if not target_keys: return {}
    
    print(f"\n   üß† [GLINER AI] Inferenza su campi: {target_keys}")
    gliner = GlinerBackend.get_model()
    if not gliner: return {}
    
    all_labels = []
    label_to_key_map = {}
    
    for key in target_keys:
        config = schema_map.get(key)
        if config:
            for lbl in config["labels"]:
                all_labels.append(lbl)
                label_to_key_map[lbl] = key
            
    mapped = {}
    try:
        entities = gliner.predict_entities(text_blob, all_labels, threshold=0.10)
        entities.sort(key=lambda x: x['score'], reverse=True)
        
        for e in entities:
            raw_label = e['label']
            txt = e['text'].strip()
            score = e['score']
            
            if txt.upper() in BLACKLIST_VALUES or len(txt) < 2: continue
            canonical_key = label_to_key_map.get(raw_label)
            if not canonical_key: continue
            
            field_conf = schema_map[canonical_key]
            if score < field_conf["threshold"]: continue
            
            if canonical_key not in mapped:
                # Iniezione Regex Specifica per Numero Documento
                spec_regex = None
                if canonical_key == "numero_documento" and doc_specs:
                    spec_regex = doc_specs.get("doc_number_regex")

                clean_val = _smart_clean_field(txt, field_conf["type"], regex_pattern=spec_regex)
                if clean_val:
                    mapped[canonical_key] = clean_val
                    print(f"      ‚úÖ {canonical_key}: {clean_val} (score {score:.2f})")
        return mapped
    except Exception as e:
        print(f"      ‚ùå GLINER Error: {e}")
        return {}

def _extract_and_repair_cf(text: str) -> str | None:
    digit_sim = r"[0-9OQILZASGB]"
    fuzzy_pattern = r"([A-Z]{6})(" + digit_sim + r"{2})([A-Z])(" + digit_sim + r"{2})([A-Z])(" + digit_sim + r"{3})([A-Z])"
    match = re.search(fuzzy_pattern, text.upper())
    if match:
        groups = list(match.groups())
        rep_map = {'O': '0', 'Q': '0', 'I': '1', 'L': '1', 'Z': '2', 'A': '4', 'S': '5', 'G': '6', 'B': '8'}
        for i in [1, 3, 5]:
            fixed = ""
            for char in groups[i]: fixed += rep_map.get(char, char)
            groups[i] = fixed
        final_cf = "".join(groups)
        print(f"      üîß CF REPAIR: {match.group(0)} -> {final_cf}")
        return final_cf
    return None

def _regex_fallback(text_blob: str, context: str = "ALL", doc_specs: dict = None) -> dict:
    schema = {}
    text_upper = text_blob.upper()
    text_compact = text_upper.replace(" ", "").replace("\n", "").replace(".", "").replace("-", "")
    
    # 1. CF con Riparazione
    if context in ["ALL", "BACK"]:
        cf_match = re.search(r'[A-Z]{6}\d{2}[A-Z]\d{2}[A-Z]\d{3}[A-Z]', text_compact)
        if cf_match:
            schema["codice_fiscale"] = cf_match.group(0)
            print(f"      üîß REGEX: Trovato CF: {cf_match.group(0)}")
        else:
            repaired = _extract_and_repair_cf(text_compact)
            if repaired: schema["codice_fiscale"] = repaired

    # 2. Doc Number Specifico
    if context in ["ALL", "FRONT"] and doc_specs:
        regex = doc_specs.get("doc_number_regex")
        if regex:
            # Cerchiamo nel testo originale o upper, NON in quello compatto (per evitare unioni strane)
            match = regex.search(text_blob) or regex.search(text_upper)
            if match:
                val = match.group(0)
                if match.groups():
                    for g in match.groups():
                        if g: val = g; break
                schema["numero_documento"] = val.replace(" ", "")
                print(f"      üîß REGEX SPECIFICA: Trovato Doc Num: {schema['numero_documento']}")

    # 3. Comune
    city_matches = re.finditer(r'([A-Z\s]{3,})\s*\(([A-Z]{2})\)', text_blob)
    found_cities = []
    for m in city_matches:
        city = m.group(1).strip()
        prov = m.group(2)
        city = re.sub(r"(CITTADINANZA|LUOGO|NASCITA|RESIDENZA|COMUNE|DI|NATA A|TARTAA)\s*", "", city, flags=re.IGNORECASE).strip()
        if len(city) > 2:
            found_cities.append(f"{city} ({prov})")
            
    if found_cities:
        if context == "FRONT" and not schema.get("comune_nascita"):
            schema["comune_nascita"] = found_cities[0]
        elif context == "BACK" and not schema.get("comune_residenza"):
            schema["comune_residenza"] = found_cities[0]

    # 4. Backup Date (Scadenza - Ora supporta spazi e formati rilassati)
    if not schema.get("scadenza_documento"):
        relaxed_date_regex = re.compile(r"\b(0[1-9]|[12]\d|3[01])[\s./-](0[1-9]|1[0-2])[\s./-](20\d{2})\b")
        date_matches = relaxed_date_regex.findall(text_blob)
        curr_year = datetime.now().year
        for d, m, y in date_matches:
            try:
                full_y = int(y)
                if full_y >= curr_year:
                    schema["scadenza_documento"] = f"{d}/{m}/{full_y}"
                    print(f"      üîß REGEX RELAXED: Trovata Scadenza: {schema['scadenza_documento']}")
                    break
            except: pass

    return schema

def _parse_cf_to_data(cf: str) -> dict:
    if len(cf) != 16: return {}
    data = {}
    try:
        yy = int(cf[6:8])
        month_map = {'A':1, 'B':2, 'C':3, 'D':4, 'E':5, 'H':6, 'L':7, 'M':8, 'P':9, 'R':10, 'S':11, 'T':12}
        mm = month_map.get(cf[8].upper())
        dd_val = int(cf[9:11])
        sex = 'M'
        dd = dd_val
        if dd_val > 40:
            sex = 'F'
            dd = dd_val - 40
        if mm and 1 <= dd <= 31:
            curr_year = datetime.now().year % 100
            prefix = "19" if yy > curr_year else "20"
            data["data_nascita"] = f"{dd:02d}/{mm:02d}/{prefix}{yy:02d}"
            data["sesso"] = sex
    except: pass
    return data

def verify_document_coherence(text_blob: str, doc_type: str) -> bool:
    specs = DOCUMENT_SPECS.get(doc_type)
    if not specs or not specs["keywords"]:
        return True 
    text_upper = text_blob.upper()
    for kw in specs["keywords"]:
        if kw in text_upper:
            print(f"     ‚úÖ [PROMO] Keyword trovata: {kw}")
            return True
    if specs.get("doc_number_regex") and specs["doc_number_regex"].search(text_upper):
        print(f"   ‚úÖ [PROMO] Keyword assente ma trovato numero documento valido.")
        return True
    print(f"   ‚ö†Ô∏è [PROMO] Nessuna keyword per {doc_type} trovata nel testo.")
    return False

def detect_nationality_context(text_blob: str, mrz_data: dict) -> bool:
    """Restituisce True se residente in Italia, False altrimenti"""
    if mrz_data.get("nationality") == "ITA" or mrz_data.get("issuing_state") == "ITA":
        return True
    text_upper = text_blob.upper()
    if "REPUBBLICA ITALIANA" in text_upper or "CITTADINANZA ITALIANA" in text_upper:
        return True
    if re.search(r"\bITA\b", text_upper):
        return True
    return False

# -------------------------
# CORE PIPELINE
# -------------------------
def analyze_documents_locally(front_img: Image.Image, back_img: Image.Image | None = None, doc_type_hint: str = "AUTO") -> dict:
    debug_log = {"steps": [], "sources": {}}
    
    print("\n" + "="*80)
    print(f"üöÄ AVVIO ANALISI IBRIDA V7.4 (Strict + DataCollect) [Time: {datetime.now().strftime('%H:%M:%S')}]")
    print(f"   Documento Dichiarato: {doc_type_hint}")
    print("="*80)
    
    final_data = {
        "source": "HYBRID_NEURAL_V7", 
        "tipo_documento": doc_type_hint if doc_type_hint != "AUTO" else "ALTRO"
    }
    
    # 0. DATASET COLLECTION (Phase 1 Strategia)
    # Salviamo l'immagine grezza per il training futuro
    if front_img:
        save_raw_dataset_image(front_img, f"{doc_type_hint}_FRONT")
    if back_img:
        save_raw_dataset_image(back_img, f"{doc_type_hint}_BACK")

    doc_specs = DOCUMENT_SPECS.get(doc_type_hint, DOCUMENT_SPECS["ALTRO"])
    paddle_engine = PaddleBackend.get_instance()
    ocr_texts = {"FRONT": "", "BACK": ""}
    
    # 1. OCR Scanning
    for side, img in [("FRONT", front_img), ("BACK", back_img)]:
        if not img: continue
        print(f"\n--- üì∏ ELABORAZIONE LATO: {side} ---")
        cropped = isolate_document_yolo(img, debug_prefix=side)
        target = cropped if cropped else img
        if paddle_engine:
            cv_img = pil_to_cv2(target)
            res = paddle_engine.infer(cv_img)
            text = _clean_text_blob(res, label=side)
            ocr_texts[side] = text
            debug_log[f"{side}_raw_ocr"] = text[:200]

    full_text = ocr_texts["FRONT"] + "\n" + ocr_texts["BACK"]

    # 2. PROMO STEP (Validazione)
    if doc_type_hint != "AUTO" and doc_type_hint != "ALTRO":
        is_coherent = verify_document_coherence(full_text, doc_type_hint)
        if not is_coherent:
            print("   ‚ùå [PROMO] Warning: Il documento non sembra corrispondere al tipo dichiarato.")
            final_data["warning_mismatch"] = True

    # 3. MRZ Extraction
    mrz_data = {}
    if ocr_texts["BACK"]:
        mrz_data = _extract_mrz_data(ocr_texts["BACK"], label="BACK")
    if not mrz_data and ocr_texts["FRONT"]:
        mrz_data = _extract_mrz_data(ocr_texts["FRONT"], label="FRONT")

    # 4. RESIDENCE CONTEXT (Sez 6.3 PDF Configurazione)
    is_italian_resident = detect_nationality_context(full_text, mrz_data)
    print(f"   üåç Contesto Residenza: {'ITALIA' if is_italian_resident else 'ESTERO'}")
    
    active_schema = PATENTE_SCHEMA if doc_type_hint == "PATENTE_IT" else STANDARD_SCHEMA
    
    # Filtra chiavi in base alla residenza
    target_front = list(FRONT_ONLY_KEYS)
    target_back = list(BACK_ONLY_KEYS)
    
    if not is_italian_resident:
        if "codice_fiscale" in target_back: target_back.remove("codice_fiscale")
        if "comune_residenza" in target_back: target_back.remove("comune_residenza")
        print("   ‚úàÔ∏è Modalit√† Light (Estero): Skip analisi residenza dettagliata.")

    # 5. AI EXTRACTION
    ai_front_data = {}
    ai_back_data = {}

    if ocr_texts["FRONT"]:
        ai_front_data = _run_gliner_extraction(ocr_texts["FRONT"], target_keys=target_front, schema_map=active_schema, doc_specs=doc_specs)
        regex_front = _regex_fallback(ocr_texts["FRONT"], context="FRONT", doc_specs=doc_specs)
        ai_front_data.update(regex_front)
    
    if ocr_texts["BACK"]:
        ai_back_data = _run_gliner_extraction(ocr_texts["BACK"], target_keys=target_back, schema_map=active_schema, doc_specs=doc_specs)
        regex_back = _regex_fallback(ocr_texts["BACK"], context="BACK", doc_specs=doc_specs)
        ai_back_data.update(regex_back)

    # 6. MERGE (White-Listing Rigida)
    print("\n--- üèÜ MERGE DATI ---")
    
    raw_merged = {}
    for k, v in mrz_data.items(): 
        if v: raw_merged[k] = (v, "MRZ")
    for k, v in ai_front_data.items(): 
        if v and k not in raw_merged: raw_merged[k] = (v, "AI_FRONT")
    for k, (val, src) in raw_merged.items():
        final_data[k] = val
        debug_log["sources"][k] = src
    
    # Per il retro, fondiamo solo se non gi√† presenti (es. CF o indirizzo)
    for k, v in ai_back_data.items(): 
        if v and k not in raw_merged and k not in final_data: 
            final_data[k] = v
            debug_log["sources"][k] = "AI_BACK"

    # E. CF Fallback (Solo se Italia e CF presente)
    if is_italian_resident and final_data.get("codice_fiscale") and not final_data.get("data_nascita"):
        math_data = _parse_cf_to_data(final_data["codice_fiscale"])
        if math_data.get("data_nascita"):
            final_data["data_nascita"] = math_data["data_nascita"]
            debug_log["sources"]["data_nascita"] = "MATH"

    # Inferenza Stato Nascita
    if not final_data.get("stato_nascita") and final_data.get("comune_nascita"):
        if "(" in final_data["comune_nascita"] and ")" in final_data["comune_nascita"]:
            final_data["stato_nascita"] = "ITALIA"
            debug_log["sources"]["stato_nascita"] = "INFERRED"

    # 7. FILTRAGGIO E VALIDAZIONE FINALE
    allowed_keys = {
        "nome", "cognome", "data_nascita", "stato_residenza", "stato_nascita",
        "tipo_documento", "numero_documento", "scadenza_documento", 
        "source", "_debug_info", "cittadinanza", "sesso", "warning_mismatch", "needs_review"
    }

    if is_italian_resident:
        allowed_keys.add("codice_fiscale")
        allowed_keys.add("comune_residenza")
        final_data["stato_residenza"] = "ITALIA"
    else:
        # LOGICA FOREIGN ADDRESS FALLBACK (Sez 6.3 PDF)
        # Se non siamo residenti in Italia, il frontend si aspetta comunque un "luogo" generico
        # per non mostrare campi vuoti brutti.
        if not final_data.get("comune_residenza"):
            # Usiamo lo stato di residenza o un generico "ESTERO"
            fallback_addr = final_data.get("stato_residenza") or final_data.get("cittadinanza") or "ESTERO"
            final_data["comune_residenza"] = fallback_addr
            allowed_keys.add("comune_residenza")
            debug_log["sources"]["comune_residenza"] = "FALLBACK_FOREIGN"
    
    is_italian_birth = (final_data.get("stato_nascita") or "").upper() == "ITALIA"
    if is_italian_birth:
        allowed_keys.add("comune_nascita")

    # LOGICA "ALTRO" -> NEEDS REVIEW (Sez 6.2 PDF)
    if doc_type_hint == "ALTRO":
        final_data["needs_review"] = True
        print("   ‚ö†Ô∏è Documento 'ALTRO' rilevato: attivazione flag needs_review.")

    # VALIDAZIONE RIGIDA NUMERO DOCUMENTO (Double Check)
    if final_data.get("numero_documento") and doc_specs.get("doc_number_regex"):
        # Verifichiamo che il dato "vincitore" rispetti ancora la regex
        if not doc_specs["doc_number_regex"].search(final_data["numero_documento"]):
            print(f"   ‚ùå Numero documento scartato nel check finale (Formato non valido): {final_data['numero_documento']}")
            del final_data["numero_documento"]

    # Applica il filtro
    keys_to_remove = [k for k in final_data.keys() if k not in allowed_keys]
    for k in keys_to_remove:
        print(f"   ‚úÇÔ∏è Rimozione campo non richiesto: {k} ({final_data[k]})")
        del final_data[k]

    # Log finale
    for k, v in final_data.items():
        if k not in ["source", "_debug_info"]:
            src = debug_log["sources"].get(k, "UNK")
            print(f"‚úÖ {k}: {v} [{src}]")

    final_data["_debug_info"] = debug_log
    return final_data
<FILE_END>

<FILE_START path="backend\app\services\waiver_mailer.py">
from __future__ import annotations

import os
import smtplib
from dataclasses import dataclass
from email.message import EmailMessage
from pathlib import Path
from typing import Optional


@dataclass(frozen=True)
class WaiverMailer:
    enabled: bool
    host: str
    port: int
    username: Optional[str]
    password: Optional[str]
    use_tls: bool
    mail_from: str

    @staticmethod
    def from_env() -> "WaiverMailer":
        enabled = os.getenv("SMTP_ENABLED", "false").lower() == "true"
        host = os.getenv("SMTP_HOST", "localhost")
        port = int(os.getenv("SMTP_PORT", "25"))
        username = os.getenv("SMTP_USER") or None
        password = os.getenv("SMTP_PASS") or None
        use_tls = os.getenv("SMTP_TLS", "false").lower() == "true"
        mail_from = os.getenv("SMTP_FROM", "noreply@localhost")
        return WaiverMailer(
            enabled=enabled,
            host=host,
            port=port,
            username=username,
            password=password,
            use_tls=use_tls,
            mail_from=mail_from,
        )

    def send_pdf(self, to_email: str, subject: str, body: str, pdf_path: Path) -> None:
        msg = EmailMessage()
        msg["Subject"] = subject
        msg["From"] = self.mail_from
        msg["To"] = to_email
        msg.set_content(body)

        data = pdf_path.read_bytes()
        msg.add_attachment(
            data,
            maintype="application",
            subtype="pdf",
            filename=pdf_path.name,
        )

        with smtplib.SMTP(self.host, self.port, timeout=30) as smtp:
            if self.use_tls:
                smtp.starttls()
            if self.username and self.password:
                smtp.login(self.username, self.password)
            smtp.send_message(msg)
<FILE_END>

<FILE_START path="backend\app\services\waiver_service.py">
from __future__ import annotations

import base64
import json
import os
import uuid
from dataclasses import dataclass
from datetime import datetime, date
from pathlib import Path
from typing import Literal, Optional, Dict, Any

from zoneinfo import ZoneInfo

from pydantic import BaseModel, Field, model_validator

from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.platypus import (
    SimpleDocTemplate,
    Paragraph,
    Spacer,
    Table,
    TableStyle,
    Image as RLImage,
)
from reportlab.lib import colors

from .waiver_mailer import WaiverMailer


TZ_ROME = ZoneInfo("Europe/Rome")


def _parse_ddmmyyyy(value: str) -> date:
    # accetta "DD/MM/YYYY"
    dd, mm_, yyyy = value.strip().split("/")
    return date(int(yyyy), int(mm_), int(dd))


def _calc_age(birth: date, on: date) -> int:
    years = on.year - birth.year
    if (on.month, on.day) < (birth.month, birth.day):
        years -= 1
    return years


class PersonaItalia(BaseModel):
    cittadinanza: Literal["ITA"] = "ITA"

    nome: str
    cognome: str
    comune_nascita: str
    data_nascita: str  # DD/MM/YYYY
    comune_residenza: str
    codice_fiscale: str

    tipo_documento: str
    numero_documento: str
    scadenza_documento: str  # DD/MM/YYYY

    email: str
    telefono: str


class PersonaEstera(BaseModel):
    cittadinanza: Literal["NON_ITA"] = "NON_ITA"

    nome: str
    cognome: str
    stato_nascita: str
    data_nascita: str  # DD/MM/YYYY
    stato_residenza: str

    tipo_documento: str
    numero_documento: str
    scadenza_documento: str  # DD/MM/YYYY

    email: str
    telefono: str


Persona = PersonaItalia | PersonaEstera


class WaiverDraftRequest(BaseModel):
    # dati del minore SEMPRE presenti se stiamo facendo la pratica ‚Äúminore‚Äù
    minore: Persona

    # richiesti SOLO se minore < 18 (validiamo server-side)
    genitore: Optional[Persona] = None

    # testo legale: in questa fase lo teniamo lato server, ma puoi anche passarlo dal client se vuoi.
    # qui lo lasciamo opzionale per poterlo aggiornare facilmente in futuro.
    waiver_title: str = "Modulo di scarico responsabilit√† / privacy / consenso informato"
    waiver_body: Optional[str] = None

    @model_validator(mode="after")
    def _validate_minor_guardian(self) -> "WaiverDraftRequest":
        today = datetime.now(TZ_ROME).date()
        dn = _parse_ddmmyyyy(self.minore.data_nascita)
        eta = _calc_age(dn, today)
        if eta < 18 and self.genitore is None:
            raise ValueError("Minore < 18: il campo 'genitore' √® obbligatorio.")
        return self


class WaiverDraftResponse(BaseModel):
    waiver_id: str
    created_at_iso: str
    is_minor: bool
    draft_pdf_path: str  # path su server (per debug / log)
    draft_pdf_url: str   # endpoint per scaricarlo


class WaiverFinalizeRequest(BaseModel):
    # firma SOLO genitore/tutore (PNG base64). Obbligatoria se minore < 18.
    signature_png_base64: Optional[str] = None

    # opzionale: se vuoi mandare anche a un indirizzo specifico (altrimenti usiamo email genitore)
    send_to_email: Optional[str] = None


class WaiverFinalizeResponse(BaseModel):
    waiver_id: str
    finalized_at_iso: str
    final_pdf_path: str
    final_pdf_url: str
    emailed_to: Optional[str] = None


@dataclass(frozen=True)
class WaiverPaths:
    root: Path
    meta_json: Path
    draft_pdf: Path
    final_pdf: Path
    signature_png: Path


class WaiverService:
    """
    Storage 100% locale:
      backend/app/storage/waivers/<waiver_id>/
         meta.json
         draft.pdf
         final.pdf
         signature.png
    """

    def __init__(self, storage_root: Optional[Path] = None, mailer: Optional[WaiverMailer] = None):
        base = storage_root or (Path(__file__).resolve().parents[1] / "storage" / "waivers")
        self.storage_root = base
        self.storage_root.mkdir(parents=True, exist_ok=True)

        self.mailer = mailer or WaiverMailer.from_env()

    def _paths(self, waiver_id: str) -> WaiverPaths:
        root = self.storage_root / waiver_id
        root.mkdir(parents=True, exist_ok=True)
        return WaiverPaths(
            root=root,
            meta_json=root / "meta.json",
            draft_pdf=root / "draft.pdf",
            final_pdf=root / "final.pdf",
            signature_png=root / "signature.png",
        )

    def create_draft(self, req: WaiverDraftRequest, public_base_url: str) -> WaiverDraftResponse:
        waiver_id = str(uuid.uuid4())
        paths = self._paths(waiver_id)

        now = datetime.now(TZ_ROME)
        today = now.date()
        minore_eta = _calc_age(_parse_ddmmyyyy(req.minore.data_nascita), today)
        is_minor = minore_eta < 18

        # testo legale (placeholder ‚Äúvero‚Äù ma breve: poi lo sostituisci con il testo ufficiale)
        waiver_body = req.waiver_body or (
            "DICHIARAZIONE:\n"
            "Il sottoscritto dichiara di aver ricevuto informativa privacy, di aver compreso i rischi "
            "connessi all'attivit√† e di sollevare l'organizzazione da responsabilit√† nei limiti di legge. "
            "Conferma inoltre la veridicit√† dei dati inseriti.\n\n"
            "PRIVACY:\n"
            "Autorizzo il trattamento dei dati personali per finalit√† organizzative e di sicurezza.\n\n"
            "CONSENSO INFORMATO:\n"
            "Dichiaro di aver compreso natura e rischi dell'attivit√† svolta."
        )

        meta: Dict[str, Any] = {
            "waiver_id": waiver_id,
            "created_at_iso": now.isoformat(),
            "is_minor": is_minor,
            "minore": req.minore.model_dump(),
            "genitore": req.genitore.model_dump() if req.genitore else None,
            "waiver_title": req.waiver_title,
            "waiver_body": waiver_body,
        }
        paths.meta_json.write_text(json.dumps(meta, ensure_ascii=False, indent=2), encoding="utf-8")

        self._render_pdf(
            out_path=paths.draft_pdf,
            meta=meta,
            signature_path=None,  # draft: niente firma
        )

        return WaiverDraftResponse(
            waiver_id=waiver_id,
            created_at_iso=now.isoformat(),
            is_minor=is_minor,
            draft_pdf_path=str(paths.draft_pdf),
            draft_pdf_url=f"{public_base_url.rstrip('/')}/api/v1/waivers/{waiver_id}/pdf?which=draft",
        )

    def finalize(self, waiver_id: str, req: WaiverFinalizeRequest, public_base_url: str) -> WaiverFinalizeResponse:
        paths = self._paths(waiver_id)
        if not paths.meta_json.exists():
            raise FileNotFoundError("waiver_id non trovato")

        meta = json.loads(paths.meta_json.read_text(encoding="utf-8"))
        is_minor = bool(meta.get("is_minor"))

        # Firma SOLO genitore/tutore: obbligatoria se minore
        if is_minor:
            if not req.signature_png_base64:
                raise ValueError("Minore: la firma del genitore/tutore √® obbligatoria (PNG base64).")
            self._save_signature_png(paths.signature_png, req.signature_png_base64)
            signature_path = paths.signature_png
        else:
            # se non √® minore, NON chiediamo firma (come da tua richiesta ‚Äúsolo firma genitore‚Äù)
            signature_path = None

        finalized_at = datetime.now(TZ_ROME)
        meta["finalized_at_iso"] = finalized_at.isoformat()
        paths.meta_json.write_text(json.dumps(meta, ensure_ascii=False, indent=2), encoding="utf-8")

        self._render_pdf(
            out_path=paths.final_pdf,
            meta=meta,
            signature_path=signature_path,
        )

        # invio email (se abilitato)
        emailed_to: Optional[str] = None
        if self.mailer.enabled:
            # preferenza: invia a req.send_to_email, altrimenti all‚Äôemail genitore (se presente),
            # altrimenti all‚Äôemail minore (caso adulto o edge).
            to_email = (
                (req.send_to_email or "").strip()
                or ((meta.get("genitore") or {}).get("email") or "").strip()
                or ((meta.get("minore") or {}).get("email") or "").strip()
            )
            if to_email:
                subject = f"Modulo firmato - {waiver_id}"
                body = "In allegato trovi il modulo compilato e firmato."
                self.mailer.send_pdf(to_email=to_email, subject=subject, body=body, pdf_path=paths.final_pdf)
                emailed_to = to_email

        return WaiverFinalizeResponse(
            waiver_id=waiver_id,
            finalized_at_iso=finalized_at.isoformat(),
            final_pdf_path=str(paths.final_pdf),
            final_pdf_url=f"{public_base_url.rstrip('/')}/api/v1/waivers/{waiver_id}/pdf?which=final",
            emailed_to=emailed_to,
        )

    def _save_signature_png(self, out_path: Path, signature_b64: str) -> None:
        # accetta sia base64 ‚Äúpuro‚Äù che data URL "data:image/png;base64,..."
        raw = signature_b64.strip()
        if raw.startswith("data:"):
            raw = raw.split(",", 1)[-1]
        data = base64.b64decode(raw)
        out_path.write_bytes(data)

    def _render_pdf(self, out_path: Path, meta: Dict[str, Any], signature_path: Optional[Path]) -> None:
        styles = getSampleStyleSheet()
        style_h = styles["Heading1"]
        style_b = styles["BodyText"]

        doc = SimpleDocTemplate(
            str(out_path),
            pagesize=A4,
            leftMargin=15 * mm,
            rightMargin=15 * mm,
            topMargin=15 * mm,
            bottomMargin=15 * mm,
            title="Waiver",
            author="Rafting Registration System",
        )

        elems = []

        title = meta.get("waiver_title", "Modulo")
        elems.append(Paragraph(title, style_h))
        elems.append(Spacer(1, 6 * mm))

        created_at_iso = meta.get("created_at_iso", "")
        finalized_at_iso = meta.get("finalized_at_iso", "")
        ts_line = f"Creato il: {created_at_iso}"
        if finalized_at_iso:
            ts_line += f" ‚Äî Firmato il: {finalized_at_iso}"
        elems.append(Paragraph(ts_line, style_b))
        elems.append(Spacer(1, 6 * mm))

        # Dati minore
        elems.append(Paragraph("<b>Dati partecipante (minore)</b>", styles["Heading3"]))
        elems.append(Spacer(1, 2 * mm))
        elems.extend(self._person_table(meta.get("minore") or {}))
        elems.append(Spacer(1, 6 * mm))

        # Dati genitore/tutore (se presenti)
        if meta.get("genitore"):
            elems.append(Paragraph("<b>Dati genitore/tutore</b>", styles["Heading3"]))
            elems.append(Spacer(1, 2 * mm))
            elems.extend(self._person_table(meta.get("genitore") or {}))
            elems.append(Spacer(1, 6 * mm))

        # Testo legale
        body = meta.get("waiver_body", "")
        for block in body.split("\n\n"):
            block = block.strip()
            if not block:
                continue
            safe = block.replace("\n", "<br/>")
            elems.append(Paragraph(safe, style_b))
            elems.append(Spacer(1, 4 * mm))

        elems.append(Spacer(1, 8 * mm))
        elems.append(Paragraph("<b>Firma genitore/tutore</b>", styles["Heading3"]))
        elems.append(Spacer(1, 2 * mm))

        # Area firma
        if signature_path and signature_path.exists():
            try:
                img = RLImage(str(signature_path), width=60 * mm, height=20 * mm)
            except Exception:
                img = Paragraph("(Firma non leggibile)", style_b)
        else:
            img = Paragraph("__________________________________________", style_b)

        sign_table = Table(
            [[img, Paragraph("Data: ____________________", style_b)]],
            colWidths=[90 * mm, 60 * mm],
        )
        sign_table.setStyle(
            TableStyle(
                [
                    ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
                    ("BOX", (0, 0), (0, 0), 0.5, colors.black),
                    ("LEFTPADDING", (0, 0), (-1, -1), 6),
                    ("RIGHTPADDING", (0, 0), (-1, -1), 6),
                    ("TOPPADDING", (0, 0), (-1, -1), 6),
                    ("BOTTOMPADDING", (0, 0), (-1, -1), 6),
                ]
            )
        )
        elems.append(sign_table)

        doc.build(elems)

    def _person_table(self, p: Dict[str, Any]) -> list:
        styles = getSampleStyleSheet()
        style_b = styles["BodyText"]

        # Normalizziamo campi ITA vs NON_ITA
        rows = []
        def add(label: str, key: str):
            val = (p.get(key) or "").strip() if isinstance(p.get(key), str) else (p.get(key) or "")
            if val:
                rows.append([Paragraph(f"<b>{label}</b>", style_b), Paragraph(str(val), style_b)])

        add("Nome", "nome")
        add("Cognome", "cognome")
        add("Cittadinanza", "cittadinanza")

        if p.get("cittadinanza") == "ITA":
            add("Comune di nascita", "comune_nascita")
            add("Comune di residenza", "comune_residenza")
            add("Codice fiscale", "codice_fiscale")
        else:
            add("Stato di nascita", "stato_nascita")
            add("Stato di residenza", "stato_residenza")

        add("Data di nascita", "data_nascita")
        add("Tipo documento", "tipo_documento")
        add("Numero documento", "numero_documento")
        add("Scadenza documento", "scadenza_documento")
        add("Email", "email")
        add("Telefono", "telefono")

        table = Table(rows, colWidths=[50 * mm, 120 * mm])
        table.setStyle(
            TableStyle(
                [
                    ("GRID", (0, 0), (-1, -1), 0.25, colors.grey),
                    ("VALIGN", (0, 0), (-1, -1), "TOP"),
                    ("LEFTPADDING", (0, 0), (-1, -1), 5),
                    ("RIGHTPADDING", (0, 0), (-1, -1), 5),
                    ("TOPPADDING", (0, 0), (-1, -1), 3),
                    ("BOTTOMPADDING", (0, 0), (-1, -1), 3),
                ]
            )
        )
        return [table]
<FILE_END>

<FILE_START path="backend\app\services\__init__.py">
<FILE_END>

<FILE_START path="backend\app\services\registration\email_service.py">
from __future__ import annotations

import os
import smtplib
from email.message import EmailMessage
from typing import Optional


class EmailService:
    def __init__(self):
        self.host = os.getenv("SMTP_HOST", "")
        self.port = int(os.getenv("SMTP_PORT", "587"))
        self.user = os.getenv("SMTP_USER", "")
        self.password = os.getenv("SMTP_PASS", "")
        self.use_starttls = os.getenv("SMTP_USE_STARTTLS", "true").lower() in ("1", "true", "yes")
        self.mail_from = os.getenv("SMTP_FROM", self.user)

    def is_configured(self) -> bool:
        return bool(self.host and self.port and self.mail_from)

    def send_pdf(self, to_email: str, subject: str, body: str, pdf_bytes: bytes, filename: str):
        if not self.is_configured():
            return

        msg = EmailMessage()
        msg["From"] = self.mail_from
        msg["To"] = to_email
        msg["Subject"] = subject
        msg.set_content(body)

        msg.add_attachment(pdf_bytes, maintype="application", subtype="pdf", filename=filename)

        with smtplib.SMTP(self.host, self.port, timeout=15) as smtp:
            if self.use_starttls:
                smtp.starttls()
            if self.user and self.password:
                smtp.login(self.user, self.password)
            smtp.send_message(msg)
<FILE_END>

<FILE_START path="backend\app\services\registration\mrz_native.py">
# backend/app/services/registration/mrz_native.py
from __future__ import annotations

import ctypes
import os
from dataclasses import dataclass
from typing import Optional


@dataclass(frozen=True)
class MrzParsed:
    format: str
    doc_type: str
    issuer: str
    nationality: str
    surname: str
    given_names: str
    document_number: str
    birth_date: str   # YYMMDD
    sex: str
    expiry_date: str  # YYMMDD


class MrzNative:
    def __init__(self):
        dll_path = os.getenv("MRZ_DLL_PATH", os.path.join("backend", "native", "mrz", "build", "mrz.dll"))
        self.dll_path = os.path.abspath(dll_path)
        self.lib = None

        if os.path.exists(self.dll_path):
            try:
                self.lib = ctypes.CDLL(self.dll_path)
                self.lib.mrz_parse_td3.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int]
                self.lib.mrz_parse_td3.restype = ctypes.c_int
                self.lib.mrz_parse_td1.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int]
                self.lib.mrz_parse_td1.restype = ctypes.c_int
            except Exception:
                self.lib = None

    def parse_td3(self, line1: str, line2: str) -> Optional[dict]:
        if not self.lib:
            return None
        out = ctypes.create_string_buffer(2048)
        ok = self.lib.mrz_parse_td3(line1.encode("utf-8"), line2.encode("utf-8"), out, ctypes.sizeof(out))
        if ok != 1:
            return None
        import json
        return json.loads(out.value.decode("utf-8"))

    def parse_td1(self, line1: str, line2: str, line3: str) -> Optional[dict]:
        if not self.lib:
            return None
        out = ctypes.create_string_buffer(2048)
        ok = self.lib.mrz_parse_td1(line1.encode("utf-8"), line2.encode("utf-8"), line3.encode("utf-8"), out, ctypes.sizeof(out))
        if ok != 1:
            return None
        import json
        return json.loads(out.value.decode("utf-8"))
<FILE_END>

<FILE_START path="backend\app\services\registration\pdf_service.py">
from __future__ import annotations

import base64
import re
from dataclasses import dataclass
from datetime import datetime
from io import BytesIO
from typing import Optional

from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm
from reportlab.pdfgen import canvas
from reportlab.lib.utils import ImageReader


@dataclass(frozen=True)
class PdfResult:
    filename: str
    pdf_bytes: bytes


class PdfService:
    def __init__(self, legal_text: Optional[str] = None):
        """
        Inizializza il servizio PDF.
        :param legal_text: Testo legale opzionale da includere (non ancora utilizzato nel layout, ma predisposto).
        """
        self.legal_text = legal_text

    def decode_signature_png(self, signature_base64: str) -> bytes:
        """
        Accetta sia base64 puro sia dataURL: data:image/png;base64,...
        """
        s = signature_base64.strip()
        m = re.match(r"^data:image\/png;base64,(.*)$", s)
        if m:
            s = m.group(1)
        return base64.b64decode(s)

    def generate(
        self,
        registration_id: str,
        timestamp: datetime,
        participant_block: str,
        guardian_block: Optional[str],
        consents_block: str,
        signature_png_bytes: bytes,
        signature_label: str,
    ) -> PdfResult:
        buf = BytesIO()
        c = canvas.Canvas(buf, pagesize=A4)
        w, h = A4

        y = h - 20 * mm
        c.setFont("Helvetica-Bold", 16)
        c.drawString(20 * mm, y, "Rafting Republic - Registrazione")
        y -= 8 * mm

        c.setFont("Helvetica", 10)
        c.drawString(20 * mm, y, f"ID: {registration_id}")
        y -= 5 * mm
        c.drawString(20 * mm, y, f"Data/Ora: {timestamp.isoformat()}")
        y -= 10 * mm

        c.setFont("Helvetica-Bold", 12)
        c.drawString(20 * mm, y, "Dati partecipante")
        y -= 6 * mm

        c.setFont("Helvetica", 10)
        for line in participant_block.splitlines():
            c.drawString(20 * mm, y, line[:120])
            y -= 4.5 * mm

        if guardian_block:
            y -= 4 * mm
            c.setFont("Helvetica-Bold", 12)
            c.drawString(20 * mm, y, "Dati genitore/tutore")
            y -= 6 * mm

            c.setFont("Helvetica", 10)
            for line in guardian_block.splitlines():
                c.drawString(20 * mm, y, line[:120])
                y -= 4.5 * mm

        y -= 4 * mm
        c.setFont("Helvetica-Bold", 12)
        c.drawString(20 * mm, y, "Consensi")
        y -= 6 * mm

        c.setFont("Helvetica", 10)
        for line in consents_block.splitlines():
            c.drawString(20 * mm, y, line[:120])
            y -= 4.5 * mm

        y -= 6 * mm
        c.setFont("Helvetica-Bold", 12)
        c.drawString(20 * mm, y, signature_label)
        y -= 6 * mm

        # firma
        try:
            img = ImageReader(BytesIO(signature_png_bytes))
            c.rect(20 * mm, y - 30 * mm, 80 * mm, 30 * mm)
            c.drawImage(img, 20 * mm, y - 30 * mm, width=80 * mm, height=30 * mm, preserveAspectRatio=True, mask='auto')
        except Exception:
            # Fallback se l'immagine non √® valida
            c.drawString(20 * mm, y - 10 * mm, "[Firma non valida]")

        c.showPage()
        c.save()

        pdf_bytes = buf.getvalue()
        filename = f"registrazione_{registration_id}.pdf"
        return PdfResult(filename=filename, pdf_bytes=pdf_bytes)
<FILE_END>

<FILE_START path="backend\app\services\registration\registration_service.py">
from __future__ import annotations

import os
import uuid
from dataclasses import dataclass
from datetime import datetime
from zoneinfo import ZoneInfo

from app.schemas.registration import RegistrationPayload
from app.services.registration.email_service import EmailService
from app.services.registration.pdf_service import PdfService
from app.services.registration.storage_service import StorageService


def _parse_ddmmyyyy(s: str) -> datetime:
    """Helper per parsare date DD/MM/YYYY."""
    try:
        return datetime.strptime(s, "%d/%m/%Y")
    except ValueError:
        return datetime(2000, 1, 1)


def _calculate_age(birth_ddmmyyyy: str, now: datetime) -> int:
    b = _parse_ddmmyyyy(birth_ddmmyyyy).date()
    t = now.date()
    years = t.year - b.year - ((t.month, t.day) < (b.month, b.day))
    return years


def _safe_get(obj, key, default=None):
    """Helper universale per propriet√† Oggetti o chiavi Dizionari."""
    if obj is None:
        return default
    if isinstance(obj, dict):
        return obj.get(key, default)
    return getattr(obj, key, default)


def _fmt_consents_block(payload: RegistrationPayload) -> str:
    legal = _safe_get(payload, "legal")
    privacy = _safe_get(legal, "privacy")
    informed = _safe_get(legal, "informed_consent")
    resp = _safe_get(legal, "responsibility")
    tess = _safe_get(legal, "tesseramento")
    photo = _safe_get(legal, "photo")
    newsletter = _safe_get(legal, "newsletter")

    return "\n".join([
        f"Lingua: {_safe_get(payload, 'language')}",
        f"Privacy: {'SI' if privacy else 'NO'}",
        f"Consenso Inf.: {'SI' if informed else 'NO'}",
        f"Responsabilit√†: {'SI' if resp else 'NO'}",
        f"Tesseramento: {'SI' if tess else 'NO'}",
        f"Foto: {'SI' if photo else 'NO'}",
        f"Newsletter: {'SI' if newsletter else 'NO'}",
    ])


def _fmt_person_block(p) -> str:
    if not p:
        return ""
    
    nome = _safe_get(p, "nome", "")
    cognome = _safe_get(p, "cognome", "")
    nascita = _safe_get(p, "data_nascita", "")
    
    lines = [
        f"Nome: {nome}",
        f"Cognome: {cognome}",
        f"Nascita: {nascita}",
    ]
    
    cittadinanza = _safe_get(p, "cittadinanza_scelta")
    
    if cittadinanza == "ITALIANA":
        cf = _safe_get(p, "codice_fiscale") or _safe_get(_safe_get(p, "italian"), "codice_fiscale")
        if cf: lines.append(f"CF: {cf}")
            
    doc_type = _safe_get(p, "tipo_documento")
    doc_num = _safe_get(p, "numero_documento")
    
    if doc_type: lines.append(f"Doc: {doc_type}")
    if doc_num: lines.append(f"Num: {doc_num}")

    return "\n".join(lines)


def _fmt_full_participant_block(payload: RegistrationPayload, age: int) -> str:
    p = _safe_get(payload, "participant")
    base_info = _fmt_person_block(p)
    
    contact = _safe_get(payload, "contact")
    email = _safe_get(contact, "email")
    tel = _safe_get(contact, "telefono")

    contacts = []
    if email: contacts.append(f"Email: {email}")
    if tel: contacts.append(f"Tel: {tel}")
        
    consents = _fmt_consents_block(payload)
    
    return f"{base_info}\nEt√†: {age}\n" + "\n".join(contacts) + "\n\n=== CONSENSI ===\n" + consents


@dataclass(frozen=True)
class SubmitResult:
    registration_id: str
    timestamp_iso: str
    pdf_filename: str
    emailed_to: str | None


class RegistrationService:
    def __init__(self):
        tz = os.getenv("APP_TZ", "Europe/Rome")
        self.tz = ZoneInfo(tz)
        
        # Percorso storage
        storage_dir = os.getenv("REGISTRATION_STORAGE_DIR", os.path.join("storage", "registrations"))
        self.storage = StorageService(storage_dir)
        
        self.pdf = PdfService(legal_text=os.getenv("LEGAL_TEXT", None))
        self.email = EmailService()

    def get_registration_details(self, registration_id: str) -> dict:
        """Recupera il payload completo per la modalit√† modifica + Audit Log."""
        if not self.storage.exists(registration_id):
            raise FileNotFoundError("Registrazione non trovata")
        
        paths = self.storage.create_registration_dir(registration_id)
        data = self.storage.load_json(paths.json_path)
        if not data:
            raise ValueError("Dati registrazione corrotti o vuoti")
        
        # Carica Audit Log (se presente)
        audit_logs = self.storage.load_json(paths.audit_path) or []
        data["audit_log"] = audit_logs

        return data

    def submit(self, payload: RegistrationPayload, registration_id: str | None = None) -> SubmitResult:
        now = datetime.now(self.tz)
        
        p = _safe_get(payload, "participant")
        data_nascita = _safe_get(p, "data_nascita", "01/01/2000")
        
        age = _calculate_age(data_nascita, now)
        is_minor = age < 18
        
        guardian = _safe_get(payload, "guardian")
    
        if is_minor and not guardian:
            raise ValueError("Partecipante minorenne: dati tutore mancanti.")

        # LOGICA UPDATE vs CREATE
        is_update = False
        if registration_id:
            if not self.storage.exists(registration_id):
                raise FileNotFoundError(f"Impossibile aggiornare: ID {registration_id} non esiste.")
            # ARCHIVIAZIONE VERSIONE PRECEDENTE (Snapshot)
            self.storage.archive_current_version(registration_id)
            is_update = True
        else:
            registration_id = str(uuid.uuid4())

        paths = self.storage.create_registration_dir(registration_id)

        # Firma
        sig_base64 = _safe_get(payload, "signature_base64", "")
        signature_png = self.pdf.decode_signature_png(sig_base64)

        # PDF Blocks
        participant_block = _fmt_full_participant_block(payload, age)
        guardian_block = _fmt_person_block(guardian) if is_minor and guardian else None
        consents_block = _fmt_consents_block(payload)
        signature_label = "Firma genitore/tutore" if is_minor else "Firma partecipante"

        pdf_result = self.pdf.generate(
            registration_id=registration_id,
            timestamp=now,
            participant_block=participant_block,
            guardian_block=guardian_block,
            consents_block=consents_block, 
            signature_png_bytes=signature_png,
            signature_label=signature_label,
        )

        # Salvataggio
        self.storage.save_bytes(paths.signature_path, signature_png)
        self.storage.save_bytes(paths.pdf_path, pdf_result.pdf_bytes)

        # JSON
        if hasattr(payload, 'model_dump'):
            payload_dict = payload.model_dump()
        else:
            payload_dict = dict(payload)

        payload_dict.update({
            "registration_id": registration_id,
            "timestamp_iso": now.isoformat(),
            "computed_age": age,
            "is_minor": is_minor,
            "locked": True # Dopo modifica/invio, blocchiamo di default per sicurezza
        })
        self.storage.save_json(paths.json_path, payload_dict)

        # Audit Log
        action_type = "UPDATE" if is_update else "CREATE"
        details = "Preferenze aggiornate" if is_update else "Nuova registrazione"
        self.storage.append_audit_log(registration_id, action_type, details)

        # Email
        emailed_to = None
        contact = _safe_get(payload, "contact")
        recipient = _safe_get(contact, "email")
        
        if recipient:
            try:
                subject_text = "Rafting Republic - Registrazione Aggiornata" if is_update else "Rafting Republic - Registrazione"
                body_text = "In allegato il documento aggiornato." if is_update else "In allegato il documento firmato."
                
                self.email.send_pdf(
                    to_email=str(recipient),
                    subject=subject_text,
                    body=body_text,
                    pdf_bytes=pdf_result.pdf_bytes,
                    filename=pdf_result.filename,
                )
                emailed_to = str(recipient)
                self.storage.append_audit_log(registration_id, "EMAIL_SENT", f"To: {emailed_to}")
            except Exception as e:
                self.storage.append_audit_log(registration_id, "EMAIL_ERROR", str(e))

        return SubmitResult(
            registration_id=registration_id,
            timestamp_iso=now.isoformat(),
            pdf_filename=pdf_result.filename,
            emailed_to=emailed_to,
        )

    def list_registrations(self, limit: int = 200, offset: int = 0, query: str | None = None) -> list[dict]:
        root = self.storage.storage_dir
        if not os.path.exists(root):
            return []

        q = (query or "").strip().lower()
        items = []

        try:
            entries = os.listdir(root)
        except OSError:
            return []

        for entry in entries:
            reg_dir = os.path.join(root, entry)
            if not os.path.isdir(reg_dir):
                continue
            
            payload_path = os.path.join(reg_dir, "payload.json")
            data = self.storage.load_json(payload_path)
            
            if not data:
                continue

            p = _safe_get(data, "participant", {})
            contact = _safe_get(data, "contact", {})
            
            reg_id = _safe_get(data, "registration_id", entry)
            nome = _safe_get(p, "nome", "")
            cognome = _safe_get(p, "cognome", "")
            email = _safe_get(contact, "email", "")
            
            searchable_text = f"{reg_id} {nome} {cognome} {email}".lower()
            if q and q not in searchable_text:
                continue

            items.append({
                "registration_id": reg_id,
                "timestamp_iso": _safe_get(data, "timestamp_iso"),
                "participant_nome": nome,
                "participant_cognome": cognome,
                "email": email,
                "is_minor": _safe_get(data, "is_minor", False),
                "locked": _safe_get(data, "locked", False),
            })

        items.sort(key=lambda x: x.get("timestamp_iso") or "", reverse=True)
        return items[offset : offset + limit]

    def set_locked(self, registration_id: str, locked: bool) -> dict:
        paths = self.storage.create_registration_dir(registration_id)
        data = self.storage.load_json(paths.json_path)
        
        if not data:
            raise FileNotFoundError("Registrazione non trovata")
            
        data["locked"] = locked
        self.storage.save_json(paths.json_path, data)
        
        # Logghiamo anche il lock/unlock
        self.storage.append_audit_log(registration_id, "LOCK_CHANGE", f"Locked: {locked}")
        
        return {"registration_id": registration_id, "locked": locked}

    def find_pdf_path(self, registration_id: str) -> str:
        paths = self.storage.create_registration_dir(registration_id)
        if os.path.exists(paths.pdf_path):
            return paths.pdf_path
        raise FileNotFoundError("PDF non trovato")
<FILE_END>

<FILE_START path="backend\app\services\registration\storage_service.py">
from __future__ import annotations

import json
import os
import shutil
import time
from dataclasses import dataclass
from pathlib import Path

@dataclass(frozen=True)
class RegistrationPaths:
    root: str
    json_path: str
    pdf_path: str
    signature_path: str
    audit_path: str  # Nuovo file di log
    history_dir: str # Nuova cartella storico

class StorageService:
    def __init__(self, storage_dir: str):
        self.storage_dir = storage_dir
        if not os.path.exists(self.storage_dir):
            os.makedirs(self.storage_dir, exist_ok=True)

    def create_registration_dir(self, registration_id: str) -> RegistrationPaths:
        reg_dir = os.path.join(self.storage_dir, registration_id)
        if not os.path.exists(reg_dir):
            os.makedirs(reg_dir, exist_ok=True)
        
        return RegistrationPaths(
            root=reg_dir,
            json_path=os.path.join(reg_dir, "payload.json"),
            pdf_path=os.path.join(reg_dir, "signed.pdf"),
            signature_path=os.path.join(reg_dir, "signature.png"),
            audit_path=os.path.join(reg_dir, "audit.json"),
            history_dir=os.path.join(reg_dir, "history")
        )

    def exists(self, registration_id: str) -> bool:
        path = os.path.join(self.storage_dir, registration_id, "payload.json")
        return os.path.exists(path)

    def archive_current_version(self, registration_id: str) -> None:
        """
        Sposta i file correnti (payload.json e signed.pdf) in una cartella history/v_{timestamp}.
        Questo crea un 'blocco' immodificabile dello stato precedente.
        """
        paths = self.create_registration_dir(registration_id)
        
        # Se non c'√® nulla da archiviare (es. prima creazione), esci
        if not os.path.exists(paths.json_path):
            return

        # Crea cartella history se non esiste
        if not os.path.exists(paths.history_dir):
            os.makedirs(paths.history_dir, exist_ok=True)

        # Crea sottocartella versione con timestamp
        version_name = f"v_{int(time.time())}"
        version_dir = os.path.join(paths.history_dir, version_name)
        os.makedirs(version_dir, exist_ok=True)

        # Copia i file vitali nello storico
        try:
            if os.path.exists(paths.json_path):
                shutil.copy2(paths.json_path, os.path.join(version_dir, "payload.json"))
            if os.path.exists(paths.pdf_path):
                shutil.copy2(paths.pdf_path, os.path.join(version_dir, "signed.pdf"))
            # Copiamo anche la firma per sicurezza forense
            if os.path.exists(paths.signature_path):
                shutil.copy2(paths.signature_path, os.path.join(version_dir, "signature.png"))
        except Exception as e:
            print(f"Errore durante l'archiviazione storico per {registration_id}: {e}")
            # Non blocchiamo il flusso, ma logghiamo l'errore

    def append_audit_log(self, registration_id: str, action: str, details: str = ""):
        """
        Scrive un evento nel file di audit log immutabile (append-only).
        """
        paths = self.create_registration_dir(registration_id)
        entry = {
            "timestamp": time.time(),
            "iso_date": time.strftime("%Y-%m-%dT%H:%M:%S%z"),
            "action": action,
            "details": details
        }
        
        # Leggi esistente o crea nuovo array
        logs = []
        if os.path.exists(paths.audit_path):
            try:
                with open(paths.audit_path, "r", encoding="utf-8") as f:
                    logs = json.load(f)
            except:
                logs = []
        
        logs.append(entry)
        
        with open(paths.audit_path, "w", encoding="utf-8") as f:
            json.dump(logs, f, ensure_ascii=False, indent=2)

    def save_bytes(self, path: str, data: bytes):
        with open(path, "wb") as f:
            f.write(data)

    def save_json(self, path: str, data: dict):
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

    def load_json(self, path: str) -> dict | None:
        if not os.path.exists(path):
            return None
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return None
<FILE_END>

<FILE_START path="backend\test\check_libs.py">
# backend/check_libs.py
try:
    import gliner
    print("‚úÖ GLINER trovato! Versione:", gliner.__version__)
except ImportError as e:
    print("‚ùå GLINER NON trovato:", e)

try:
    import paddleocr
    print("‚úÖ PaddleOCR trovato!")
except ImportError as e:
    print("‚ùå PaddleOCR NON trovato:", e)
<FILE_END>

<FILE_START path="backend\test\check_models.py">
import google.generativeai as genai
import os
from dotenv import load_dotenv

# 1. Carica la chiave segreta
load_dotenv()
api_key = os.getenv("GEMINI_API_KEY")

if not api_key:
    print("ERRORE: Chiave non trovata nel file .env")
else:
    # 2. Configura Google
    genai.configure(api_key=api_key)

    print("\n--- LISTA DEI MODELLI CHE PUOI USARE ---")
    try:
        # 3. Chiede a Google la lista ufficiale
        found_any = False
        for m in genai.list_models():
            # Filtriamo solo quelli che generano testo/immagini
            if 'generateContent' in m.supported_generation_methods:
                print(f"‚úÖ {m.name}")
                found_any = True
        
        if not found_any:
            print("Nessun modello trovato. La chiave potrebbe non avere permessi.")
            
    except Exception as e:
        print(f"ERRORE DI CONNESSIONE: {e}")
<FILE_END>

<FILE_START path="backend\test\test_ocr_isolation.py">
import cv2
import numpy as np
import pytesseract
import os
import sys
import argparse
from pathlib import Path

# --- CONFIGURAZIONE TESSERACT (Simile al tuo backend) ---
# Tenta di trovare Tesseract automaticamente
DEFAULT_PATHS = [
    r"C:\Program Files\Tesseract-OCR\tesseract.exe",
    r"C:\Program Files (x86)\Tesseract-OCR\tesseract.exe",
    r"/usr/bin/tesseract",
    r"/usr/local/bin/tesseract"
]

TESS_CMD = os.getenv("TESSERACT_CMD")
if not TESS_CMD:
    for p in DEFAULT_PATHS:
        if os.path.exists(p):
            TESS_CMD = p
            break

if not TESS_CMD:
    print("‚ùå Tesseract non trovato. Imposta TESSERACT_CMD o installalo nei percorsi standard.")
    sys.exit(1)

pytesseract.pytesseract.tesseract_cmd = TESS_CMD

def get_tess_config(whitelist=True):
    """Restituisce la configurazione 'hardcore' per MRZ"""
    config = "--oem 3 --psm 6" # PSM 6 = Assume un singolo blocco di testo uniforme
    if whitelist:
        # Whitelist stretta per MRZ
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<"
        config += f" -c tessedit_char_whitelist={chars}"
    return config

def run_test_pipeline(image_path):
    print(f"\nüß™ AVVIO TEST ISOLATO SU: {image_path}")
    
    if not os.path.exists(image_path):
        print(f"‚ùå File non trovato: {image_path}")
        return

    # Carica immagine originale (in scala di grigi)
    original = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if original is None:
        print("‚ùå Impossibile leggere l'immagine.")
        return

    # Lista delle pipeline da testare
    pipelines = [
        ("1. RAW (Nessun filtro)", lambda img: img),
        
        ("2. OTSU (Binarizzazione Classica)", lambda img: 
         cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]),
        
        ("3. ADAPTIVE GAUSSIAN (Attuale in Prod)", lambda img: 
         cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)),
        
        ("4. EROSION (Ispessisce i caratteri)", lambda img: 
         cv2.erode(cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1], np.ones((2,2), np.uint8), iterations=1)),
        
        ("5. DENOISE + OTSU (Rimuove sfondo CIE)", lambda img: 
         cv2.threshold(cv2.fastNlMeansDenoising(img, None, 10, 7, 21), 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]),
        
        ("6. UPSCALE + CLAHE + OTSU (High Definition)", lambda img: _pipeline_hd(img))
    ]

    # Cartella output per vedere cosa "vede" Tesseract
    out_dir = Path("debug_isolation_results")
    out_dir.mkdir(exist_ok=True)

    print(f"üìÇ Le immagini processate verranno salvate in: {out_dir.absolute()}")
    print("-" * 60)

    # Verifica lingue disponibili
    langs = pytesseract.get_languages(config='')
    print(f"üìö Lingue disponibili: {langs}")
    best_score = 0
    best_method = ""

    for name, func in pipelines:
        print(f"\nüëâ Testing: {name}")
        
        # 1. Applica filtro
        try:
            processed = func(original.copy())
        except Exception as e:
            print(f"   ‚ö†Ô∏è Errore nel preprocessing: {e}")
            continue

        # 2. Salva anteprima
        safe_name = name.split(" ")[1].lower()
        out_path = out_dir / f"test_{safe_name}.jpg"
        cv2.imwrite(str(out_path), processed)

        # 3. Esegui OCR con entrambe le lingue se possibile
        test_langs = ['ocrb', 'eng'] if 'ocrb' in langs else ['eng']
        
        for lang in test_langs:
            try:
                # Usa config con whitelist
                cfg = get_tess_config(whitelist=True)
                text = pytesseract.image_to_string(processed, lang=lang, config=cfg).strip()
                
                # Pulizia output
                text_clean = text.replace(" ", "")
                
                # Valutazione base
                score = 0
                if "<<" in text_clean: score += 5
                if "ITA" in text_clean: score += 3
                if len(text_clean) > 20: score += 2
                
                # Feedback visuale
                marker = "‚úÖ" if score >= 5 else "‚ùå"
                print(f"   [{lang.upper()}] Score: {score}/10 -> {marker} Result: {text_clean[:50]}...")

                if score > best_score:
                    best_score = score
                    best_method = f"{name} ({lang})"

            except Exception as e:
                print(f"   ‚ö†Ô∏è Errore Tesseract: {e}")

    print("-" * 60)
    print(f"üèÜ VINCITORE: {best_method if best_method else 'Nessuno (Il documento √® illeggibile)'}")
    print("Consiglio: Apri la cartella 'debug_isolation_results' e guarda quale immagine ha il testo nero pi√π nitido senza rumore di fondo.")

def _pipeline_hd(img):
    # Scala 2x
    img = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)
    # Aumenta contrasto locale
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    img = clahe.apply(img)
    # Binarizzazione pulita
    return cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]

if __name__ == "__main__":
    # Esempio uso: python backend/test_ocr_isolation.py backend/storage/debug_captures/debug_mrz_....jpg
    if len(sys.argv) < 2:
        print("Uso: python test_ocr_isolation.py <path_to_debug_image_jpg>")
        # Cerca l'ultimo file di debug se non passato
        debug_dir = Path(__file__).parent / "debug_captures"
        if debug_dir.exists():
            files = sorted(list(debug_dir.glob("debug_mrz_*.jpg")), key=os.path.getmtime, reverse=True)
            if files:
                print(f"üí° Nessun file specificato. Uso l'ultimo trovato: {files[0].name}")
                run_test_pipeline(str(files[0]))
            else:
                print("‚ùå Nessun file di debug trovato in backend/debug_captures")
    else:
        run_test_pipeline(sys.argv[1])
<FILE_END>

<FILE_START path="backend\test\test_ocr_noise.py">
import cv2
import numpy as np
import pytesseract
import os
import sys
from pathlib import Path

# --- CONFIGURAZIONE BASE ---
DEFAULT_PATHS = [
    r"C:\Program Files\Tesseract-OCR\tesseract.exe",
    r"C:\Program Files (x86)\Tesseract-OCR\tesseract.exe",
    r"/usr/bin/tesseract",
    r"/usr/local/bin/tesseract"
]

TESS_CMD = os.getenv("TESSERACT_CMD")
if not TESS_CMD:
    for p in DEFAULT_PATHS:
        if os.path.exists(p):
            TESS_CMD = p
            break

if not TESS_CMD:
    print("‚ùå Tesseract non trovato. Verifica l'installazione.")
    sys.exit(1)

pytesseract.pytesseract.tesseract_cmd = TESS_CMD

def get_tess_config():
    # PSM 6 = Blocco di testo uniforme (perfetto per MRZ)
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<"
    return f"--oem 3 --psm 6 -c tessedit_char_whitelist={chars}"

# --- PIPELINE AVANZATE DI PULIZIA ---

def pipe_1_division_norm(img):
    """
    Tecnica 'Division Normalization':
    Divide l'immagine per la sua versione sfocata. 
    Questo appiattisce lo sfondo (rimuovendo ombre e pattern leggeri) lasciando il testo netto.
    """
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    
    # Sfocatura ampia per stimare lo sfondo
    bg = cv2.GaussianBlur(gray, (25, 25), 0)
    
    # Divisione: (img / bg) * 255
    # Evitiamo divisione per zero aggiungendo 1
    norm = cv2.divide(gray, bg, scale=255)
    
    # Binarizzazione finale su immagine normalizzata
    _, binary = cv2.threshold(norm, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    return binary

def pipe_2_morph_blackhat(img):
    """
    Tecnica 'Black Hat':
    Estrae elementi scuri (testo) su sfondo chiaro.
    Molto potente contro pattern e ologrammi.
    """
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    
    # Kernel rettangolare orizzontale (adatto ai caratteri MRZ)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (15, 5))
    
    # Blackhat: Differenza tra chiusura e immagine originale
    blackhat = cv2.morphologyEx(gray, cv2.MORPH_BLACKHAT, kernel)
    
    # Aumentiamo il contrasto del risultato
    # Tutto ci√≤ che era sfondo ora √® nero, il testo √® bianco/grigio
    _, binary = cv2.threshold(blackhat, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    
    # Invertiamo per avere testo nero su bianco (formato standard OCR)
    return cv2.bitwise_not(binary)

def pipe_3_gamma_contrast(img):
    """
    Aumento contrasto estremo + Gamma Correction
    """
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    
    # Gamma < 1 schiarisce i mezzitoni (lo sfondo)
    gamma = 0.5
    invGamma = 1.0 / gamma
    table = np.array([((i / 255.0) ** invGamma) * 255 for i in np.arange(0, 256)]).astype("uint8")
    adjusted = cv2.LUT(gray, table)
    
    # Binarizzazione
    _, binary = cv2.threshold(adjusted, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    return binary

def pipe_4_heavy_blur_threshold(img):
    """
    Sfocatura prima del threshold per 'fondere' il rumore di fondo
    """
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    
    # Gaussian Blur leggero per rimuovere il retino tipografico
    blur = cv2.GaussianBlur(gray, (5, 5), 0)
    
    # Adaptive Threshold con parametri pi√π laschi
    binary = cv2.adaptiveThreshold(blur, 255, cv2.ADAPTIVE_THRESH_MEAN_C, 
                                   cv2.THRESH_BINARY, 21, 10)
    return binary

def run_noise_test(image_path):
    print(f"\nüßπ TEST RIMOZIONE RUMORE SU: {os.path.basename(image_path)}")
    
    original = cv2.imread(image_path)
    if original is None:
        print("‚ùå File non trovato.")
        return

    pipelines = [
        ("Division Norm", pipe_1_division_norm),
        ("Morph BlackHat", pipe_2_morph_blackhat),
        ("Gamma Contrast", pipe_3_gamma_contrast),
        ("Blur+Adaptive", pipe_4_heavy_blur_threshold)
    ]

    out_dir = Path("debug_noise_results")
    out_dir.mkdir(exist_ok=True)

    winner_method = ""
    best_score = 0

    for name, func in pipelines:
        # Elabora
        processed = func(original.copy())
        
        # Salva debug
        safe_name = name.replace(" ", "_").lower()
        cv2.imwrite(str(out_dir / f"noise_{safe_name}.jpg"), processed)

        # OCR
        try:
            text = pytesseract.image_to_string(processed, lang='ocrb', config=get_tess_config())
        except:
            text = pytesseract.image_to_string(processed, lang='eng', config=get_tess_config())

        text_clean = text.strip().replace(" ", "")
        
        # Scoring
        score = 0
        if "<<" in text_clean: score += 5
        if "ITA" in text_clean: score += 3
        if len(text_clean) > 20: score += 2
        # Penalit√† per troppi caratteri strani (rumore letto come testo)
        if len(text_clean) > 90: score -= 3 

        marker = "‚úÖ" if score >= 5 else "‚ùå"
        print(f"   [{name}] Score: {score}/10 -> {marker}")
        if score > 0:
            print(f"      Lettura: {text_clean[:60]}...")
        
        if score > best_score:
            best_score = score
            winner_method = name

    print("-" * 50)
    if winner_method:
        print(f"üèÜ METODO VINCENTE: {winner_method}")
        print("Integra questo metodo in 'image_utils.py' > 'enhance_image_for_mrz'")
    else:
        print("üíÄ Nessun metodo ha funzionato perfettamente. Controlla la cartella 'debug_noise_results' per vedere quale immagine √® pi√π pulita all'occhio umano.")

if __name__ == "__main__":
    target = None
    if len(sys.argv) > 1:
        target = sys.argv[1]
    else:
        debug_dir = Path(__file__).parent / "debug_captures"
        if debug_dir.exists():
            files = sorted(list(debug_dir.glob("debug_mrz_*.jpg")), key=os.path.getmtime, reverse=True)
            if files: target = str(files[0])
    
    if target:
        run_noise_test(target)
    else:
        print("Nessuna immagine di debug trovata.")
<FILE_END>

<FILE_START path="backend\test\test_ocr_refinement.py">
import cv2
import numpy as np
import pytesseract
import os
import sys
from pathlib import Path

# --- CONFIGURAZIONE ---
DEFAULT_PATHS = [
    r"C:\Program Files\Tesseract-OCR\tesseract.exe",
    r"C:\Program Files (x86)\Tesseract-OCR\tesseract.exe",
    r"/usr/bin/tesseract",
    r"/usr/local/bin/tesseract"
]

TESS_CMD = os.getenv("TESSERACT_CMD")
if not TESS_CMD:
    for p in DEFAULT_PATHS:
        if os.path.exists(p):
            TESS_CMD = p
            break
if TESS_CMD:
    pytesseract.pytesseract.tesseract_cmd = TESS_CMD

def get_tess_config():
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<"
    return f"--oem 3 --psm 6 -c tessedit_char_whitelist={chars}"

def run_refinement(image_path):
    print(f"\nüßº REFINEMENT TEST SU: {os.path.basename(image_path)}")
    
    # Leggi in scala di grigi
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        print("‚ùå File non trovato.")
        return

    # Se l'immagine √® per lo pi√π nera (come il blackhat), invertila per avere testo nero su bianco
    if np.mean(img) < 127:
        print("üîÑ Rilevato sfondo scuro: Inverto i colori...")
        img = cv2.bitwise_not(img)

    # Assicuriamo una dimensione minima per far funzionare i kernel morfologici
    h, w = img.shape
    if h < 200:
        scale = 2.0
        img = cv2.resize(img, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)
        print(f"üîç Upscaling 2x attivo (nuova h: {img.shape[0]})")

    # Binarizzazione base di partenza (Otsu)
    _, binary = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    # --- LE ARMI SEGRETE CONTRO LE LINEE SOTTILI ---
    strategies = []

    # 1. Median Blur (Ottimo per rumore "sale e pepe" e linee sottili)
    strategies.append(("Median Blur 3", cv2.medianBlur(binary, 3)))
    strategies.append(("Median Blur 5", cv2.medianBlur(binary, 5)))

    # 2. Morphological Opening (Erosione seguita da Dilatazione) -> Mangia le linee sottili
    kernel_small = np.ones((2,2), np.uint8)
    strategies.append(("Morph Open (2x2)", cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel_small)))

    kernel_med = np.ones((3,3), np.uint8)
    strategies.append(("Morph Open (3x3)", cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel_med)))

    # 3. Combo: Median + Open (Distruzione totale rumore)
    combo = cv2.medianBlur(binary, 3)
    combo = cv2.morphologyEx(combo, cv2.MORPH_OPEN, kernel_small)
    strategies.append(("COMBO (Median+Open)", combo))

    out_dir = Path("debug_refinement_results")
    out_dir.mkdir(exist_ok=True)

    for name, processed in strategies:
        # Salva
        fname = name.replace(" ", "_").replace("(", "").replace(")", "").lower()
        cv2.imwrite(str(out_dir / f"refine_{fname}.jpg"), processed)

        # OCR
        text = "N/A"
        try:
            text = pytesseract.image_to_string(processed, lang='ocrb', config=get_tess_config())
        except:
            text = pytesseract.image_to_string(processed, lang='eng', config=get_tess_config())
        
        text_clean = text.strip().replace(" ", "")
        
        # Score
        score = 0
        if "<<" in text_clean: score += 5
        if "ITA" in text_clean: score += 3
        if len(text_clean) > 20: score += 2

        marker = "‚úÖ" if score >= 5 else "‚ùå"
        print(f"   [{name}] Score: {score}/10 -> {marker}")
        print(f"      Lettura: {text_clean[:50]}...")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        run_refinement(sys.argv[1])
    else:
        # Cerca l'ultimo file debug
        debug_dir = Path(__file__).parent / "debug_captures"
        if debug_dir.exists():
            files = sorted(list(debug_dir.glob("debug_mrz_*.jpg")), key=os.path.getmtime, reverse=True)
            if files: run_refinement(str(files[0]))
<FILE_END>

<FILE_START path="backend\test\test_ocr_rotation.py">
import cv2
import numpy as np
import pytesseract
import os
import sys
from pathlib import Path

# --- CONFIGURAZIONE ---
DEFAULT_PATHS = [
    r"C:\Program Files\Tesseract-OCR\tesseract.exe",
    r"C:\Program Files (x86)\Tesseract-OCR\tesseract.exe",
    r"/usr/bin/tesseract",
    r"/usr/local/bin/tesseract"
]

TESS_CMD = os.getenv("TESSERACT_CMD")
if not TESS_CMD:
    for p in DEFAULT_PATHS:
        if os.path.exists(p):
            TESS_CMD = p
            break

if not TESS_CMD:
    print("‚ùå Tesseract non trovato.")
    sys.exit(1)

pytesseract.pytesseract.tesseract_cmd = TESS_CMD

def get_tess_config():
    # PSM 6 = Assume un singolo blocco di testo uniforme
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<"
    return f"--oem 3 --psm 6 -c tessedit_char_whitelist={chars}"

def apply_smart_preprocessing(img):
    """
    Applica una pulizia aggressiva per CIE:
    1. Upscale (per caratteri piccoli)
    2. Grayscale
    3. Contrasto locale (CLAHE)
    4. Otsu Threshold (Binarizzazione)
    """
    # 1. Upscale se l'immagine √® piccola
    h, w = img.shape[:2]
    if h < 100: # Se l'MRZ √® pi√π piccola di 100px in altezza, √® illeggibile
        scale = 2.0
        img = cv2.resize(img, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)
    
    # 2. Grayscale (se non lo √® gi√†)
    if len(img.shape) == 3:
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    else:
        gray = img

    # 3. CLAHE
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    contrast = clahe.apply(gray)

    # 4. Otsu Thresholding (pi√π pulito dell'Adaptive per le CIE)
    _, binary = cv2.threshold(contrast, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    
    return binary

def run_rotation_test(image_path):
    print(f"\nüîÑ TEST ROTAZIONE SU: {os.path.basename(image_path)}")
    
    original = cv2.imread(image_path)
    if original is None:
        print("‚ùå Impossibile leggere file.")
        return

    # Info base
    h, w = original.shape[:2]
    print(f"üìè Dimensioni originali: {w}x{h} px")
    if h < 50:
        print("‚ö†Ô∏è ATTENZIONE: L'immagine √® troppo bassa (<50px). Tesseract fallir√† quasi sicuramente.")

    # Prepariamo le varianti
    rotations = [
        ("0¬∞ (Originale)", original),
        ("90¬∞ Orario", cv2.rotate(original, cv2.ROTATE_90_CLOCKWISE)),
        ("180¬∞ Capovolto", cv2.rotate(original, cv2.ROTATE_180)),
        ("270¬∞ Antiorario", cv2.rotate(original, cv2.ROTATE_90_COUNTERCLOCKWISE))
    ]

    out_dir = Path("debug_rotation_results")
    out_dir.mkdir(exist_ok=True)

    winner_text = ""
    winner_rot = ""

    for label, img_rot in rotations:
        # Preprocess
        processed = apply_smart_preprocessing(img_rot)
        
        # Salva per debug
        safe_label = label.split(" ")[0].replace("¬∞", "deg")
        cv2.imwrite(str(out_dir / f"rot_{safe_label}.jpg"), processed)

        # OCR
        try:
            # Prova OCRB se c'√®, altrimenti ENG
            text = pytesseract.image_to_string(processed, lang='ocrb', config=get_tess_config())
        except:
            text = pytesseract.image_to_string(processed, lang='eng', config=get_tess_config())

        text_clean = text.strip().replace(" ", "")
        
        # Punteggio
        score = 0
        if "<<" in text_clean: score += 5
        if "ITA" in text_clean: score += 3
        if len(text_clean) > 20 and "<" in text_clean: score += 2

        marker = "‚úÖ" if score >= 5 else "‚ùå"
        print(f"   [{label}] Score: {score}/10 -> {marker}")
        if score > 0:
            print(f"      Lettura: {text_clean[:60]}...")
        else:
            print(f"      (Spazzatura): {text_clean[:20]}...")

        if score >= 5:
            winner_text = text_clean
            winner_rot = label
            break # Trovato!

    print("-" * 50)
    if winner_rot:
        print(f"üéâ SOLUZIONE TROVATA! L'immagine era ruotata di: {winner_rot}")
        print(f"üìÑ Testo: {winner_text}")
    else:
        print("üíÄ Ancora nessun risultato valido. Il problema potrebbe essere il ritaglio errato a monte.")

if __name__ == "__main__":
    # Cerca l'ultimo file debug se non passato
    target = None
    if len(sys.argv) > 1:
        target = sys.argv[1]
    else:
        debug_dir = Path(__file__).parent / "debug_captures"
        files = sorted(list(debug_dir.glob("debug_mrz_*.jpg")), key=os.path.getmtime, reverse=True)
        if files:
            target = str(files[0])
    
    if target:
        run_rotation_test(target)
    else:
        print("Nessun file trovato.")
<FILE_END>

<FILE_START path="backend\test\test_tesseract.py">
import os
from dotenv import load_dotenv
import pytesseract

# 1. Carica le variabili d'ambiente
load_dotenv()

# 2. Leggi il percorso dal .env
tess_path = os.getenv("TESSERACT_CMD")

print(f"\n--- DIAGNOSTICA TESSERACT ---")
print(f"1. Percorso letto dal .env: [{tess_path}]")

if not tess_path:
    print("‚ùå ERRORE: La variabile TESSERACT_CMD √® vuota o non esiste nel .env")
    exit()

# 3. Verifica se il file esiste fisicamente
if os.path.exists(tess_path):
    print("‚úÖ Il file esiste nel percorso specificato.")
else:
    print("‚ùå ERRORE: Il file NON esiste in questo percorso. Controlla il path.")
    # Tentativo di indovinare dove potrebbe essere
    common_path = r"C:\Program Files\Tesseract-OCR\tesseract.exe"
    if os.path.exists(common_path):
        print(f"üí° SUGGERIMENTO: L'ho trovato qui: {common_path}")
        print("   Copia questo percorso nel tuo .env!")
    exit()

# 4. Prova a configurare ed eseguire Tesseract
try:
    pytesseract.pytesseract.tesseract_cmd = tess_path
    version = pytesseract.get_tesseract_version()
    print(f"‚úÖ Tesseract risponde! Versione installata: {version}")
    print("üöÄ Il problema √® risolto in questo script. Se il backend fallisce, riavvialo completamente.")
except Exception as e:
    print(f"‚ùå ERRORE DI ESECUZIONE: {e}")
<FILE_END>

<FILE_START path="backend\tools\check_full_stack.py">
### backend/tools/check_full_stack.py
import os
import sys

# Disabilita check online e log
os.environ["DISABLE_MODEL_SOURCE_CHECK"] = "True"
os.environ["GLOG_minloglevel"] = "2"

print("‚è≥ [STEP 1] Verifica importazioni...")

try:
    # 1. Numpy Check
    import numpy as np
    print(f"‚úÖ Numpy: {np.__version__}")
    if int(np.__version__.split('.')[0]) >= 2:
        raise ImportError("Numpy 2.x rilevato!")

    # 2. Paddle Check
    import paddle
    from paddleocr import PaddleOCR
    paddle.set_device('cpu')
    print(f"‚úÖ Paddle Core: {paddle.__version__}")
    
    # Istanza Test (Parametri Aggiornati per v2.7+)
    # FIX: Rimossi parametri deprecati (show_log, use_angle_cls)
    ocr = PaddleOCR(
        use_textline_orientation=False, 
        lang='it', 
        enable_mkldnn=False
    )
    print("‚úÖ PaddleOCR: Istanziato OK")

    # 3. Torch CPU Check
    import torch
    print(f"‚úÖ PyTorch: {torch.__version__}")
    
    # 4. Ultralytics Check
    from ultralytics import YOLO
    print("‚úÖ Ultralytics: Importato OK")

    # 5. GLINER Check
    from gliner import GLiNER
    print("‚úÖ GLINER: Importato OK")

    print("\nüöÄ AMBIENTE STABILE. Nessun conflitto DLL rilevato.")

except Exception as e:
    print(f"\n‚ùå ERRORE CRITICO: {e}")
    sys.exit(1)
<FILE_END>

<FILE_START path="backend\tools\convert_labelstudio_to_yolo.py">
import json
import shutil
import os
import random
import cv2
import numpy as np
from pathlib import Path

# --- CONFIGURAZIONE ROBUSTA (FIX PERCORSI) ---
# 1. Ottieni la cartella dove si trova QUESTO file script (cio√® backend/tools)
SCRIPT_DIR = Path(__file__).resolve().parent

# 2. Il file JSON deve essere nella stessa cartella dello script
JSON_EXPORT_PATH = SCRIPT_DIR / "project_export.json"

# 3. Risaliamo alla cartella 'backend' (padre di 'tools')
BACKEND_DIR = SCRIPT_DIR.parent

# 4. Definiamo gli altri percorsi partendo da BACKEND_DIR
# Cartella immagini raw: backend/storage/dataset_raw
RAW_IMAGES_DIR = BACKEND_DIR / "storage" / "dataset_raw"

# Output Dataset YOLO: backend/datasets/id_cards
OUTPUT_DIR = BACKEND_DIR / "datasets" / "id_cards"

def convert():
    # Debug visivo dei percorsi
    print(f"üìÇ Script Dir: {SCRIPT_DIR}")
    print(f"üìÇ Cerco JSON qui: {JSON_EXPORT_PATH}")
    print(f"üìÇ Cerco Immagini qui: {RAW_IMAGES_DIR}")

    if not JSON_EXPORT_PATH.exists():
        print(f"‚ùå ERRORE: File non trovato: {JSON_EXPORT_PATH}")
        print("   Assicurati di aver salvato l'export di Label Studio come 'project_export.json'")
        print("   dentro la cartella: backend/tools/")
        return

    # Pulisci e crea cartelle output
    for split in ['train', 'val']:
        (OUTPUT_DIR / split / "images").mkdir(parents=True, exist_ok=True)
        (OUTPUT_DIR / split / "labels").mkdir(parents=True, exist_ok=True)

    try:
        with open(JSON_EXPORT_PATH, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except json.JSONDecodeError:
        print("‚ùå ERRORE: Il file JSON non √® valido o √® corrotto.")
        return

    print(f"üîÑ Elaborazione di {len(data)} task di annotazione...")
    
    success_count = 0

    for task in data:
        # 1. Trova il nome file originale
        # Label studio path es: "/data/upload/12/345-immagine.jpg"
        # Prendiamo l'ultima parte dopo eventuali separatori di percorso
        ls_path = task['data']['image']
        
        # In Label Studio locale, spesso il file viene rinominato con un hash prefisso (es. "8d7s6f-nomefile.jpg")
        # Tentiamo di recuperare il file originale.
        if '-' in ls_path:
            # Prende tutto dopo il primo trattino (rischiose se il file ha trattini, ma standard LS)
            # O meglio: controlliamo se esiste il file esatto in RAW, altrimenti cerchiamo il suffix
            filename_part = ls_path.split('/')[-1] # nomefile completo in LS
        else:
            filename_part = ls_path.split('/')[-1]

        # Cerchiamo il file nella cartella raw
        found_img_path = None
        
        # Tentativo 1: Cerca corrispondenza esatta nella cartella raw (se LS non ha rinominato)
        if (RAW_IMAGES_DIR / filename_part).exists():
            found_img_path = RAW_IMAGES_DIR / filename_part
        else:
            # Tentativo 2: Il nome in LS ha un hash davanti (es "34534-foto.jpg").
            # Cerchiamo nella cartella raw un file che "finisca" con la parte originale del nome.
            # Questo √® necessario perch√© non sappiamo l'hash esatto che LS ha generato se non usiamo il suo storage.
            original_name_candidate = filename_part
            if '-' in filename_part:
                 original_name_candidate = filename_part.split('-', 1)[-1] # Rimuove solo il primo pezzo (hash)
            
            if (RAW_IMAGES_DIR / original_name_candidate).exists():
                found_img_path = RAW_IMAGES_DIR / original_name_candidate
            else:
                # Tentativo 3: Ricerca brutale per suffisso (lento ma sicuro)
                for f in RAW_IMAGES_DIR.glob("*"):
                    if filename_part.endswith(f.name) or f.name in filename_part:
                        found_img_path = f
                        break
        
        if not found_img_path:
            print(f"‚ö†Ô∏è Immagine non trovata per: {filename_part}")
            continue

        # 2. Leggi dimensioni immagine (per normalizzare)
        img = cv2.imread(str(found_img_path))
        if img is None: 
            print(f"‚ö†Ô∏è Impossibile leggere immagine: {found_img_path}")
            continue
            
        h_img, w_img = img.shape[:2]

        # 3. Estrai annotazioni
        label_lines = []
        # Supporto sia per struttura export standard che snapshot
        annotations = task.get('annotations', [])
        
        for ann in annotations:
            for res in ann.get('result', []):
                # Gestiamo solo PolygonLabels
                if res['type'] != 'polygonlabels': continue
                
                points = res['value']['points'] # [[x,y], [x,y]...] in percentuale 0-100
                
                # YOLO OBB vuole: class x1 y1 x2 y2 x3 y3 x4 y4 (Normalizzati 0-1)
                
                flat_coords = []
                for p in points:
                    # Label studio usa coordinate relative 0-100
                    nx = p[0] / 100.0
                    ny = p[1] / 100.0
                    flat_coords.extend([f"{nx:.6f}", f"{ny:.6f}"])
                
                # Se abbiamo meno di 3 punti, non √® un poligono valido
                if len(points) < 3: continue
                
                # Class index 0 = id_card (unica classe)
                line = f"0 {' '.join(flat_coords)}"
                label_lines.append(line)

        if not label_lines:
            # Nessuna annotazione poligonale valida trovata
            continue

        # 4. Split Train/Val (80% Train, 20% Val)
        subset = "train" if random.random() < 0.8 else "val"
        
        # 5. Salva File
        # Usiamo un nome univoco basato sull'ID del task per evitare sovrascritture
        out_name = f"{task['id']}_{found_img_path.name}"
        
        # Copia immagine
        shutil.copy2(found_img_path, OUTPUT_DIR / subset / "images" / out_name)
        
        # Scrivi Label
        # Sostituisci estensione immagine con .txt
        txt_name = os.path.splitext(out_name)[0] + ".txt"
        with open(OUTPUT_DIR / subset / "labels" / txt_name, "w") as out_f:
            out_f.write("\n".join(label_lines))
            
        success_count += 1

    print("-" * 50)
    print(f"‚úÖ Conversione completata!")
    print(f"üìä Immagini processate con successo: {success_count}")
    print(f"üìÇ Cartella Output: {OUTPUT_DIR}")

if __name__ == "__main__":
    convert()
<FILE_END>

<FILE_START path="backend\tools\diagnose_env.py">
import os
import platform
import sys
import subprocess

def check_cpu_instructions():
    print("--- DIAGNOSTICA CPU E AMBIENTE ---")
    print(f"OS: {platform.system()} {platform.release()}")
    print(f"Architecture: {platform.machine()}")
    print(f"Python: {sys.version.split()[0]}")
    
    # Tentativo di rilevamento CPU
    try:
        if platform.system() == "Windows":
            command = "wmic cpu get name"
            output = subprocess.check_output(command, shell=True).decode().strip().split('\n')[1]
            print(f"CPU Model: {output}")
        else:
            # Linux/Mac fallback
            with open('/proc/cpuinfo') as f:
                for line in f:
                    if "model name" in line:
                        print(f"CPU Model: {line.split(':')[1].strip()}")
                        break
    except Exception as e:
        print(f"CPU Model detection failed: {e}")

    print("\n--- CONSIGLIO INSTALLAZIONE PADDLE ---")
    print("Se la tua CPU √® Intel Core (4a gen o superiore) o AMD Ryzen recente -> Supporta AVX.")
    print("Se sei su una VM Windows Server vecchia o CPU Celeron/Pentium vecchi -> Potrebbe NON supportare AVX.")
    print("\nREGOLA D'ORO:")
    print("1. Prova prima l'installazione STANDARD (MKL).")
    print("2. Esegui lo script 'verify_paddle.py' (che creeremo tra poco).")
    print("3. Se ottieni errore 'Illegal Instruction' o crash, passa alla versione NO-AVX.")

if __name__ == "__main__":
    check_cpu_instructions()
<FILE_END>

<FILE_START path="backend\tools\generate_synthetic_data.py">
# backend/tools/generate_synthetic_data.py
import cv2
import numpy as np
import os
import random
from pathlib import Path

# Configurazione
NUM_IMAGES = 100  # Generiamo 100 immagini finte
BASE_DIR = Path(__file__).resolve().parent.parent
TEMPLATES_DIR = BASE_DIR / "assets" / "templates"
OUTPUT_DIR = BASE_DIR / "datasets" / "id_cards"

# Crea cartelle
(OUTPUT_DIR / "train" / "images").mkdir(parents=True, exist_ok=True)
(OUTPUT_DIR / "train" / "labels").mkdir(parents=True, exist_ok=True)
(OUTPUT_DIR / "val" / "images").mkdir(parents=True, exist_ok=True)
(OUTPUT_DIR / "val" / "labels").mkdir(parents=True, exist_ok=True)

def create_random_background(h, w):
    """Crea uno sfondo rumoroso casuale"""
    # Colore base casuale (grigio/legno/tavolo)
    color = np.random.randint(100, 200, size=(1, 1, 3), dtype=np.uint8)
    bg = np.ones((h, w, 3), dtype=np.uint8) * color
    # Aggiungi rumore
    noise = np.random.randint(-50, 50, size=(h, w, 3), dtype=np.int16)
    bg = np.clip(bg + noise, 0, 255).astype(np.uint8)
    return bg

def rotate_image(image, angle):
    """Ruota l'immagine e calcola i nuovi 4 angoli"""
    h, w = image.shape[:2]
    cx, cy = w // 2, h // 2
    
    # Matrice di rotazione
    M = cv2.getRotationMatrix2D((cx, cy), angle, 1.0)
    cos = np.abs(M[0, 0])
    sin = np.abs(M[0, 1])
    
    # Nuove dimensioni bounding box
    nW = int((h * sin) + (w * cos))
    nH = int((h * cos) + (w * sin))
    
    M[0, 2] += (nW / 2) - cx
    M[1, 2] += (nH / 2) - cy
    
    rotated = cv2.warpAffine(image, M, (nW, nH), borderValue=(0,0,0))
    
    # Calcola le coordinate dei 4 angoli originali trasformati
    # Ordine: TL, TR, BR, BL
    corners = np.array([
        [0, 0],
        [w, 0],
        [w, h],
        [0, h]
    ])
    
    ones = np.ones(shape=(len(corners), 1))
    corners_ones = np.hstack([corners, ones])
    transformed = M.dot(corners_ones.T).T
    
    # Maschera alpha per incollare
    mask = cv2.warpAffine(np.ones((h, w), dtype=np.uint8)*255, M, (nW, nH))
    
    return rotated, mask, transformed

def generate():
    # Cerca i template disponibili (CIE, Patente, ecc.)
    templates = list(TEMPLATES_DIR.glob("*.jpg")) + list(TEMPLATES_DIR.glob("*.png"))
    if not templates:
        print(f"‚ùå Nessun template trovato in {TEMPLATES_DIR}")
        return

    print(f"üé® Generazione {NUM_IMAGES} immagini sintetiche da {len(templates)} template...")

    for i in range(NUM_IMAGES):
        # 1. Scegli template e sfondo
        tpl_path = random.choice(templates)
        card = cv2.imread(str(tpl_path))
        
        # Ridimensiona template a una dimensione realistica (es. larghezza 400-600px)
        target_w = random.randint(400, 600)
        aspect = card.shape[0] / card.shape[1]
        card = cv2.resize(card, (target_w, int(target_w * aspect)))
        
        # Sfondo pi√π grande
        bg_h, bg_w = 1024, 1024
        bg = create_random_background(bg_h, bg_w)
        
        # 2. Ruota la carta
        angle = random.randint(-180, 180)
        rot_card, mask, corners = rotate_image(card, angle)
        
        # 3. Posiziona la carta sullo sfondo
        h_rot, w_rot = rot_card.shape[:2]
        # Assicuriamoci che stia dentro
        max_x = bg_w - w_rot
        max_y = bg_h - h_rot
        
        if max_x < 0 or max_y < 0: continue # Skip se troppo grande dopo rotazione
        
        x_off = random.randint(0, max_x)
        y_off = random.randint(0, max_y)
        
        # Incolla
        roi = bg[y_off:y_off+h_rot, x_off:x_off+w_rot]
        # Dove la maschera √® > 0, usa la carta, altrimenti tieni lo sfondo
        mask_bool = mask > 0
        roi[mask_bool] = rot_card[mask_bool]
        bg[y_off:y_off+h_rot, x_off:x_off+w_rot] = roi
        
        # 4. Aggiorna coordinate assolute globali
        final_corners = corners + [x_off, y_off]
        
        # 5. Prepara Label YOLO OBB
        # Formato: class_index x1 y1 x2 y2 x3 y3 x4 y4 (Normalizzati 0-1)
        # class_index √® sempre 0 ("id_card")
        norm_corners = final_corners / [bg_w, bg_h]
        flat_coords = " ".join([f"{c[0]:.6f} {c[1]:.6f}" for c in norm_corners])
        label_str = f"0 {flat_coords}"
        
        # 6. Salva (Split 80/20 train/val)
        subset = "train" if i < (NUM_IMAGES * 0.8) else "val"
        filename = f"syn_{i:04d}"
        
        cv2.imwrite(str(OUTPUT_DIR / subset / "images" / f"{filename}.jpg"), bg)
        with open(OUTPUT_DIR / subset / "labels" / f"{filename}.txt", "w") as f:
            f.write(label_str)

    print("‚úÖ Generazione completata. Dataset pronto in backend/datasets/id_cards")

if __name__ == "__main__":
    generate()
<FILE_END>

<FILE_START path="backend\tools\project_export.json">
[{"id":10,"annotations":[{"id":2,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[10.409929892610046,28.756961808301405],[95.08451427682981,28.153293193394894],[96.47965952016929,58.15562335424843],[6.3318130274638476,57.73305532381387]],"closed":true,"polygonlabels":["id_card"]},"id":"nPE-XKasmR","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:27:19.992614Z","updated_at":"2026-01-28T14:27:19.992614Z","draft_created_at":"2026-01-28T14:25:48.460542Z","lead_time":107.949,"prediction":{},"result_count":1,"unique_id":"c722c6b7-ff42-4aa9-80ce-62fe7643ddeb","import_id":null,"last_action":null,"bulk_created":false,"task":10,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"6c59f319-1769537173_6fa0afed_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/6c59f319-1769537173_6fa0afed_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.969495Z","updated_at":"2026-01-28T14:27:20.867436Z","allow_skip":true,"inner_id":1,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":11,"annotations":[{"id":3,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[9.493591892546817,30.908199927986967],[94.19294216866015,29.004321988666444],[98.73335568248686,59.856064970345436],[9.328485946589478,61.016966152857954]],"closed":true,"polygonlabels":["id_card"]},"id":"A8olBmLxa9","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:28:10.971315Z","updated_at":"2026-01-28T14:28:10.971315Z","draft_created_at":"2026-01-28T14:27:44.702799Z","lead_time":35.354,"prediction":{},"result_count":1,"unique_id":"2a37e449-9c27-4f29-ba1c-868d96ca3634","import_id":null,"last_action":null,"bulk_created":false,"task":11,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"16eefd4b-1769537227_7590b910_BACK.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/16eefd4b-1769537227_7590b910_BACK.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.969495Z","updated_at":"2026-01-28T14:28:11.577126Z","allow_skip":true,"inner_id":2,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":12,"annotations":[{"id":13,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[10.32407480071222,28.67703608368779],[95.42793464442103,27.735313044433635],[97.10210893642846,58.81217333982075],[5.720095497691906,58.105881060380135]],"closed":true,"polygonlabels":["id_card"]},"id":"K3p6XJ7-C5","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:37:51.297391Z","updated_at":"2026-01-28T14:37:51.297391Z","draft_created_at":"2026-01-28T14:37:36.677960Z","lead_time":27.409,"prediction":{},"result_count":1,"unique_id":"722edf38-0112-4e31-bd10-6ba8e3c16a7c","import_id":null,"last_action":null,"bulk_created":false,"task":12,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"0100ad90-1769537227_caf21a69_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/0100ad90-1769537227_caf21a69_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.969495Z","updated_at":"2026-01-28T14:37:51.357122Z","allow_skip":true,"inner_id":3,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":13,"annotations":[{"id":14,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[10.302611027737779,28.19814577148245],[5.9025375679747745,57.89864162488272],[96.58697838504158,58.50231023978923],[95.51378973631887,27.835944602538543]],"closed":true,"polygonlabels":["id_card"]},"id":"jmLSBn4_3I","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:38:28.858974Z","updated_at":"2026-01-28T14:38:28.858974Z","draft_created_at":"2026-01-28T14:38:04.295512Z","lead_time":33.717,"prediction":{},"result_count":1,"unique_id":"6484219d-4359-4fa3-8379-d4b319e182a5","import_id":null,"last_action":null,"bulk_created":false,"task":13,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"156e6307-1769537443_693984f2_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/156e6307-1769537443_693984f2_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.969495Z","updated_at":"2026-01-28T14:38:28.917244Z","allow_skip":true,"inner_id":4,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":14,"annotations":[{"id":15,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[9.460544784054575,30.908766178041315],[94.86464084832805,28.64892714143924],[98.7525359650628,59.849285453235666],[8.682965760707624,61.23434808857242]],"closed":true,"polygonlabels":["id_card"]},"id":"MhGGGKHCoY","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:39:03.227329Z","updated_at":"2026-01-28T14:39:03.227329Z","draft_created_at":"2026-01-28T14:38:45.302919Z","lead_time":29.598,"prediction":{},"result_count":1,"unique_id":"c66fde22-4f91-4282-a43d-04e306630f60","import_id":null,"last_action":null,"bulk_created":false,"task":14,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"889976f3-1769537492_01e00b83_BACK.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/889976f3-1769537492_01e00b83_BACK.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.971059Z","updated_at":"2026-01-28T14:39:03.299119Z","allow_skip":true,"inner_id":5,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":15,"annotations":[{"id":16,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[9.975288489877364,28.07590287696388],[95.21866285792017,27.565802897367885],[97.75782720079805,58.78392164864314],[5.259697567389895,58.17180167312793]],"closed":true,"polygonlabels":["id_card"]},"id":"AQ2UCPp7VM","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:40:22.029658Z","updated_at":"2026-01-28T14:40:22.031670Z","draft_created_at":"2026-01-28T14:39:51.499269Z","lead_time":39.455,"prediction":{},"result_count":1,"unique_id":"0e2710e2-124a-4e7e-9c0b-06e700696459","import_id":null,"last_action":null,"bulk_created":false,"task":15,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"9d2aad11-1769537492_fa926c97_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/9d2aad11-1769537492_fa926c97_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.971059Z","updated_at":"2026-01-28T14:40:22.090885Z","allow_skip":true,"inner_id":6,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":16,"annotations":[{"id":17,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[5.869516378783305,57.75244701716657],[10.071462703397492,28.385692342691797],[95.28971738109104,27.60291325962622],[96.82284402212343,58.50941959863093]],"closed":true,"polygonlabels":["id_card"]},"id":"ucWLsF3dIn","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:41:09.964991Z","updated_at":"2026-01-28T14:41:09.964991Z","draft_created_at":"2026-01-28T14:40:31.931393Z","lead_time":46.066,"prediction":{},"result_count":1,"unique_id":"8e6c490a-c79e-43e6-b364-993d1b955e58","import_id":null,"last_action":null,"bulk_created":false,"task":16,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"3dbf62ab-1769537842_5a2c0c8b_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/3dbf62ab-1769537842_5a2c0c8b_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.971059Z","updated_at":"2026-01-28T14:41:10.021036Z","allow_skip":true,"inner_id":7,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":29,"annotations":[{"id":4,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":270,"value":{"points":[[77.85145888594162,93.89920424403185],[9.946949602121986,93.79973474801061],[9.283819628647215,13.129973474801051],[78.3819628647215,13.42838196286472]],"closed":true,"polygonlabels":["id_card"]},"id":"9DTID0iO63","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:29:16.171855Z","updated_at":"2026-01-28T14:29:16.171855Z","draft_created_at":"2026-01-28T14:28:56.759364Z","lead_time":35.577,"prediction":{},"result_count":1,"unique_id":"58199c1f-0d5b-463e-9682-fe31e992c720","import_id":null,"last_action":null,"bulk_created":false,"task":29,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"8ad33a03-1769596492_99194ebe_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/8ad33a03-1769596492_99194ebe_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.980804Z","updated_at":"2026-01-28T14:29:17.480114Z","allow_skip":true,"inner_id":20,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":30,"annotations":[{"id":5,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":270,"value":{"points":[[78.57438920113,8.014028237017376],[82.09549071618035,73.40848806366049],[24.403183023872668,73.1100795755968],[26.525198938992045,9.946949602122007]],"closed":true,"polygonlabels":["id_card"]},"id":"HMrvMFJ_8a","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:31:38.001613Z","updated_at":"2026-01-28T14:31:38.001613Z","draft_created_at":"2026-01-28T14:31:11.739804Z","lead_time":47.47,"prediction":{},"result_count":1,"unique_id":"2229aa5b-db6a-4ae7-a562-744d296186b9","import_id":null,"last_action":null,"bulk_created":false,"task":30,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"605b30e9-1769596780_4d3a2d9d_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/605b30e9-1769596780_4d3a2d9d_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.980804Z","updated_at":"2026-01-28T14:31:38.461137Z","allow_skip":true,"inner_id":21,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":31,"annotations":[{"id":6,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[10.236568649354828,28.302455064533564],[95.26613081738284,27.977402733430058],[97.24740216887088,58.64872774053242],[5.8612610814854245,57.95218703102491]],"closed":true,"polygonlabels":["id_card"]},"id":"QuF2fl2cOL","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:32:43.463166Z","updated_at":"2026-01-28T14:32:43.463166Z","draft_created_at":"2026-01-28T14:32:28.713075Z","lead_time":53.75,"prediction":{},"result_count":1,"unique_id":"7b2dbf69-8e19-47f9-9f37-fbaa16c07c2a","import_id":null,"last_action":null,"bulk_created":false,"task":31,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"eb3c0a61-1769605683_852bab5b_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/eb3c0a61-1769605683_852bab5b_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.981857Z","updated_at":"2026-01-28T14:32:43.953510Z","allow_skip":true,"inner_id":22,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":32,"annotations":[{"id":7,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":270,"value":{"points":[[78.91246684350133,8.057029177718832],[81.9628647214854,73.80636604774537],[24.403183023872668,73.30901856763926],[26.12732095490717,9.748010610079568]],"closed":true,"polygonlabels":["id_card"]},"id":"DhsZOqHnxI","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:33:37.651064Z","updated_at":"2026-01-28T14:33:37.651064Z","draft_created_at":"2026-01-28T14:33:07.886915Z","lead_time":40.32,"prediction":{},"result_count":1,"unique_id":"18e24fd3-0845-4596-9f09-6eeb6896e204","import_id":null,"last_action":null,"bulk_created":false,"task":32,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"5e7a382a-1769605932_e803dcdb_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/5e7a382a-1769605932_e803dcdb_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.981857Z","updated_at":"2026-01-28T14:33:38.279087Z","allow_skip":true,"inner_id":23,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":45,"annotations":[{"id":39,"completed_by":1,"result":[{"original_width":1014,"original_height":644,"image_rotation":0,"value":{"points":[[0,0.45375624250451974],[99.32756964457252,0.9075124850090395],[99.71181556195965,99.52386918932466],[0.48030739673390976,99.07011294682013]],"closed":true,"polygonlabels":["id_card"]},"id":"rY1i_WokOq","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:56:24.599750Z","updated_at":"2026-01-28T14:56:24.599750Z","draft_created_at":"2026-01-28T14:55:47.813581Z","lead_time":46.32,"prediction":{},"result_count":1,"unique_id":"2cd9b994-528f-4c74-995b-d41c29348cf5","import_id":null,"last_action":null,"bulk_created":false,"task":45,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"0146de63-1769608197_6c624c3e_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/0146de63-1769608197_6c624c3e_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:56:24.659289Z","allow_skip":true,"inner_id":36,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":46,"annotations":[{"id":38,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[9.372236958443855,13.262599469496022],[79.04509283819631,12.9973474801061],[76.9230769230769,94.16445623342176],[10.256410256410257,94.16445623342177]],"closed":true,"polygonlabels":["id_card"]},"id":"ExyDpPO3ht","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:55:36.175570Z","updated_at":"2026-01-28T14:55:36.175570Z","draft_created_at":"2026-01-28T14:55:08.649646Z","lead_time":35.287,"prediction":{},"result_count":1,"unique_id":"a0ec72a9-a601-41cc-8b00-3fd59040585f","import_id":null,"last_action":null,"bulk_created":false,"task":46,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"b78e933c-WhatsApp_Image_2026-01-28_at_11.05.58.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/b78e933c-WhatsApp_Image_2026-01-28_at_11.05.58.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:55:36.239673Z","allow_skip":true,"inner_id":37,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":47,"annotations":[{"id":37,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[24.93368700265252,23.47480106100796],[77.45358090185677,23.740053050397876],[74.97789566755084,81.43236074270557],[26.348364279398762,82.75862068965517]],"closed":true,"polygonlabels":["id_card"]},"id":"W2mjeiTr1j","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:54:56.000467Z","updated_at":"2026-01-28T14:54:56.000467Z","draft_created_at":"2026-01-28T14:54:49.423351Z","lead_time":16.072,"prediction":{},"result_count":1,"unique_id":"b051392e-5e11-4677-af9b-c6326e1d59f2","import_id":null,"last_action":null,"bulk_created":false,"task":47,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"958e4f9e-WhatsApp_Image_2026-01-28_at_11.06.00.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/958e4f9e-WhatsApp_Image_2026-01-28_at_11.06.00.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:54:56.060750Z","allow_skip":true,"inner_id":38,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":48,"annotations":[{"id":36,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[26.702033598585324,82.75862068965517],[73.03271441202475,82.89124668435014],[72.85587975243148,27.055702917771885],[24.933687002652515,27.18832891246684]],"closed":true,"polygonlabels":["id_card"]},"id":"RLayg_Xzcn","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:54:37.811138Z","updated_at":"2026-01-28T14:54:37.811138Z","draft_created_at":"2026-01-28T14:54:23.612032Z","lead_time":22.486,"prediction":{},"result_count":1,"unique_id":"89050832-f07d-4513-bf75-cfa6c6d755d7","import_id":null,"last_action":null,"bulk_created":false,"task":48,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"b6e88e21-WhatsApp_Image_2026-01-28_at_11.06.01.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/b6e88e21-WhatsApp_Image_2026-01-28_at_11.06.01.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:54:37.872278Z","allow_skip":true,"inner_id":39,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":49,"annotations":[{"id":35,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[24.892879004284836,86.10487655580495],[23.668639053254438,23.36257906549684],[78.35135686594572,23.464599061416042],[76.58301027001292,85.39073658437056]],"closed":true,"polygonlabels":["id_card"]},"id":"1NTk83VRU9","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:54:13.357656Z","updated_at":"2026-01-28T14:54:13.357656Z","draft_created_at":"2026-01-28T14:53:54.052229Z","lead_time":33.44,"prediction":{},"result_count":1,"unique_id":"e2ad20df-d339-4bfd-8245-4ec4f558200c","import_id":null,"last_action":null,"bulk_created":false,"task":49,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"53eb6a16-WhatsApp_Image_2026-01-28_at_11.06.04.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/53eb6a16-WhatsApp_Image_2026-01-28_at_11.06.04.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:54:13.417421Z","allow_skip":true,"inner_id":40,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":50,"annotations":[{"id":34,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[30.658316722385276,38.68912152935822],[78.68619172434718,37.11958313060128],[77.63983279184257,88.07150816944737],[35.05302423890467,89.95495424795568]],"closed":true,"polygonlabels":["id_card"]},"id":"0i67nOOXMr","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:53:36.995297Z","updated_at":"2026-01-28T14:53:36.995297Z","draft_created_at":"2026-01-28T14:53:17.322698Z","lead_time":29.291,"prediction":{},"result_count":1,"unique_id":"7f5db9ba-5911-48bf-b23c-96903d634fd9","import_id":null,"last_action":null,"bulk_created":false,"task":50,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"6f05cb34-WhatsApp_Image_2026-01-28_at_11.06.10.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/6f05cb34-WhatsApp_Image_2026-01-28_at_11.06.10.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:53:37.059149Z","allow_skip":true,"inner_id":41,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":51,"annotations":[{"id":33,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[44.51854812063874,31.886983576591653],[78.4044797040575,31.16258123870384],[78.79887653246307,70.5409715925623],[45.87881473289474,70.78243903852493]],"closed":true,"polygonlabels":["id_card"]},"id":"8v-h5Pxipx","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:52:52.731783Z","updated_at":"2026-01-28T14:52:52.731783Z","draft_created_at":"2026-01-28T14:52:21.143000Z","lead_time":41.349,"prediction":{},"result_count":1,"unique_id":"d873594d-3fca-4515-ad3f-5f2be9515969","import_id":null,"last_action":null,"bulk_created":false,"task":51,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"eb10cd35-WhatsApp_Image_2026-01-28_at_11.06.20.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/eb10cd35-WhatsApp_Image_2026-01-28_at_11.06.20.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:52:52.804395Z","allow_skip":true,"inner_id":42,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":52,"annotations":[{"id":32,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[16.672752221227416,18.594735354266362],[80.60413315227875,13.679148061456212],[80.60413315227873,94.39450571872526],[19.662349171240603,89.30644167879896]],"closed":true,"polygonlabels":["id_card"]},"id":"KX-TXJmtXd","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:52:06.567743Z","updated_at":"2026-01-28T14:52:06.567743Z","draft_created_at":"2026-01-28T14:51:40.991299Z","lead_time":38.365,"prediction":{},"result_count":1,"unique_id":"bfc75bbe-da27-4f62-b71b-f119eb7d1445","import_id":null,"last_action":null,"bulk_created":false,"task":52,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"01229e78-WhatsApp_Image_2026-01-28_at_11.06.33.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/01229e78-WhatsApp_Image_2026-01-28_at_11.06.33.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:52:06.633335Z","allow_skip":true,"inner_id":43,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":53,"annotations":[{"id":31,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[26.52922339642475,22.25557155948128],[78.60570257569299,22.315938420971936],[79.28181142438827,82.46113279622921],[28.41266947493306,83.78920374902354]],"closed":true,"polygonlabels":["id_card"]},"id":"dEnKC2Ml1u","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:51:11.224249Z","updated_at":"2026-01-28T14:51:11.224249Z","draft_created_at":"2026-01-28T14:50:40.595029Z","lead_time":41.364,"prediction":{},"result_count":1,"unique_id":"6bc11400-4ccf-4b78-8862-815c1931cc28","import_id":null,"last_action":null,"bulk_created":false,"task":53,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"a8d89f4f-WhatsApp_Image_2026-01-28_at_11.06.34_1.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/a8d89f4f-WhatsApp_Image_2026-01-28_at_11.06.34_1.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:51:11.277575Z","allow_skip":true,"inner_id":44,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":54,"annotations":[{"id":30,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[24.668544981254463,13.561165085205307],[79.0243094017577,11.878902775079688],[83.0663745133137,78.9541777552289],[23.925508410675413,79.4588564482666]],"closed":true,"polygonlabels":["id_card"]},"id":"OjcDkmFCZS","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:50:15.247373Z","updated_at":"2026-01-28T14:50:15.247373Z","draft_created_at":"2026-01-28T14:49:47.900058Z","lead_time":41.299,"prediction":{},"result_count":1,"unique_id":"2fa02e06-4503-43f6-b608-7ec052ac4c29","import_id":null,"last_action":null,"bulk_created":false,"task":54,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"e06a7198-WhatsApp_Image_2026-01-28_at_11.06.34_2.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/e06a7198-WhatsApp_Image_2026-01-28_at_11.06.34_2.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.991548Z","updated_at":"2026-01-28T14:50:15.305893Z","allow_skip":true,"inner_id":45,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":55,"annotations":[{"id":29,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[18.415917212081254,21.050649004127887],[75.86102260658473,19.951972124998036],[73.03585348882224,79.20361621647076],[26.57751688561727,80.06686233578706]],"closed":true,"polygonlabels":["id_card"]},"id":"UUMylbR5HW","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:49:30.926350Z","updated_at":"2026-01-28T14:49:30.926350Z","draft_created_at":"2026-01-28T14:49:13.567579Z","lead_time":28.487,"prediction":{},"result_count":1,"unique_id":"a7cc30c9-5ccd-4cf3-b009-4c71f65c6036","import_id":null,"last_action":null,"bulk_created":false,"task":55,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"9d8e669a-WhatsApp_Image_2026-01-28_at_11.06.34_3.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/9d8e669a-WhatsApp_Image_2026-01-28_at_11.06.34_3.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.991548Z","updated_at":"2026-01-28T14:49:30.984990Z","allow_skip":true,"inner_id":46,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":56,"annotations":[{"id":28,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[17.055650599825256,26.96702399824212],[66.44379221404316,25.78987019917442],[67.80405882629917,82.97050837348735],[21.345722223094185,83.44136989311446]],"closed":true,"polygonlabels":["id_card"]},"id":"e8AjZRbWur","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:48:59.733752Z","updated_at":"2026-01-28T14:48:59.733752Z","draft_created_at":"2026-01-28T14:48:38.300708Z","lead_time":31.451,"prediction":{},"result_count":1,"unique_id":"6c8cdb01-0983-4897-8de3-759b1625d6ce","import_id":null,"last_action":null,"bulk_created":false,"task":56,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"ed416253-WhatsApp_Image_2026-01-28_at_11.06.34.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/ed416253-WhatsApp_Image_2026-01-28_at_11.06.34.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.991548Z","updated_at":"2026-01-28T14:48:59.797437Z","allow_skip":true,"inner_id":47,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":57,"annotations":[{"id":27,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[26.41666666666666,9.562499999999996],[79.16666666666666,8.812499999999996],[81.83333333333331,73.125],[24.16666666666666,73.125]],"closed":true,"polygonlabels":["id_card"]},"id":"aM5WaoBJI0","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:48:11.187606Z","updated_at":"2026-01-28T14:48:11.187606Z","draft_created_at":"2026-01-28T14:47:51.725913Z","lead_time":35.679,"prediction":{},"result_count":1,"unique_id":"20a741ce-cdbf-4209-92b8-e6ad15a20668","import_id":null,"last_action":null,"bulk_created":false,"task":57,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"7f2fd10f-WhatsApp_Image_2026-01-28_at_11.06.35_1.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/7f2fd10f-WhatsApp_Image_2026-01-28_at_11.06.35_1.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.991548Z","updated_at":"2026-01-28T14:48:11.254836Z","allow_skip":true,"inner_id":48,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":58,"annotations":[{"id":26,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[14.323607427055704,12.864721485411138],[79.75243147656941,10.742705570291777],[79.22192749778957,90.05305039787798],[15.384615384615385,87.26790450928382]],"closed":true,"polygonlabels":["id_card"]},"id":"kO9XIErnKe","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:47:31.130877Z","updated_at":"2026-01-28T14:47:31.130877Z","draft_created_at":"2026-01-28T14:47:06.967177Z","lead_time":33.289,"prediction":{},"result_count":1,"unique_id":"d2ccbb7e-d251-4429-ae3b-fc0fd62611d4","import_id":null,"last_action":null,"bulk_created":false,"task":58,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"f0507490-WhatsApp_Image_2026-01-28_at_11.06.35_2.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/f0507490-WhatsApp_Image_2026-01-28_at_11.06.35_2.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.991548Z","updated_at":"2026-01-28T14:47:31.187134Z","allow_skip":true,"inner_id":49,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":59,"annotations":[{"id":25,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[38.31283475939981,15.816117710550554],[90.22833564135965,17.928957862723337],[90.38931393866805,78.0543519074117],[40.003106881138045,81.2537955664162]],"closed":true,"polygonlabels":["id_card"]},"id":"2nr4docsa8","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:46:55.132037Z","updated_at":"2026-01-28T14:46:55.132037Z","draft_created_at":"2026-01-28T14:46:45.618966Z","lead_time":22.225,"prediction":{},"result_count":1,"unique_id":"b86d0975-a0f7-471f-9d90-e3a09ed401c6","import_id":null,"last_action":null,"bulk_created":false,"task":59,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"5aa78e32-WhatsApp_Image_2026-01-28_at_11.06.35_3.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/5aa78e32-WhatsApp_Image_2026-01-28_at_11.06.35_3.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.991548Z","updated_at":"2026-01-28T14:46:55.229263Z","allow_skip":true,"inner_id":50,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":60,"annotations":[{"id":24,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[19.85667297299146,22.028652527137915],[22.13451587990536,87.8058939788885],[77.99398504592105,87.74552711739784],[76.30371292418282,21.00766779874654]],"closed":true,"polygonlabels":["id_card"]},"id":"LzCMVvjxnw","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:45:54.475304Z","updated_at":"2026-01-28T14:46:30.559419Z","draft_created_at":null,"lead_time":37.706,"prediction":{},"result_count":1,"unique_id":"09d90b82-2ffb-4578-bec5-743cf6ca9d8b","import_id":null,"last_action":null,"bulk_created":false,"task":60,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"f1054b66-WhatsApp_Image_2026-01-28_at_11.06.35_4.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/f1054b66-WhatsApp_Image_2026-01-28_at_11.06.35_4.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.992333Z","updated_at":"2026-01-28T14:46:30.661140Z","allow_skip":true,"inner_id":51,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":61,"annotations":[{"id":23,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[20.412048098705448,22.28026160583095],[76.59347385933796,20.710723207074025],[77.91349589726686,87.8058939788885],[22.05402673125116,87.6851602559072]],"closed":true,"polygonlabels":["id_card"]},"id":"neFILDCqEP","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:45:40.247595Z","updated_at":"2026-01-28T14:45:40.247595Z","draft_created_at":"2026-01-28T14:45:17.473078Z","lead_time":33.266,"prediction":{},"result_count":1,"unique_id":"b95ea83c-7114-4bba-afe6-11e21affa958","import_id":null,"last_action":null,"bulk_created":false,"task":61,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"27b78437-WhatsApp_Image_2026-01-28_at_11.06.35_5.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/27b78437-WhatsApp_Image_2026-01-28_at_11.06.35_5.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.992333Z","updated_at":"2026-01-28T14:45:40.305588Z","allow_skip":true,"inner_id":52,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":62,"annotations":[{"id":22,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[14.41932140775149,20.474377657128695],[65.37514397883429,16.062953163581124],[66.96397880624095,82.87220456788933],[16.90272121738227,79.6842571676593]],"closed":true,"polygonlabels":["id_card"]},"id":"dE-8JfPQMC","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:45:05.148496Z","updated_at":"2026-01-28T14:45:05.148496Z","draft_created_at":"2026-01-28T14:44:37.671944Z","lead_time":37.609,"prediction":{},"result_count":1,"unique_id":"f3fefe99-54aa-47cc-ab36-0479931d90ef","import_id":null,"last_action":null,"bulk_created":false,"task":62,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"a9458bd9-WhatsApp_Image_2026-01-28_at_11.06.35.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/a9458bd9-WhatsApp_Image_2026-01-28_at_11.06.35.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.013226Z","updated_at":"2026-01-28T14:45:05.204555Z","allow_skip":true,"inner_id":53,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":63,"annotations":[{"id":21,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[39.23633269790789,26.29930835344161],[40.244574327100636,71.8233607087881],[77.29204507958342,71.01354465095365],[77.06774343823334,26.743657237894414]],"closed":true,"polygonlabels":["id_card"]},"id":"Ahn0EYrr_r","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:44:25.317308Z","updated_at":"2026-01-28T14:44:25.317308Z","draft_created_at":"2026-01-28T14:43:50.334806Z","lead_time":46.328,"prediction":{},"result_count":1,"unique_id":"427061f5-f857-4182-85de-06cd92ff175e","import_id":null,"last_action":null,"bulk_created":false,"task":63,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"2a1bab9b-WhatsApp_Image_2026-01-28_at_11.06.36_1.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/2a1bab9b-WhatsApp_Image_2026-01-28_at_11.06.36_1.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.013226Z","updated_at":"2026-01-28T14:44:25.381550Z","allow_skip":true,"inner_id":54,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":64,"annotations":[{"id":20,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[8.253233473542332,21.40522537410505],[10.896992433184174,54.562355578088365],[80.38808476458934,52.660566546495645],[80.06050821758127,19.141565620353976]],"closed":true,"polygonlabels":["id_card"]},"id":"ddG80DdbUW","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:43:37.181188Z","updated_at":"2026-01-28T14:43:37.181188Z","draft_created_at":"2026-01-28T14:43:23.684205Z","lead_time":32.214,"prediction":{},"result_count":1,"unique_id":"05e0bf4e-764f-4e62-8c6f-835bff511fb5","import_id":null,"last_action":null,"bulk_created":false,"task":64,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"1cb2043a-WhatsApp_Image_2026-01-28_at_11.06.36_2.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/1cb2043a-WhatsApp_Image_2026-01-28_at_11.06.36_2.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.013226Z","updated_at":"2026-01-28T14:43:37.240750Z","allow_skip":true,"inner_id":55,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":65,"annotations":[{"id":19,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":270,"value":{"points":[[63.69354716896826,30.3492737713987],[32.23075593679226,30.988954014823967],[33.36796525843715,67.94825696828374],[64.92552393408359,67.66395463787254]],"closed":true,"polygonlabels":["id_card"]},"id":"b5cNvByM6x","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:43:02.060479Z","updated_at":"2026-01-28T14:43:02.060479Z","draft_created_at":"2026-01-28T14:42:41.290739Z","lead_time":35.94,"prediction":{},"result_count":1,"unique_id":"e414eefa-98ce-4089-bb09-68f48b48f3f2","import_id":null,"last_action":null,"bulk_created":false,"task":65,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"6d99fdb7-WhatsApp_Image_2026-01-28_at_11.06.36.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/6d99fdb7-WhatsApp_Image_2026-01-28_at_11.06.36.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.015475Z","updated_at":"2026-01-28T14:43:02.124016Z","allow_skip":true,"inner_id":56,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":66,"annotations":[{"id":18,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[29.37426210962503,71.26886398413683],[66.06493094999402,70.59554129827954],[66.24612131250205,26.01393993688118],[27.15536356420681,26.21873830798933]],"closed":true,"polygonlabels":["id_card"]},"id":"oaIsnBZAmx","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:42:22.248552Z","updated_at":"2026-01-28T14:42:22.248552Z","draft_created_at":"2026-01-28T14:41:48.010658Z","lead_time":47.363,"prediction":{},"result_count":1,"unique_id":"19760869-c82e-453e-b1ab-7ac85ea0a5ae","import_id":null,"last_action":null,"bulk_created":false,"task":66,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"dd45871f-WhatsApp_Image_2026-01-28_at_11.06.37_1.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/dd45871f-WhatsApp_Image_2026-01-28_at_11.06.37_1.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.015475Z","updated_at":"2026-01-28T14:42:22.309221Z","allow_skip":true,"inner_id":57,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":67,"annotations":[{"id":12,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":270,"value":{"points":[[67.77188328912467,18.79973474801061],[66.97612732095489,78.38196286472149],[18.965517241379292,78.87931034482757],[14.986737400530492,19.49602122015914]],"closed":true,"polygonlabels":["id_card"]},"id":"7iZ_Nw0gCQ","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:36:59.232899Z","updated_at":"2026-01-28T14:36:59.232899Z","draft_created_at":"2026-01-28T14:36:41.687041Z","lead_time":27.358,"prediction":{},"result_count":1,"unique_id":"f8869cbe-e18d-424a-b36b-2030e4d09dcb","import_id":null,"last_action":null,"bulk_created":false,"task":67,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"3df5a6ee-WhatsApp_Image_2026-01-28_at_11.06.37_2.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/3df5a6ee-WhatsApp_Image_2026-01-28_at_11.06.37_2.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.017980Z","updated_at":"2026-01-28T14:36:59.293155Z","allow_skip":true,"inner_id":58,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":68,"annotations":[{"id":11,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[24.348772359382437,34.36033462558662],[62.16418418009929,33.13609467455621],[63.66047745358089,78.0248928790043],[27.341358906345636,77.92287288308508]],"closed":true,"polygonlabels":["id_card"]},"id":"Be549WBxU_","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:36:19.683229Z","updated_at":"2026-01-28T14:36:19.683229Z","draft_created_at":"2026-01-28T14:36:07.563991Z","lead_time":21.541,"prediction":{},"result_count":1,"unique_id":"0f8fbbc7-af04-4aae-8760-4899caaae15f","import_id":null,"last_action":null,"bulk_created":false,"task":68,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"f8785ee4-WhatsApp_Image_2026-01-28_at_11.06.37.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/f8785ee4-WhatsApp_Image_2026-01-28_at_11.06.37.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.017980Z","updated_at":"2026-01-28T14:36:19.747315Z","allow_skip":true,"inner_id":59,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":69,"annotations":[{"id":8,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[14.323607427055704,40.58355437665783],[72.14854111405835,39.257294429708224],[72.6173099158204,66.49035518653963],[14.85829684156556,67.74598590554518]],"closed":true,"polygonlabels":["id_card"]},"id":"ZWkeq9T1ix","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:34:49.669072Z","updated_at":"2026-01-28T14:34:49.669072Z","draft_created_at":"2026-01-28T14:34:32.510551Z","lead_time":39.45,"prediction":{},"result_count":1,"unique_id":"89cacfdc-78dd-4ea9-a803-fb2ece4d552a","import_id":null,"last_action":null,"bulk_created":false,"task":69,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"4bc5117e-WhatsApp_Image_2026-01-28_at_11.06.38_1.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/4bc5117e-WhatsApp_Image_2026-01-28_at_11.06.38_1.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.017980Z","updated_at":"2026-01-28T14:34:49.733090Z","allow_skip":true,"inner_id":60,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":70,"annotations":[{"id":9,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[4.597701149425287,34.48275862068966],[90.89301503094606,33.02387267904509],[92.13085764809902,74.13793103448276],[6.18921308576481,75.06631299734748]],"closed":true,"polygonlabels":["id_card"]},"id":"Hj_t85VU_L","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:35:16.554225Z","updated_at":"2026-01-28T14:35:16.554225Z","draft_created_at":"2026-01-28T14:35:01.999409Z","lead_time":23.256,"prediction":{},"result_count":1,"unique_id":"a6c88b82-9e49-4afe-befe-a97fab59cdb0","import_id":null,"last_action":null,"bulk_created":false,"task":70,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"d76b9b41-WhatsApp_Image_2026-01-28_at_11.06.38_2.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/d76b9b41-WhatsApp_Image_2026-01-28_at_11.06.38_2.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.017980Z","updated_at":"2026-01-28T14:35:16.613735Z","allow_skip":true,"inner_id":61,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":71,"annotations":[{"id":10,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":270,"value":{"points":[[28.603006189213083,15.251989389920423],[71.35278514588857,14.953580901856762],[70.5128205128205,64.45623342175067],[29.48717948717949,64.45623342175067]],"closed":true,"polygonlabels":["id_card"]},"id":"pMocMAC2R7","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:35:54.337038Z","updated_at":"2026-01-28T14:35:54.337038Z","draft_created_at":"2026-01-28T14:35:29.112629Z","lead_time":32.269,"prediction":{},"result_count":1,"unique_id":"a158b2b4-d6a6-43ae-bbe3-c0ebdaafdbcd","import_id":null,"last_action":null,"bulk_created":false,"task":71,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"ee9663f5-WhatsApp_Image_2026-01-28_at_11.06.38.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/ee9663f5-WhatsApp_Image_2026-01-28_at_11.06.38.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.017980Z","updated_at":"2026-01-28T14:35:54.404470Z","allow_skip":true,"inner_id":62,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]}]
<FILE_END>

<FILE_START path="backend\tools\test_yolo_inference.py">
# backend/tools/test_yolo_inference.py
import sys
import os
import cv2
from pathlib import Path

# Aggiungiamo la root del backend al path per poter importare i moduli app.*
BASE_DIR = Path(__file__).resolve().parent.parent
sys.path.append(str(BASE_DIR))

from app.services.image_utils import isolate_document_yolo, cv2_to_pil, pil_to_cv2

def test_inference():
    print("üß† TEST INFERENZA YOLOv11...")
    
    # 1. Prendiamo un'immagine dal dataset di validazione generato prima
    val_dir = BASE_DIR / "datasets" / "id_cards" / "val" / "images"
    images = list(val_dir.glob("*.jpg"))
    
    if not images:
        print("‚ùå Nessuna immagine trovata in datasets/id_cards/val/images")
        return

    # Prendiamo la prima immagine
    target_img_path = images[0]
    print(f"üìÑ Test su immagine: {target_img_path.name}")
    
    # Carichiamo come PIL (come farebbe il backend)
    original_pil = cv2_to_pil(cv2.imread(str(target_img_path)))
    
    # 2. ESEGUIAMO LA MAGIA
    # Questa funzione ora usa il tuo modello id_card_detector_v11n.pt!
    try:
        cropped_pil = isolate_document_yolo(original_pil, debug_prefix="TEST_MANUALE")
    except Exception as e:
        print(f"‚ùå Errore durante l'inferenza: {e}")
        return

    if cropped_pil:
        print("‚úÖ SUCCESSO! Documento rilevato e raddrizzato.")
        
        # Salviamo il risultato per vederlo
        out_path = "test_result_cropped.jpg"
        pil_to_cv2(cropped_pil) # Riconvertiamo per salvare con cv2 se necessario, o usa save del PIL
        cropped_pil.save(out_path)
        print(f"üíæ Risultato salvato in: {os.path.abspath(out_path)}")
        print("   Aprilo e verifica che sia un rettangolo perfetto senza sfondo!")
    else:
        print("‚ùå FALLITO. Il modello non ha trovato nulla (o il file .pt non √® nel posto giusto).")

if __name__ == "__main__":
    test_inference()
<FILE_END>

<FILE_START path="backend\tools\train_yolo.py">
# backend/tools/train_yolo.py
from ultralytics import YOLO
import os

def train_document_detector():
    """
    Script per addestrare YOLOv11n-OBB sul dataset di documenti.
    Output: un modello .pt ottimizzato per il crop dei documenti.
    """
    # 1. Carica il modello pre-addestrato nano (pi√π veloce per CPU)
    # La versione -obb (Oriented Bounding Box) √® cruciale per documenti ruotati
    model = YOLO("yolo11n-obb.pt") 

    # 2. Configura i percorsi
    # Assicurati di avere un file dataset.yaml nel formato standard YOLO
    # che punta alle tue immagini annotate.
    dataset_yaml = "dataset.yaml" 
    
    if not os.path.exists(dataset_yaml):
        print("‚ùå ERRORE: File 'dataset.yaml' mancante.")
        print("   Crea un file YAML che punti alle cartelle 'train' e 'val' delle immagini annotate.")
        return

    print("üöÄ Avvio Training YOLOv11-OBB...")
    
    # 3. Avvia il training
    # epochs=100: un buon bilanciamento iniziale
    # imgsz=640: risoluzione standard
    # device='cpu' o '0' (se hai GPU Nvidia)
    results = model.train(
        data=dataset_yaml, 
        epochs=100, 
        imgsz=640, 
        patience=20,
        batch=16,
        project="rafting_republic_train",
        name="id_card_obb"
    )

    # 4. Export del modello migliore
    # Lo salviamo dove il backend se lo aspetta
    backend_model_dir = os.path.join("..", "assets", "models")
    os.makedirs(backend_model_dir, exist_ok=True)
    
    best_model_path = os.path.join("rafting_republic_train", "id_card_obb", "weights", "best.pt")
    dest_path = os.path.join(backend_model_dir, "id_card_detector_v11n.pt")
    
    if os.path.exists(best_model_path):
        import shutil
        shutil.copy2(best_model_path, dest_path)
        print(f"‚úÖ Modello salvato e pronto in: {dest_path}")
    else:
        print("‚ö†Ô∏è Training completato ma non trovo i pesi finali.")

if __name__ == "__main__":
    train_document_detector()
<FILE_END>

<FILE_START path="backend\tools\verify_paddle.py">
import os
import sys
import time
import numpy as np

# Disabilitiamo i log di debug e il check online
os.environ["GLOG_minloglevel"] = "2"
os.environ["DISABLE_MODEL_SOURCE_CHECK"] = "True"

print("‚è≥ [STEP 1] Avvio test di importazione librerie...")

try:
    # 1. Verifica Numpy
    print(f"‚úÖ Numpy importato. Versione: {np.__version__}")
    if int(np.__version__.split('.')[0]) >= 2:
        raise ImportError("‚ùå ERRORE FATALE: Numpy versione 2.x rilevata!")

    # 2. Import Core e Toolkit
    import paddle
    import paddleocr
    from paddleocr import PaddleOCR
    
    print(f"‚úÖ Paddle Core: {paddle.__version__}")
    print(f"‚úÖ Paddle OCR: {paddleocr.__version__}")

    # 3. Test Inferenza Dummy
    print("\n‚è≥ [STEP 2] Avvio Inferenza Dummy (Configurazione Sicura)...")

    # CONFIGURAZIONE SICURA PER PADDLEOCR v3.3.3
    ocr = PaddleOCR(
        use_textline_orientation=False, # Aggiornato da use_angle_cls
        lang='it', 
        use_gpu=False,
        enable_mkldnn=False             # Disabilitato per stabilit√† massima
    )
    
    img = np.zeros((100, 100, 3), dtype=np.uint8)
    
    start = time.time()
    result = ocr.ocr(img, cls=False)
    end = time.time()
    
    print(f"‚úÖ Inferenza completata in {end - start:.4f} secondi.")
    print("\nüéâ SISTEMA PRONTO E STABILE.")

except Exception as e:
    print(f"\n‚ùå ERRORE RUNTIME: {e}")
    sys.exit(1)
<FILE_END>

<FILE_START path="backend\tools\zone_calibrator.py">
import cv2
import json
import sys
import os

# --- CONFIGURAZIONE ROBUSTA DEI PERCORSI ---
# Ottiene la cartella dove si trova questo script (backend/tools)
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
# Risale alla cartella padre (backend)
BACKEND_DIR = os.path.dirname(CURRENT_DIR)
# Costruisce il percorso assoluto verso l'immagine
TEMPLATE_PATH = os.path.join(BACKEND_DIR, "assets", "templates", "Model_CIE_retro.jpg")

WINDOW_NAME = "Rafting Republic - Zone Calibrator"

def calibrate_template(image_path):
    print(f"Cercando immagine in: {image_path}")
    
    if not os.path.exists(image_path):
        print(f"‚ùå ERRORE: Immagine non trovata.")
        print(f"Assicurati di aver messo 'cie_front.jpg' in: {os.path.dirname(image_path)}")
        return

    # Carica immagine
    img = cv2.imread(image_path)
    if img is None:
        print("‚ùå ERRORE: OpenCV non riesce ad aprire l'immagine (formato non valido o file corrotto).")
        return

    h, w = img.shape[:2]
    print(f"\n--- CALIBRAZIONE AVVIATA ---")
    print(f"Immagine: {w}x{h}")
    print("\nISTRUZIONI:")
    print("1. Si aprir√† una finestra con l'immagine.")
    print("2. Usa il mouse per disegnare un rettangolo attorno al dato (es. Cognome).")
    print("3. Premi SPAZIO o INVIO per confermare la selezione.")
    print("4. Torna qui nella console e scrivi il nome del campo (es. 'cognome').")
    print("5. Premi 'c' per cancellare una selezione errata.")
    print("6. Premi 'q' (o Esc) sulla finestra immagine per terminare e generare il JSON.")
    print("----------------------------")

    zones = {}

    while True:
        # Usa la funzione nativa di OpenCV per selezionare ROI
        try:
            rect = cv2.selectROI(WINDOW_NAME, img, showCrosshair=True)
        except KeyboardInterrupt:
            break
        
        # rect √® una tupla (x, y, w, h)
        x, y, rw, rh = rect

        # Se l'utente preme 'q' o chiude, esce (w e h sono 0)
        if rw == 0 or rh == 0:
            print("\nFine selezione.")
            break

        print(f"\nSelezione rilevata: x={x}, y={y}, w={rw}, h={rh}")
        field_name = input("Nome campo (es. 'cognome') o 'skip' per annullare: ").strip()

        if field_name.lower() == 'skip' or not field_name:
            print("Selezione ignorata.")
            continue

        # Calcolo percentuali (4 decimali di precisione)
        p_x = round(x / w, 4)
        p_y = round(y / h, 4)
        p_w = round(rw / w, 4)
        p_h = round(rh / h, 4)

        zones[field_name] = (p_x, p_y, p_w, p_h)
        print(f"‚úÖ Campo '{field_name}' salvato in memoria.")

        # Disegna rettangolo di conferma sull'immagine (visuale)
        cv2.rectangle(img, (x, y), (x+rw, y+rh), (0, 255, 0), 2)
        cv2.putText(img, field_name, (x, y - 5), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)

    cv2.destroyAllWindows()

    if zones:
        print("\n\n=== COPIA QUESTO JSON IN local_vision_service.py ===")
        print(json.dumps(zones, indent=4))
        print("====================================================")
    else:
        print("\nNessuna zona selezionata.")

if __name__ == "__main__":
    # Se passi il file come argomento usa quello, altrimenti il default calcolato
    path = sys.argv[1] if len(sys.argv) > 1 else TEMPLATE_PATH
    calibrate_template(path)
<FILE_END>

<FILE_START path="web-app\.prettierrc.json">
{
  "$schema": "https://json.schemastore.org/prettierrc",
  "semi": false,
  "singleQuote": true,
  "printWidth": 100
}
<FILE_END>

<FILE_START path="web-app\eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import pluginVue from 'eslint-plugin-vue'
import pluginQuasar from '@quasar/app-vite/eslint'
import prettierSkipFormatting from '@vue/eslint-config-prettier/skip-formatting'

export default [
  {
    /**
     * Ignore the following files.
     * Please note that pluginQuasar.configs.recommended() already ignores
     * the "node_modules" folder for you (and all other Quasar project
     * relevant folders and files).
     *
     * ESLint requires "ignores" key to be the only one in this object
     */
    // ignores: []
  },

  ...pluginQuasar.configs.recommended(),
  js.configs.recommended,

  /**
   * https://eslint.vuejs.org
   *
   * pluginVue.configs.base
   *   -> Settings and rules to enable correct ESLint parsing.
   * pluginVue.configs[ 'flat/essential']
   *   -> base, plus rules to prevent errors or unintended behavior.
   * pluginVue.configs["flat/strongly-recommended"]
   *   -> Above, plus rules to considerably improve code readability and/or dev experience.
   * pluginVue.configs["flat/recommended"]
   *   -> Above, plus rules to enforce subjective community defaults to ensure consistency.
   */
  ...pluginVue.configs['flat/essential'],

  {
    languageOptions: {
      ecmaVersion: 'latest',
      sourceType: 'module',

      globals: {
        ...globals.browser,
        ...globals.node, // SSR, Electron, config files
        process: 'readonly', // process.env.*
        ga: 'readonly', // Google Analytics
        cordova: 'readonly',
        Capacitor: 'readonly',
        chrome: 'readonly', // BEX related
        browser: 'readonly', // BEX related
      },
    },

    // add your custom rules here
    rules: {
      'prefer-promise-reject-errors': 'off',

      // allow debugger during development only
      'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    },
  },

  {
    files: ['src-pwa/custom-service-worker.js'],
    languageOptions: {
      globals: {
        ...globals.serviceworker,
      },
    },
  },

  prettierSkipFormatting,
]
<FILE_END>

<FILE_START path="web-app\index.html">
<!doctype html>
<html>
  <head>
    <title><%= productName %></title>

    <meta charset="utf-8" />
    <meta name="description" content="<%= productDescription %>" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta
      name="viewport"
      content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width<% if (ctx.mode.cordova || ctx.mode.capacitor) { %>, viewport-fit=cover<% } %>"
    />

    <link rel="icon" type="image/png" sizes="128x128" href="icons/favicon-128x128.png" />
    <link rel="icon" type="image/png" sizes="96x96" href="icons/favicon-96x96.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png" />
    <link rel="icon" type="image/ico" href="favicon.ico" />
  </head>
  <body>
    <!-- quasar:entry-point -->
  </body>
</html>
<FILE_END>

<FILE_START path="web-app\jsconfig.json">
{
  "extends": "./.quasar/tsconfig.json"
}
<FILE_END>

<FILE_START path="web-app\package.json">
{
  "name": "web-app",
  "version": "0.0.1",
  "description": "A Quasar Project",
  "productName": "Quasar App",
  "author": "Theollotti <bellottitheo1@gmail.com>",
  "type": "module",
  "private": true,
  "scripts": {
    "lint": "eslint -c ./eslint.config.js \"./src*/**/*.{js,cjs,mjs,vue}\"",
    "format": "prettier --write \"**/*.{js,vue,scss,html,md,json}\" --ignore-path .gitignore",
    "test": "echo \"No test specified\" && exit 0",
    "dev": "quasar dev",
    "build": "quasar build",
    "postinstall": "quasar prepare"
  },
  "dependencies": {
    "axios": "^1.2.1",
    "pinia": "^3.0.1",
    "@quasar/extras": "^1.16.4",
    "quasar": "^2.16.0",
    "vue": "^3.5.22",
    "vue-router": "^4.0.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.14.0",
    "eslint": "^9.14.0",
    "eslint-plugin-vue": "^10.4.0",
    "globals": "^16.4.0",
    "vite-plugin-checker": "^0.11.0",
    "vue-eslint-parser": "^10.2.0",
    "@vue/eslint-config-prettier": "^10.1.0",
    "prettier": "^3.3.3",
    "@quasar/app-vite": "^2.1.0",
    "autoprefixer": "^10.4.2",
    "postcss": "^8.4.14"
  },
  "engines": {
    "node": "^28 || ^26 || ^24 || ^22 || ^20",
    "npm": ">= 6.13.4",
    "yarn": ">= 1.21.1"
  }
}
<FILE_END>

<FILE_START path="web-app\postcss.config.js">
// https://github.com/michael-ciniawsky/postcss-load-config

import autoprefixer from 'autoprefixer'
// import rtlcss from 'postcss-rtlcss'

export default {
  plugins: [
    // https://github.com/postcss/autoprefixer
    autoprefixer({
      overrideBrowserslist: [
        'last 4 Chrome versions',
        'last 4 Firefox versions',
        'last 4 Edge versions',
        'last 4 Safari versions',
        'last 4 Android versions',
        'last 4 ChromeAndroid versions',
        'last 4 FirefoxAndroid versions',
        'last 4 iOS versions',
      ],
    }),

    // https://github.com/elchininet/postcss-rtlcss
    // If you want to support RTL css, then
    // 1. yarn/pnpm/bun/npm install postcss-rtlcss
    // 2. optionally set quasar.config.js > framework > lang to an RTL language
    // 3. uncomment the following line (and its import statement above):
    // rtlcss()
  ],
}
<FILE_END>

<FILE_START path="web-app\quasar.config.js">
// Configuration for your app
// https://v2.quasar.dev/quasar-cli-vite/quasar-config-file

import { defineConfig } from '#q-app/wrappers'

export default defineConfig((/* ctx */) => {
  return {
    // https://v2.quasar.dev/quasar-cli-vite/prefetch-feature
    // preFetch: true,

    // app boot file (/src/boot)
    // --> boot files are part of "main.js"
    // https://v2.quasar.dev/quasar-cli-vite/boot-files
    boot: ['axios'],

    // https://v2.quasar.dev/quasar-cli-vite/quasar-config-file#css
    css: ['app.scss'],

    // https://github.com/quasarframework/quasar/tree/dev/extras
    extras: [
      // 'ionicons-v4',
      // 'mdi-v7',
      // 'fontawesome-v6',
      // 'eva-icons',
      // 'themify',
      // 'line-awesome',
      // 'roboto-font-latin-ext', // this or either 'roboto-font', NEVER both!

      'roboto-font', // optional, you are not bound to it
      'material-icons', // optional, you are not bound to it
    ],

    // Full list of options: https://v2.quasar.dev/quasar-cli-vite/quasar-config-file#build
    build: {
      target: {
        browser: ['es2022', 'firefox115', 'chrome115', 'safari14'],
        node: 'node20',
      },

      vueRouterMode: 'hash', // available values: 'hash', 'history'
      // vueRouterBase,
      // vueDevtools,
      // vueOptionsAPI: false,

      // rebuildCache: true, // rebuilds Vite/linter/etc cache on startup

      // publicPath: '/',
      // analyze: true,
      // env: {},
      // rawDefine: {}
      // ignorePublicFolder: true,
      // minify: false,
      // polyfillModulePreload: true,
      // distDir

      // extendViteConf (viteConf) {},
      // viteVuePluginOptions: {},

      vitePlugins: [
        [
          'vite-plugin-checker',
          {
            eslint: {
              lintCommand: 'eslint -c ./eslint.config.js "./src*/**/*.{js,mjs,cjs,vue}"',
              useFlatConfig: true,
            },
          },
          { server: false },
        ],
      ],
    },

    // Full list of options: https://v2.quasar.dev/quasar-cli-vite/quasar-config-file#devserver
    devServer: {
      open: true, // apre il browser in automatico
      proxy: {
        '/api': {
        target: 'http://127.0.0.1:8000', // Indirizzo del tuo Backend Python
        changeOrigin: true,
        secure: false
        }
      } 
    },

    // https://v2.quasar.dev/quasar-cli-vite/quasar-config-file#framework
    framework: {
      config: {},

      // iconSet: 'material-icons', // Quasar icon set
      // lang: 'en-US', // Quasar language pack

      // For special cases outside of where the auto-import strategy can have an impact
      // (like functional components as one of the examples),
      // you can manually specify Quasar components/directives to be available everywhere:
      //
      // components: [],
      // directives: [],

      // Quasar plugins
      plugins: [
        'Notify'
      ]
    },

    // animations: 'all', // --- includes all animations
    // https://v2.quasar.dev/options/animations
    animations: [],

    // https://v2.quasar.dev/quasar-cli-vite/quasar-config-file#sourcefiles
    // sourceFiles: {
    //   rootComponent: 'src/App.vue',
    //   router: 'src/router/index',
    //   store: 'src/store/index',
    //   pwaRegisterServiceWorker: 'src-pwa/register-service-worker',
    //   pwaServiceWorker: 'src-pwa/custom-service-worker',
    //   pwaManifestFile: 'src-pwa/manifest.json',
    //   electronMain: 'src-electron/electron-main',
    //   electronPreload: 'src-electron/electron-preload'
    //   bexManifestFile: 'src-bex/manifest.json
    // },

    // https://v2.quasar.dev/quasar-cli-vite/developing-ssr/configuring-ssr
    ssr: {
      prodPort: 3000, // The default port that the production server should use
      // (gets superseded if process.env.PORT is specified at runtime)

      middlewares: [
        'render', // keep this as last one
      ],

      // extendPackageJson (json) {},
      // extendSSRWebserverConf (esbuildConf) {},

      // manualStoreSerialization: true,
      // manualStoreSsrContextInjection: true,
      // manualStoreHydration: true,
      // manualPostHydrationTrigger: true,

      pwa: false,
      // pwaOfflineHtmlFilename: 'offline.html', // do NOT use index.html as name!

      // pwaExtendGenerateSWOptions (cfg) {},
      // pwaExtendInjectManifestOptions (cfg) {}
    },

    // https://v2.quasar.dev/quasar-cli-vite/developing-pwa/configuring-pwa
    pwa: {
      workboxMode: 'GenerateSW', // 'GenerateSW' or 'InjectManifest'
      // swFilename: 'sw.js',
      // manifestFilename: 'manifest.json',
      // extendManifestJson (json) {},
      // useCredentialsForManifestTag: true,
      // injectPwaMetaTags: false,
      // extendPWACustomSWConf (esbuildConf) {},
      // extendGenerateSWOptions (cfg) {},
      // extendInjectManifestOptions (cfg) {}
    },

    // Full list of options: https://v2.quasar.dev/quasar-cli-vite/developing-cordova-apps/configuring-cordova
    cordova: {
      // noIosLegacyBuildFlag: true, // uncomment only if you know what you are doing
    },

    // Full list of options: https://v2.quasar.dev/quasar-cli-vite/developing-capacitor-apps/configuring-capacitor
    capacitor: {
      hideSplashscreen: true,
    },

    // Full list of options: https://v2.quasar.dev/quasar-cli-vite/developing-electron-apps/configuring-electron
    electron: {
      // extendElectronMainConf (esbuildConf) {},
      // extendElectronPreloadConf (esbuildConf) {},

      // extendPackageJson (json) {},

      // Electron preload scripts (if any) from /src-electron, WITHOUT file extension
      preloadScripts: ['electron-preload'],

      // specify the debugging port to use for the Electron app when running in development mode
      inspectPort: 5858,

      bundler: 'packager', // 'packager' or 'builder'

      packager: {
        // https://github.com/electron-userland/electron-packager/blob/master/docs/api.md#options
        // OS X / Mac App Store
        // appBundleId: '',
        // appCategoryType: '',
        // osxSign: '',
        // protocol: 'myapp://path',
        // Windows only
        // win32metadata: { ... }
      },

      builder: {
        // https://www.electron.build/configuration/configuration

        appId: 'web-app',
      },
    },

    // Full list of options: https://v2.quasar.dev/quasar-cli-vite/developing-browser-extensions/configuring-bex
    bex: {
      // extendBexScriptsConf (esbuildConf) {},
      // extendBexManifestJson (json) {},

      /**
       * The list of extra scripts (js/ts) not in your bex manifest that you want to
       * compile and use in your browser extension. Maybe dynamic use them?
       *
       * Each entry in the list should be a relative filename to /src-bex/
       *
       * @example [ 'my-script.ts', 'sub-folder/my-other-script.js' ]
       */
      extraScripts: [],
    },
  }
})
<FILE_END>

<FILE_START path="web-app\README.md">
# Quasar App (web-app)

A Quasar Project

## Install the dependencies

```bash
yarn
# or
npm install
```

### Start the app in development mode (hot-code reloading, error reporting, etc.)

```bash
quasar dev
```

### Lint the files

```bash
yarn lint
# or
npm run lint
```

### Format the files

```bash
yarn format
# or
npm run format
```

### Build the app for production

```bash
quasar build
```

### Customize the configuration

See [Configuring quasar.config.js](https://v2.quasar.dev/quasar-cli-vite/quasar-config-js).
<FILE_END>

<FILE_START path="web-app\src\App.vue">
<template>
  <router-view />
</template>

<script>
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'App',
})
</script>
<FILE_END>

<FILE_START path="web-app\src\boot\axios.js">
import { boot } from 'quasar/wrappers'
import axios from 'axios'

// Creiamo un'istanza di axios con l'URL base del tuo backend Python
// Se il backend gira su una porta diversa da 8000, cambiala qui!
const api = axios.create({ baseURL: 'http://127.0.0.1:8000/api/v1' })

export default boot(({ app }) => {
  // Rende l'api disponibile globalmente nell'app (es. this.$api)
  app.config.globalProperties.$axios = axios
  app.config.globalProperties.$api = api
})

export { api }
<FILE_END>

<FILE_START path="web-app\src\components\CameraCapture.vue">
<template>
  <div class="camera-wrapper">
    <video 
      ref="video" 
      autoplay 
      playsinline 
      class="video-feed" 
      :class="{'mirrored': !isBackCamera, 'flash-effect': isFlashing}"
    ></video>
    
    <canvas ref="analysisCanvas" style="display: none;"></canvas>

    <div class="overlay-guide" :class="[docType, stateClass]">
      <div class="guide-border">
        <div class="guide-feedback transition-generic" v-if="feedbackMessage">
          <q-icon :name="feedbackIcon" size="sm" class="q-mr-xs" />
          {{ feedbackMessage }}
        </div>
      </div>
    </div>

    <div class="controls row justify-center items-center q-gutter-md">
      <q-btn round color="negative" icon="close" @click="stopCameraAndClose" />
      
      <q-btn round color="white" text-color="dark" icon="cameraswitch" @click="switchCamera" />
      
      <div class="relative-position">
        <q-circular-progress
          v-show="cameraState === 'ACQUIRING'"
          :value="acquireProgress"
          size="74px"
          thickness="0.15"
          color="green-5"
          track-color="transparent"
          class="absolute-center"
          show-value
        />
        
        <q-btn 
          round 
          :color="cameraState === 'ACQUIRING' ? 'yellow-9' : 'primary'" 
          icon="camera" 
          size="lg" 
          @click="forceCapture" 
        >
          <q-tooltip>Scatto Manuale</q-tooltip>
        </q-btn>
      </div>
    </div>

    <div v-if="showDebug" class="debug-overlay">
      <div>Blur: {{ debugMetrics.blur }} (Min: {{ THRESHOLDS.BLUR }})</div>
      <div>Bright: {{ debugMetrics.brightness }}</div>
      <div>Stable: {{ debugMetrics.stability }}</div>
      <div>State: {{ cameraState }}</div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, computed } from 'vue'
import ImageQualityService from 'src/services/ImageQualityService'

const props = defineProps({
  docType: { type: String, default: 'CIE' }
})
const emit = defineEmits(['capture', 'close'])

// --- Configurazione Soglie (Tuning Empirico) ---
// Riferimento Strategia Sez 3.1, 3.2, 3.3
const THRESHOLDS = {
  BLUR: 250,          // Sotto questo valore √® sfocata (Varianza Laplaciano)
  BRIGHT_MIN: 60,     // Troppo scura
  BRIGHT_MAX: 230,    // Troppo chiara/sovraesposta
  STABILITY: 15,      // Differenza pixel tra frame (basso = stabile)
  DWELL_TIME: 1200    // Millisecondi di stabilit√† per scattare
}

// --- Stati ---
const video = ref(null)
const analysisCanvas = ref(null)
const stream = ref(null)
const isBackCamera = ref(true)
const isFlashing = ref(false)
const showDebug = ref(false) // Mettere true per debuggare i valori

// FSM: 'SEARCHING' | 'ACQUIRING' | 'LOCKED' | 'ERROR'
const cameraState = ref('SEARCHING') 
const acquireProgress = ref(0)
const feedbackMessage = ref('Inquadra il documento')
const feedbackIcon = ref('center_focus_strong')

// Variabili Loop Analisi
let analysisInterval = null
let lastFrameGray = null
let acquiringStartTime = 0

// Metriche reattive per debug
const debugMetrics = ref({ blur: 0, brightness: 0, stability: 0 })

// --- Computed UI ---
const stateClass = computed(() => {
  if (cameraState.value === 'ACQUIRING') return 'state-acquiring'
  if (cameraState.value === 'LOCKED') return 'state-locked'
  return 'state-searching'
})

// --- Gestione Fotocamera ---

async function startCamera() {
  stopCamera()
  
  // Richiesta FullHD per OCR ottimale
  const constraints = {
    video: {
      facingMode: isBackCamera.value ? 'environment' : 'user',
      width: { ideal: 1920 },
      height: { ideal: 1080 },
      focusMode: 'continuous' // Tentativo di forzare autofocus
    }
  }
  
  try {
    stream.value = await navigator.mediaDevices.getUserMedia(constraints)
    if (video.value) {
      video.value.srcObject = stream.value
      // Attendiamo che il video sia pronto prima di partire con l'analisi
      video.value.onloadedmetadata = () => {
        video.value.play()
        startAnalysisLoop()
      }
    }
  } catch (err) {
    console.error("Errore Camera:", err)
    feedbackMessage.value = "Errore accesso fotocamera"
    cameraState.value = 'ERROR'
  }
}

function stopCamera() {
  stopAnalysisLoop()
  if (stream.value) {
    stream.value.getTracks().forEach(track => track.stop())
    stream.value = null
  }
}

function stopCameraAndClose() {
  stopCamera()
  emit('close')
}

function switchCamera() {
  isBackCamera.value = !isBackCamera.value
  startCamera()
}

// --- Core Intelligence: Il Loop di Analisi ---

function startAnalysisLoop() {
  if (analysisInterval) clearInterval(analysisInterval)
  
  // Eseguiamo l'analisi ogni 150ms (~6-7 FPS) per non uccidere la CPU
  analysisInterval = setInterval(() => {
    if (!video.value || !analysisCanvas.value || cameraState.value === 'LOCKED') return
    
    processFrame()
  }, 150)
}

function stopAnalysisLoop() {
  if (analysisInterval) clearInterval(analysisInterval)
  analysisInterval = null
}

function processFrame() {
  const vid = video.value
  const can = analysisCanvas.value
  
  // Sincronizza dimensioni (fondamentale per i calcoli)
  // Usiamo una risoluzione ridotta per l'analisi per velocit√† (downsampling)
  const analysisWidth = 480 
  const scale = analysisWidth / vid.videoWidth
  const analysisHeight = vid.videoHeight * scale
  
  can.width = analysisWidth
  can.height = analysisHeight
  
  const ctx = can.getContext('2d', { willReadFrequently: true })
  ctx.drawImage(vid, 0, 0, can.width, can.height)
  
  try {
    const imageData = ctx.getImageData(0, 0, can.width, can.height)
    
    // Invocazione Service "Pure JS"
    const result = ImageQualityService.analyzeFrame(imageData, lastFrameGray)
    
    // Aggiorna buffer per il prossimo frame (Motion Detection)
    lastFrameGray = result.grayBuffer
    
    // Aggiorna metriche per logica
    const m = result.metrics
    debugMetrics.value = m // Per UI debug
    
    evaluateQuality(m)
    
  } catch (e) {
    console.warn("Frame analysis error:", e)
  }
}

// --- Macchina a Stati Decisionale (Logic Gatekeeper) ---

function evaluateQuality(metrics) {
  const isStable = metrics.stability < THRESHOLDS.STABILITY
  const isSharp = metrics.blurScore > THRESHOLDS.BLUR
  const isBrightEnough = metrics.brightness > THRESHOLDS.BRIGHT_MIN
  const isNotTooBright = metrics.brightness < THRESHOLDS.BRIGHT_MAX
  
  // 1. Check Errori Bloccanti
  if (!isBrightEnough) {
    resetAcquisition('Troppo buio üåë', 'brightness_low')
    return
  }
  if (!isNotTooBright) {
    resetAcquisition('Troppo chiaro / Riflessi ‚òÄÔ∏è', 'brightness_high')
    return
  }
  
  // 2. Check Movimento
  if (!isStable) {
    resetAcquisition('Tieni fermo il telefono ‚úã', 'vibration')
    return
  }
  
  // 3. Check Fuoco (Solo se stabile)
  if (!isSharp) {
    resetAcquisition('Metti a fuoco (Tocca schermo) üéØ', 'blur_on')
    return
  }
  
  // 4. Tutto OK -> Transizione ACQUIRING -> LOCKED
  if (cameraState.value !== 'ACQUIRING') {
    // Entra in stato acquisizione
    cameraState.value = 'ACQUIRING'
    acquiringStartTime = Date.now()
    feedbackMessage.value = 'Non muoverti...'
    feedbackIcon.value = 'timer'
  } else {
    // Siamo gi√† in acquisizione, aggiorna progresso
    const elapsed = Date.now() - acquiringStartTime
    const progress = Math.min(100, (elapsed / THRESHOLDS.DWELL_TIME) * 100)
    acquireProgress.value = progress
    
    if (elapsed >= THRESHOLDS.DWELL_TIME) {
      // Successo! Scatto automatico
      captureImage(true)
    }
  }
}

function resetAcquisition(msg, icon) {
  if (cameraState.value === 'ACQUIRING') {
    // Interruzione durante il caricamento
    acquireProgress.value = 0
  }
  cameraState.value = 'SEARCHING'
  feedbackMessage.value = msg
  feedbackIcon.value = icon
}

// --- Cattura ---

function forceCapture() {
  // Scatto manuale (Escape Hatch)
  captureImage(false)
}

function captureImage(isAuto) {
  if (cameraState.value === 'LOCKED') return // Gi√† preso
  
  stopAnalysisLoop()
  cameraState.value = 'LOCKED'
  feedbackMessage.value = isAuto ? 'Preso! ‚úÖ' : 'Scatto Manuale üì∏'
  acquireProgress.value = 100
  
  // Effetto Flash Visivo
  isFlashing.value = true
  setTimeout(() => isFlashing.value = false, 300)
  
  // Cattura alla MASSIMA risoluzione (dal video source, non dal canvas di analisi)
  const vid = video.value
  const fullCanvas = document.createElement('canvas')
  fullCanvas.width = vid.videoWidth
  fullCanvas.height = vid.videoHeight
  
  const ctx = fullCanvas.getContext('2d')
  
  // Gestione mirroring fronte/retro
  if (!isBackCamera.value) {
    ctx.translate(fullCanvas.width, 0)
    ctx.scale(-1, 1)
  }
  
  ctx.drawImage(vid, 0, 0, fullCanvas.width, fullCanvas.height)
  
  fullCanvas.toBlob((blob) => {
    // Crea file e invia al genitore
    const file = new File([blob], `scan_${props.docType}_${Date.now()}.jpg`, { type: "image/jpeg" })
    
    // Piccolo delay per far vedere l'animazione di successo
    setTimeout(() => {
      emit('capture', file)
      stopCamera() // Importante: rilascia risorse
    }, 500)
    
  }, 'image/jpeg', 0.95) // Max qualit√† per backend OCR
}

onMounted(() => {
  startCamera()
})

onUnmounted(() => {
  stopCamera()
})
</script>

<style scoped>
.camera-wrapper {
  position: relative;
  width: 100%;
  height: 60vh; /* Responsive height */
  min-height: 400px;
  background: #000;
  overflow: hidden;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
}

.video-feed {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: opacity 0.1s;
}

.mirrored {
  transform: scaleX(-1);
}

.flash-effect {
  opacity: 0.2;
  filter: brightness(10);
}

/* OVERLAY GUIDE & STATES */
.overlay-guide {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none; /* Lascia passare i click */
  transition: all 0.3s ease;
}

.guide-border {
  border: 3px solid rgba(255, 255, 255, 0.6); /* Default Searching */
  box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6); /* Darken outside */
  border-radius: 16px;
  position: relative;
  transition: border-color 0.3s ease, transform 0.2s ease;
}

/* State Colors */
.state-searching .guide-border { border-color: rgba(255, 255, 255, 0.8); }
.state-acquiring .guide-border { border-color: #fdd835; /* Yellow */ transform: scale(1.02); }
.state-locked .guide-border { border-color: #21ba45; /* Green */ box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.8); }

/* Feedback Text pill */
.guide-feedback {
  position: absolute;
  bottom: -50px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 6px 12px;
  border-radius: 20px;
  white-space: nowrap;
  font-weight: 500;
  font-size: 0.95rem;
  display: flex;
  align-items: center;
}

/* Aspect Ratios per Doc Type */
.CIE .guide-border, .PATENTE_IT .guide-border, .CI_CARTACEA .guide-border, .PERMESSO_SOGGIORNO .guide-border {
  width: 85%;
  aspect-ratio: 85.6 / 53.98; 
  max-width: 500px;
}
.PASSAPORTO .guide-border {
  width: 80%;
  aspect-ratio: 125 / 88; /* Passaporto aperto */
  max-width: 500px;
}

.controls {
  position: absolute;
  bottom: 30px;
  width: 100%;
  z-index: 10;
  pointer-events: auto;
}

.debug-overlay {
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0,0,0,0.5);
  color: lime;
  font-family: monospace;
  font-size: 10px;
  padding: 4px;
  pointer-events: none;
}

/* Transition Utility */
.transition-generic { transition: all 0.3s ease; }
</style>
<FILE_END>

<FILE_START path="web-app\src\components\ModuleCard.vue">
<template>
  <q-card class="cursor-pointer q-hoverable transition-generic" v-ripple @click="$emit('click')">
    <q-card-section class="flex flex-center column q-py-lg">
      <div
        class="flex flex-center q-mb-md"
        :style="`background-color: ${hexToRgba(color, 0.1)}; width: 60px; height: 60px; border-radius: 50%;`"
      >
        <q-icon :name="icon" size="30px" :style="`color: ${color}`" />
      </div>

      <div class="text-subtitle1 text-weight-bold">{{ title }}</div>
      <div v-if="caption" class="text-caption text-grey-7 q-mt-xs text-center">
        {{ caption }}
      </div>
    </q-card-section>
  </q-card>
</template>

<script setup>
defineProps({
  title: { type: String, required: true },
  icon: { type: String, required: true },
  color: { type: String, default: '#1976D2' },
  caption: { type: String, default: '' }
})

defineEmits(['click'])

function hexToRgba (hex, alpha) {
  if (!hex || typeof hex !== 'string' || !hex.startsWith('#') || hex.length !== 7) {
    return `rgba(0, 0, 0, ${alpha})`
  }
  const r = parseInt(hex.slice(1, 3), 16)
  const g = parseInt(hex.slice(3, 5), 16)
  const b = parseInt(hex.slice(5, 7), 16)
  return `rgba(${r}, ${g}, ${b}, ${alpha})`
}
</script>

<style scoped>
.transition-generic { transition: transform 0.2s; }
.transition-generic:hover { transform: translateY(-5px); }
</style>
<FILE_END>

<FILE_START path="web-app\src\components\scanner\PersonForm.vue">
<template>
  <div class="row q-col-gutter-sm">
    <div class="col-12 col-md-6">
      <q-input :model-value="modelValue.nome" v-on:update:model-value="v => update('nome', v)" label="Nome *" outlined dense :readonly="readonly" :rules="[val => !!val || 'Obbligatorio']" />
    </div>
    <div class="col-12 col-md-6">
      <q-input :model-value="modelValue.cognome" v-on:update:model-value="v => update('cognome', v)" label="Cognome *" outlined dense :readonly="readonly" :rules="[val => !!val || 'Obbligatorio']" />
    </div>
    
    <div class="col-12 col-md-4">
      <q-input 
        :model-value="modelValue.data_nascita" 
        v-on:update:model-value="v => update('data_nascita', v)"
        label="Data di Nascita *" 
        outlined dense :readonly="readonly"
        mask="##/##/####"
        :rules="[val => /^\d{2}\/\d{2}\/\d{4}$/.test(val) || 'Formato errato (GG/MM/AAAA)']"
      >
        <template v-slot:append v-if="!readonly">
          <q-icon name="event" class="cursor-pointer">
            <q-popup-proxy cover transition-show="scale" transition-hide="scale">
              <q-date :model-value="modelValue.data_nascita" v-on:update:model-value="v => update('data_nascita', v)" mask="DD/MM/YYYY" />
            </q-popup-proxy>
          </q-icon>
        </template>
      </q-input>
    </div>
    
    <div class="col-12 col-md-2">
      <q-input :model-value="age" label="Et√†" outlined dense readonly bg-color="grey-2" />
    </div>

    <div class="col-12 col-md-6">
      <q-select 
        :model-value="modelValue.stato_nascita" 
        v-on:update:model-value="v => update('stato_nascita', v)"
        :options="countries" 
        label="Stato di Nascita *" 
        outlined dense :readonly="readonly"
      />
    </div>
    
    <div v-if="modelValue.stato_nascita === 'ITALIA'" class="col-12 col-md-6">
      <q-input :model-value="modelValue.comune_nascita" v-on:update:model-value="v => update('comune_nascita', v)" label="Comune di Nascita *" outlined dense :readonly="readonly" />
    </div>

    <div class="col-12 col-md-6">
      <q-select :model-value="modelValue.stato_residenza" v-on:update:model-value="v => update('stato_residenza', v)" :options="countries" label="Stato Residenza *" outlined dense :readonly="readonly" />
    </div>
    
    <div v-if="modelValue.stato_residenza === 'ITALIA'" class="col-12 col-md-6">
      <q-input :model-value="modelValue.comune_residenza" v-on:update:model-value="v => update('comune_residenza', v)" label="Comune Residenza *" outlined dense :readonly="readonly" />
    </div>

    <div v-if="modelValue.stato_residenza === 'ITALIA'" class="col-12">
      <q-input 
        :model-value="modelValue.codice_fiscale" 
        v-on:update:model-value="v => update('codice_fiscale', v.toUpperCase())"
        label="Codice Fiscale *" 
        outlined dense :readonly="readonly"
        mask="AAAAAA##A##A###A"
        :rules="[val => val.length === 16 || 'CF deve essere 16 caratteri']"
      />
    </div>

    <div class="col-12 col-md-6">
      <q-input 
        :model-value="modelValue.numero_documento" 
        v-on:update:model-value="v => update('numero_documento', v)"
        label="Numero Documento *" 
        outlined dense :readonly="readonly" 
        :rules="[val => !!val && val.length >= 2 || 'Minimo 2 caratteri']"
      />
    </div>
    <div class="col-12 col-md-6">
      <q-input 
        :model-value="modelValue.scadenza_documento" 
        v-on:update:model-value="v => update('scadenza_documento', v)"
        label="Scadenza *" 
        outlined dense :readonly="readonly"
        mask="##/##/####"
        :rules="[val => /^\d{2}\/\d{2}\/\d{4}$/.test(val) || 'Formato errato (GG/MM/AAAA)']"
      >
        <template v-slot:append v-if="!readonly">
          <q-icon name="event" class="cursor-pointer">
            <q-popup-proxy cover transition-show="scale" transition-hide="scale">
              <q-date :model-value="modelValue.scadenza_documento" v-on:update:model-value="v => update('scadenza_documento', v)" mask="DD/MM/YYYY" />
            </q-popup-proxy>
          </q-icon>
        </template>
      </q-input>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'

const props = defineProps(['modelValue', 'isAdult', 'readonly'])
const emit = defineEmits(['update:modelValue'])

const countries = ['ITALIA', 'FRANCIA', 'GERMANIA', 'SVIZZERA', 'REGNO UNITO', 'SPAGNA', 'USA', 'ALTRO']

const age = computed(() => {
  const d = props.modelValue
  if (!d.data_nascita || d.data_nascita.length !== 10) return '-'
  const parts = d.data_nascita.split('/')
  if(parts.length !== 3) return '-'
  const birth = new Date(parts[2], parts[1]-1, parts[0])
  const now = new Date()
  let a = now.getFullYear() - birth.getFullYear()
  const m = now.getMonth() - birth.getMonth()
  if (m < 0 || (m === 0 && now.getDate() < birth.getDate())) a--
  return a
})

function update(field, value) {
  emit('update:modelValue', { ...props.modelValue, [field]: value })
}
</script>
<FILE_END>

<FILE_START path="web-app\src\components\scanner\SignaturePad.vue">
<template>
  <div class="signature-wrapper">
    <canvas ref="canvasRef" class="sig-canvas"></canvas>
    <div class="row justify-end q-pa-xs">
      <q-btn icon="refresh" size="sm" flat label="Pulisci" @click="clear" />
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, defineExpose, defineEmits } from 'vue'

const emit = defineEmits(['update:modelValue'])
const canvasRef = ref(null)
let ctx = null
let drawing = false

onMounted(() => {
  const c = canvasRef.value
  if(!c) return
  
  // Setup Canvas
  c.width = c.parentElement.clientWidth
  c.height = 150
  ctx = c.getContext('2d')
  ctx.lineWidth = 2
  ctx.strokeStyle = '#000'
  
  // Event Listeners
  const start = (e) => { drawing = true; ctx.beginPath(); const {x,y} = pos(e); ctx.moveTo(x,y); }
  const move = (e) => { 
    if(!drawing) return; 
    const {x,y} = pos(e); 
    ctx.lineTo(x,y); 
    ctx.stroke(); 
  }
  const end = () => { 
    drawing = false; 
    emit('update:modelValue', getImage()) // Emit auto-update
  }
  
  const pos = (e) => {
    const r = c.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: clientX - r.left, y: clientY - r.top }
  }

  c.addEventListener('mousedown', start);
  c.addEventListener('mousemove', move); 
  c.addEventListener('mouseup', end);
  
  // Touch events (passive: false per prevenire lo scroll mentre si firma)
  c.addEventListener('touchstart', start, {passive: false}); 
  c.addEventListener('touchmove', move, {passive: false}); 
  c.addEventListener('touchend', end);
})

const clear = () => {
  if (!ctx || !canvasRef.value) return
  ctx.clearRect(0,0, canvasRef.value.width, canvasRef.value.height)
  emit('update:modelValue', null)
}

const getImage = () => canvasRef.value.toDataURL('image/png')
const isEmpty = () => false 

defineExpose({ clear, getImage, isEmpty })
</script>

<style scoped>
.signature-wrapper {
  border: 1px dashed #ccc; 
  background: white;
  border-radius: 4px;
}
.sig-canvas {
  width: 100%; 
  height: 150px; 
  touch-action: none; /* Fondamentale per mobile */
  cursor: crosshair;
}
</style>
<FILE_END>

<FILE_START path="web-app\src\components\scanner\steps\StepDocuments.vue">
<template>
  <div class="col-12 col-md-8">
    
    <!-- MODE SELECTOR -->
    <div v-if="!store.isEditMode" class="q-mb-lg">
      <div class="text-subtitle1 text-center q-mb-sm text-grey-8">Come vuoi inserire i dati?</div>
      <div class="row q-col-gutter-sm justify-center">
        <div class="col-12 col-sm-6">
          <div 
            class="selection-card cursor-pointer q-pa-sm transition-generic"
            :class="!store.isManualMode ? 'active-mode shadow-2' : 'inactive-mode'"
            v-on:click="store.setInputMode('SCAN')"
            v-ripple
          >
            <div class="row items-center no-wrap">
              <div class="col-auto q-mr-md">
                <q-avatar color="blue-1" text-color="primary" icon="document_scanner" size="md" font-size="20px"/>
              </div>
              <div class="col">
                <div class="text-weight-bold text-primary">{{ t.docs.mode_scan_title }}</div>
                <div class="text-caption text-grey-7">{{ t.docs.mode_scan_desc }}</div>
              </div>
              <div class="col-auto">
                <q-radio :model-value="store.inputMode" v-on:update:model-value="val => store.inputMode = val" val="SCAN" dense color="primary" class="no-pointer-events" />
              </div>
            </div>
            <div v-if="!store.isManualMode" class="floating-badge bg-green text-white">Consigliato</div>
          </div>
        </div>

        <div class="col-12 col-sm-6">
          <div 
            class="selection-card cursor-pointer q-pa-sm transition-generic"
            :class="store.isManualMode ? 'active-mode-manual shadow-2' : 'inactive-mode'"
            v-on:click="store.setInputMode('MANUAL')"
            v-ripple
          >
            <div class="row items-center no-wrap">
              <div class="col-auto q-mr-md">
                <q-avatar :color="store.isManualMode ? 'orange-1' : 'grey-2'" :text-color="store.isManualMode ? 'orange-9' : 'grey-6'" icon="edit_note" size="md" font-size="20px"/>
              </div>
              <div class="col">
                <div class="text-weight-bold" :class="store.isManualMode ? 'text-orange-9' : 'text-grey-8'">{{ t.docs.mode_manual_title }}</div>
                <div class="text-caption text-grey-7">{{ t.docs.mode_manual_desc }}</div>
              </div>
              <div class="col-auto">
                <q-radio :model-value="store.inputMode" v-on:update:model-value="val => store.inputMode = val" val="MANUAL" dense color="orange" class="no-pointer-events" />
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- GUARDIAN CARD -->
    <q-card bordered class="q-mb-md">
      <q-card-section class="bg-grey-2">
        <div class="text-weight-bold text-subtitle1">{{ adultCardTitle }}</div>
        <div class="text-caption text-grey-7">{{ t.docs.guardian_card_desc }}</div>
      </q-card-section>
      <q-card-section>
        <div v-if="!store.isManualMode">
          <q-select
            v-model="store.guardian.ocrData.tipo_documento"
            :options="docTypes"
            :label="t.docs.type_doc"
            outlined dense class="q-mb-md" emit-value map-options
            :readonly="store.isEditMode"
          />
          
          <div v-if="!store.isEditMode">
            <!-- Front -->
            <div class="row q-col-gutter-sm items-center q-mb-sm">
              <div class="col">
                <q-file outlined dense v-model="store.guardian.frontFile" :label="t.docs.scan_front" accept="image/*" @update:model-value="store.startGuardianScan()">
                  <template v-slot:prepend><q-icon name="image" /></template>
                </q-file>
              </div>
              <div class="col-auto">
                <q-btn round color="primary" icon="photo_camera" v-on:click="$emit('open-camera', { target: 'guardian', side: 'FRONT' })">
                  <q-tooltip>Fotocamera</q-tooltip>
                </q-btn>
              </div>
            </div>
            <!-- Back -->
            <div class="row q-col-gutter-sm items-center">
              <div class="col">
                <q-file outlined dense v-model="store.guardian.backFile" :label="t.docs.scan_back" accept="image/*" @update:model-value="store.startGuardianScan()">
                  <template v-slot:prepend><q-icon name="flip" /></template>
                </q-file>
              </div>
              <div class="col-auto">
                <q-btn round color="primary" icon="photo_camera" v-on:click="$emit('open-camera', { target: 'guardian', side: 'BACK' })">
                  <q-tooltip>Fotocamera</q-tooltip>
                </q-btn>
              </div>
            </div>
          </div>
          <div v-else class="text-caption text-grey-6">* Scansioni non modificabili</div>

          <!-- DEBUG -->
          <div v-if="store.guardian.ocrData.debug" class="q-mt-md">
            <q-expansion-item dense icon="bug_report" :label="t.docs.debug_ai" header-class="text-white bg-grey-8">
              <q-card class="bg-grey-2">
                <q-card-section>
                  <div class="q-mt-sm text-caption">Source: <q-badge color="purple">{{ store.guardian.ocrData.source }}</q-badge></div>
                  <div v-if="store.guardian.ocrData.warning_mismatch" class="q-mt-sm text-red text-weight-bold">
                     ‚ö†Ô∏è MISMATCH: Tipo documento rilevato diverso da quello dichiarato!
                  </div>
                </q-card-section>
              </q-card>
            </q-expansion-item>
          </div>
        </div>
        <div v-else class="text-center text-grey-6 q-pa-md bg-grey-1 rounded-borders">
          <q-icon name="edit_note" size="md" color="grey-5" />
          <div class="text-caption q-mt-xs">Inserimento manuale attivo.</div>
        </div>
      </q-card-section>
    </q-card>

    <!-- MINORS -->
    <div class="q-my-lg">
      <q-toggle 
        v-if="!store.isEditMode" 
        v-model="store.hasMinors" 
        :label="t.docs.minor_toggle" 
        size="lg"
        class="text-weight-medium"
      />

      <q-slide-transition>
        <div v-if="store.hasMinors" class="bg-orange-1 q-pa-md rounded-borders q-mt-sm border-orange">
          <div class="row items-center justify-between q-mb-md">
            <div class="text-h6 text-orange-9"><q-icon name="child_care" /> {{ t.docs.minor_area }}</div>
            <q-toggle 
              v-if="!store.isEditMode" 
              v-model="store.tutorParticipates" 
              :label="t.docs.tutor_participates" 
              color="green" dense
            />
          </div>

          <div v-for="(minor, index) in store.minors" :key="minor.id" class="q-mb-md">
            <q-card bordered class="bg-white">
              <q-card-section class="row justify-between bg-grey-1 items-center q-py-sm">
                <div class="text-weight-bold text-primary">Minore #{{ index + 1 }}</div>
                <q-btn v-if="!store.isEditMode" flat round color="negative" icon="delete" size="sm" v-on:click="store.removeMinor(index)" />
              </q-card-section>
              <q-separator />
              <q-card-section>
                <div v-if="!store.isManualMode">
                  <q-select
                    v-model="minor.ocrData.tipo_documento"
                    :options="docTypes"
                    :label="t.docs.type_doc"
                    outlined dense class="q-mb-md" emit-value map-options
                    :readonly="store.isEditMode"
                  />
                  <div v-if="!store.isEditMode">
                    <div class="row q-col-gutter-sm items-center q-mb-sm">
                      <div class="col">
                        <q-file outlined dense v-model="minor.frontFile" :label="t.docs.scan_front" accept="image/*" @update:model-value="store.startMinorScan(index)">
                          <template v-slot:prepend><q-icon name="image" /></template>
                        </q-file>
                      </div>
                      <div class="col-auto">
                        <q-btn round color="primary" icon="photo_camera" v-on:click="$emit('open-camera', { target: 'minor', side: 'FRONT', index })">
                          <q-tooltip>Fotocamera</q-tooltip>
                        </q-btn>
                      </div>
                    </div>
                    <!-- Retro Minore -->
                    <div class="row q-col-gutter-sm items-center">
                      <div class="col">
                        <q-file outlined dense v-model="minor.backFile" :label="t.docs.scan_back" accept="image/*" @update:model-value="store.startMinorScan(index)">
                          <template v-slot:prepend><q-icon name="flip" /></template>
                        </q-file>
                      </div>
                      <div class="col-auto">
                        <q-btn round color="primary" icon="photo_camera" v-on:click="$emit('open-camera', { target: 'minor', side: 'BACK', index })">
                          <q-tooltip>Fotocamera</q-tooltip>
                        </q-btn>
                      </div>
                    </div>
                  </div>
                </div>
                <div v-else class="text-center text-grey-6 q-pa-sm">Manuale attivo</div>
              </q-card-section>
            </q-card>
          </div>
          
          <q-btn 
            v-if="!store.isEditMode" 
            outline color="primary" icon="add" :label="t.docs.add_minor" 
            class="full-width bg-white"
            v-on:click="store.addMinor()" :disable="store.minors.length >= 5"
          />
        </div>
      </q-slide-transition>
    </div>

    <!-- NAVIGATION -->
    <div class="row justify-end q-mt-xl q-gutter-sm">
      <q-btn flat :label="t.nav.back" v-on:click="$emit('prev')" />
      <q-btn color="primary" :label="t.nav.continue" v-on:click="checkAndProceed" />
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useRegistrationStore } from 'stores/registration-store'
import { translations } from 'src/constants/translations' // Named Import Corretto
import { useQuasar } from 'quasar'

const emit = defineEmits(['next', 'prev', 'open-camera'])
const store = useRegistrationStore()
const $q = useQuasar()

// Localization helper
const t = computed(() => translations[store.language] || translations.it)

const adultCardTitle = computed(() => 
  store.hasMinors ? 
  (store.tutorParticipates ? 'Tutore (Partecipante)' : 'Tutore (Non partecipante)') : 
  'Partecipante'
)

const docTypes = [
  {label: 'Carta Identit√† Elettronica (CIE)', value: 'CIE'},
  {label: 'Carta Identit√† Cartacea', value: 'CI_CARTACEA'},
  {label: 'Passaporto', value: 'PASSAPORTO'},
  {label: 'Patente di Guida', value: 'PATENTE_IT'},
  {label: 'Permesso di Soggiorno', value: 'PERMESSO_SOGGIORNO'},
  {label: 'Altro Documento', value: 'ALTRO'}
]

function checkAndProceed() {
  if(!store.isManualMode && !store.isEditMode && !store.guardian.frontFile) { 
    $q.notify({type:'warning', message: 'Fronte documento obbligatorio'})
    return 
  }
  emit('next')
}
</script>

<style scoped>
.selection-card {
  border-radius: 8px;
  border: 1px solid #ddd;
  position: relative;
  background: white;
}
.selection-card:hover { border-color: #bbb; }
.active-mode { border: 2px solid var(--q-primary); background: #e3f2fd; }
.active-mode-manual { border: 2px solid var(--q-warning); background: #fff3e0; }
.inactive-mode { opacity: 0.8; }
.floating-badge {
  position: absolute; top: -8px; right: -8px;
  font-size: 10px; padding: 2px 6px; border-radius: 4px; font-weight: bold;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
.border-orange { border: 1px solid var(--q-warning); }
.transition-generic { transition: all 0.2s ease-in-out; }
</style>
<FILE_END>

<FILE_START path="web-app\src\components\scanner\steps\StepReview.vue">
<template>
  <div class="row q-col-gutter-lg">
    <div class="col-12" v-if="store.isEditMode">
      <q-banner class="bg-warning text-dark q-mb-md">
        <q-icon name="lock" /> <strong>{{ t.review.edit_warning }}</strong>
      </q-banner>
    </div>

    <!-- ADULT / GUARDIAN -->
    <div class="col-12" v-if="store.tutorParticipates || !store.hasMinors">
      <q-card bordered class="shadow-1">
        <q-card-section class="bg-primary text-white">
          <div class="text-h6">{{ store.hasMinors ? 'Tutore' : 'Partecipante' }}</div>
        </q-card-section>
        <q-card-section>
          <PersonForm 
            v-model="store.guardian.ocrData" 
            :is-adult="true"
            :readonly="store.isEditMode"
          />
        </q-card-section>
      </q-card>
    </div>

    <!-- MINORS -->
    <div v-if="store.hasMinors" class="col-12">
      <div v-for="(minor, idx) in store.minors" :key="minor.id" class="q-mb-md">
        <q-card bordered class="shadow-1">
          <q-card-section class="bg-secondary text-white">
            <div class="text-h6">Minore #{{ idx + 1 }}</div>
          </q-card-section>
          <q-card-section>
             <PersonForm 
              v-model="minor.ocrData" 
              :is-adult="false"
              :readonly="store.isEditMode"
            />
            <div class="q-mt-md">
              <div class="text-subtitle2 q-mb-sm">{{ t.review.minor_sig_title }} #{{ idx + 1 }}</div>
              <SignaturePad v-model="minor.ocrData.signature" />
            </div>
          </q-card-section>
        </q-card>
      </div>
    </div>

    <!-- MAIN SIGNATURE -->
    <div class="col-12" v-if="store.tutorParticipates || !store.hasMinors">
      <q-card bordered class="bg-grey-1">
        <q-card-section>
          <div class="text-subtitle1 text-weight-bold">{{ t.review.main_sig_title }}</div>
          <div class="text-caption text-grey-7 q-mb-sm">{{ t.review.main_sig_desc }}</div>
          <SignaturePad v-model="store.guardian.ocrData.signature" />
        </q-card-section>
      </q-card>
    </div>

    <div class="col-12 row justify-between q-mt-lg">
      <q-btn flat :label="t.nav.back" v-on:click="$emit('prev')" />
      <q-btn color="primary" label="Vai al Riepilogo" v-on:click="$emit('next')" />
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useRegistrationStore } from 'stores/registration-store'
import { translations } from 'src/constants/translations' // Named Import Corretto
import PersonForm from '../PersonForm.vue'
import SignaturePad from '../SignaturePad.vue'

defineEmits(['next', 'prev'])

const store = useRegistrationStore()
const t = computed(() => translations[store.language] || translations.it)
</script>
<FILE_END>

<FILE_START path="web-app\src\constants\legal.js">
export const LEGAL_TEXTS = {
  privacy: `INFORMATIVA SUL TRATTAMENTO DEI DATI PERSONALI (Art. 13 GDPR 679/2016)

1. Finalit√† del trattamento:
I dati raccolti (anagrafici, documenti d'identit√†) saranno utilizzati esclusivamente per:
- L'iscrizione all'attivit√† sportiva e la relativa copertura assicurativa (Tesseramento).
- Adempimenti amministrativi, fiscali e contabili obbligatori per legge.
- Gestione delle emergenze e della sicurezza durante l'attivit√†.

2. Modalit√† di trattamento:
Il trattamento sar√† svolto in forma automatizzata e/o manuale, nel rispetto di quanto previsto dall‚Äôart. 32 del GDPR 2016/679 in materia di misure di sicurezza.

3. Comunicazione dei dati:
I dati potranno essere comunicati a enti assicurativi e federazioni sportive nazionali per il tesseramento obbligatorio. Non saranno diffusi a terzi per scopi di marketing senza esplicito consenso separato.

4. Diritti dell'interessato:
In ogni momento, Lei potr√† esercitare, ai sensi degli articoli dal 15 al 22 del Regolamento UE n. 2016/679, il diritto di accesso, rettifica, cancellazione dei dati.`,

  informed: `CONSENSO INFORMATO E DICHIARAZIONE DI RESPONSABILIT√Ä

Il sottoscritto, consapevole che l'attivit√† di rafting/sport fluviale comporta rischi intrinseci legati all'ambiente naturale, DICHIARA:

1. Idoneit√† Fisica:
Di essere in buono stato di salute, di non essere affetto da patologie che possano pregiudicare la sicurezza propria o altrui durante l'attivit√†, e di Saper Nuotare.

2. Stato Psicofisico:
Di non aver assunto sostanze stupefacenti, alcol o farmaci che possano alterare i riflessi o la percezione del rischio prima dell'attivit√†.

3. Rispetto delle Regole:
Di impegnarsi a seguire scrupolosamente tutte le indicazioni fornite dalle guide e dal personale tecnico, e di indossare correttamente l'attrezzatura di sicurezza (casco, salvagente) per tutta la durata dell'attivit√†.

4. Esonero di Responsabilit√†:
Di sollevare l'organizzazione da ogni responsabilit√† per danni a persone o cose causati dalla propria negligenza, imprudenza o mancato rispetto delle istruzioni impartite.`,
}
<FILE_END>

<FILE_START path="web-app\src\constants\translations.js">
export const translations = {
  it: {
    nav: {
      back: 'Indietro',
      continue: 'Continua',
      confirm: 'Conferma e Invia',
      confirm_edit: 'Conferma Modifiche'
    },
    steps: {
      lang: 'Lingua',
      docs: 'Documenti',
      contact: 'Contatti',
      privacy: 'Privacy',
      review: 'Verifica & Firma',
      summary: 'Riepilogo'
    },
    docs: {
      title: 'Documenti',
      mode_scan_title: 'Scanner Smart',
      mode_scan_desc: 'Compilazione automatica',
      mode_manual_title: 'Manuale',
      mode_manual_desc: 'Scrivi i dati a mano',
      guardian_card_title: 'Partecipante / Tutore',
      guardian_card_desc: 'Dati del maggiorenne responsabile',
      minor_toggle: 'Ci sono minori da registrare?',
      minor_area: 'Area Minori',
      tutor_participates: 'Il tutore partecipa all\'attivit√†?',
      add_minor: 'Aggiungi un altro minore',
      scan_front: 'Fronte (Obbligatorio)',
      scan_back: 'Retro (Opzionale)',
      debug_ai: 'Debug AI & OCR',
      type_doc: 'Tipo Documento *'
    },
    privacy: {
      already_accepted: 'Gi√† accettata in precedenza.',
      read_and_accept: 'Ho letto, capito e acconsento',
      photo_consent_text: 'Autorizzi Rafting Republic a scattare e utilizzare foto/video durante l\'attivit√† per scopi promozionali?',
      newsletter_text: 'Vuoi ricevere aggiornamenti, sconti e novit√† via email?',
      warn_photo: 'ATTENZIONE: Negando il consenso, Rafting Republic non utilizzer√† la tua immagine per scopi promozionali. Tieni presente che in foto di gruppo generali potresti comunque comparire incidentalmente.'
    },
    review: {
      edit_warning: 'Modalit√† Modifica: I dati anagrafici sono bloccati. √à richiesta una nuova firma.',
      main_sig_title: 'Firma Principale',
      main_sig_desc: 'Firma qui sotto per confermare i dati.',
      minor_sig_title: 'Firma per il minore',
      clear: 'Pulisci'
    }
  },
  en: {
    nav: {
      back: 'Back',
      continue: 'Continue',
      confirm: 'Confirm & Submit',
      confirm_edit: 'Confirm Changes'
    },
    steps: {
      lang: 'Language',
      docs: 'Documents',
      contact: 'Contact',
      privacy: 'Privacy',
      review: 'Check & Sign',
      summary: 'Summary'
    },
    docs: {
      title: 'Documents',
      mode_scan_title: 'Smart Scanner',
      mode_scan_desc: 'Automatic fill',
      mode_manual_title: 'Manual',
      mode_manual_desc: 'Type data manually',
      guardian_card_title: 'Participant / Guardian',
      guardian_card_desc: 'Responsible adult data',
      minor_toggle: 'Are there minors to register?',
      minor_area: 'Minors Area',
      tutor_participates: 'Does the guardian participate?',
      add_minor: 'Add another minor',
      scan_front: 'Front (Required)',
      scan_back: 'Back (Optional)',
      debug_ai: 'AI & OCR Debug',
      type_doc: 'Document Type *'
    },
    privacy: {
      already_accepted: 'Already accepted previously.',
      read_and_accept: 'I have read, understood and agree',
      photo_consent_text: 'Do you authorize Rafting Republic to take and use photos/videos during the activity for promotional purposes?',
      newsletter_text: 'Do you want to receive updates, discounts, and news via email?',
      warn_photo: 'WARNING: By denying consent, Rafting Republic will not use your image for promotional purposes. Note that you may still appear incidentally in general group photos.'
    },
    review: {
      edit_warning: 'Edit Mode: Personal data is locked. A new signature is required.',
      main_sig_title: 'Main Signature',
      main_sig_desc: 'Sign below to confirm data.',
      minor_sig_title: 'Signature for minor',
      clear: 'Clear'
    }
  }
}
<FILE_END>

<FILE_START path="web-app\src\css\app.scss">
// app global css in SCSS form
<FILE_END>

<FILE_START path="web-app\src\css\quasar.variables.scss">
// Quasar SCSS (& Sass) Variables
// --------------------------------------------------
// To customize the look and feel of this app, you can override
// the Sass/SCSS variables found in Quasar's source Sass/SCSS files.

// Check documentation for full list of Quasar variables

// Your own variables (that are declared here) and Quasar's own
// ones will be available out of the box in your .vue/.scss/.sass files

// It's highly recommended to change the default colors
// to match your app's branding.
// Tip: Use the "Theme Builder" on Quasar's documentation website.

$primary: #1976d2;
$secondary: #26a69a;
$accent: #9c27b0;

$dark: #1d1d1d;
$dark-page: #121212;

$positive: #21ba45;
$negative: #c10015;
$info: #31ccec;
$warning: #f2c037;
<FILE_END>

<FILE_START path="web-app\src\layouts\MainLayout.vue">
<template>
  <q-layout view="lHh Lpr lFf">
    <q-header elevated>
      <q-toolbar>
        <q-btn flat dense round icon="menu" aria-label="Menu" @click="toggleLeftDrawer" />
        <q-toolbar-title>Rafting Republic ‚Ä¢ Gestionale</q-toolbar-title>
        <div class="text-caption">Quasar v{{ $q.version }}</div>
      </q-toolbar>
    </q-header>

    <q-drawer v-model="leftDrawerOpen" show-if-above bordered>
      <q-list padding>
        <q-item-label header>Menu</q-item-label>

        <q-item clickable v-ripple to="/">
          <q-item-section avatar><q-icon name="dashboard" /></q-item-section>
          <q-item-section>Dashboard</q-item-section>
        </q-item>

        <q-item clickable v-ripple to="/scanner">
          <q-item-section avatar><q-icon name="document_scanner" /></q-item-section>
          <q-item-section>Nuova registrazione</q-item-section>
        </q-item>

        <q-item clickable v-ripple to="/registrazioni">
          <q-item-section avatar><q-icon name="assignment" /></q-item-section>
          <q-item-section>Registrazioni</q-item-section>
        </q-item>
      </q-list>
    </q-drawer>

    <q-page-container>
      <router-view />
    </q-page-container>
  </q-layout>
</template>

<script>
import { defineComponent, ref } from 'vue'

export default defineComponent({
  name: 'MainLayout',
  setup () {
    const leftDrawerOpen = ref(false)
    const toggleLeftDrawer = () => { leftDrawerOpen.value = !leftDrawerOpen.value }
    return { leftDrawerOpen, toggleLeftDrawer }
  }
})
</script>
<FILE_END>

<FILE_START path="web-app\src\pages\DashboardPage.vue">
<template>
  <q-page class="q-pa-md bg-grey-1">
    <div class="q-mb-xl q-mt-md">
      <div class="text-h4 text-weight-bold text-dark">Ciao! üëã</div>
      <div class="text-subtitle1 text-grey-7 q-mt-sm">
        Scegli cosa vuoi fare.
      </div>
    </div>

    <div class="row q-col-gutter-md">
      <div class="col-12 col-sm-6 col-md-4">
        <ModuleCard
          title="Nuova registrazione"
          caption="Scanner documenti + firma"
          icon="document_scanner"
          color="#1976D2"
          @click="go('/scanner')"
        />
      </div>

      <div class="col-12 col-sm-6 col-md-4">
        <ModuleCard
          title="Registrazioni"
          caption="Archivio PDF + lock"
          icon="assignment"
          color="#2E7D32"
          @click="go('/registrazioni')"
        />
      </div>
    </div>
  </q-page>
</template>

<script setup>
import ModuleCard from 'components/ModuleCard.vue'
import { useRouter } from 'vue-router'

const router = useRouter()
function go (path) { router.push(path) }
</script>
<FILE_END>

<FILE_START path="web-app\src\pages\ErrorNotFound.vue">
<template>
  <div class="fullscreen bg-blue text-white text-center q-pa-md flex flex-center">
    <div>
      <div style="font-size: 30vh">404</div>

      <div class="text-h2" style="opacity: 0.4">Oops. Nothing here...</div>

      <q-btn
        class="q-mt-xl"
        color="white"
        text-color="blue"
        unelevated
        to="/"
        label="Go Home"
        no-caps
      />
    </div>
  </div>
</template>

<script>
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'ErrorNotFound',
})
</script>
<FILE_END>

<FILE_START path="web-app\src\pages\IndexPage.vue">
<template>
  <q-page class="flex flex-center">
    <img
      alt="Quasar logo"
      src="~assets/quasar-logo-vertical.svg"
      style="width: 200px; height: 200px"
    />
  </q-page>
</template>

<script>
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'IndexPage',
})
</script>
<FILE_END>

<FILE_START path="web-app\src\pages\RegistrationPage.vue">
<template>
  <q-page class="q-pa-md">
    <div class="row items-center q-col-gutter-sm q-mb-md">
      <div class="col">
        <div class="text-h5 text-weight-bold">Registrazioni</div>
        <div class="text-caption text-grey-7">
          Elenco registrazioni inviate (payload + PDF). In futuro verranno collegate alle prenotazioni.
        </div>
      </div>

      <div class="col-12 col-sm-auto">
        <q-input v-model="filter" dense outlined debounce="250" placeholder="Cerca nome, email, ID..." clearable>
          <template #prepend><q-icon name="search" /></template>
        </q-input>
      </div>

      <div class="col-12 col-sm-auto">
        <q-btn outline icon="refresh" label="Aggiorna" :loading="loading" @click="load" />
      </div>
    </div>

    <q-table
      :rows="filteredRows"
      :columns="columns"
      row-key="registration_id"
      :loading="loading"
      :pagination="pagination"
      flat
      bordered
    >
      <template #body-cell-is_minor="props">
        <q-td :props="props" class="text-center">
          <q-badge :color="props.value ? 'orange' : 'green'" rounded>
            {{ props.value ? 'S√¨' : 'No' }}
          </q-badge>
        </q-td>
      </template>

      <template #body-cell-locked="props">
        <q-td :props="props" class="text-center">
          <q-toggle
            v-model="props.row.locked"
            @update:model-value="val => onToggleLock(props.row, val)"
          />
        </q-td>
      </template>

      <template #body-cell-actions="props">
        <q-td :props="props" class="text-right">
          <q-btn dense flat icon="edit" color="primary" @click="editRegistration(props.row.registration_id)">
            <q-tooltip>Modifica Dati</q-tooltip>
          </q-btn>
          <q-btn dense flat icon="picture_as_pdf" @click="openPdf(props.row.registration_id)">
             <q-tooltip>Apri PDF</q-tooltip>
          </q-btn>
          <q-btn dense flat icon="info" @click="openDetails(props.row)">
             <q-tooltip>Dettagli & Storico</q-tooltip>
          </q-btn>
        </q-td>
      </template>
    </q-table>

    <q-dialog v-model="detailsOpen">
      <q-card style="min-width: 500px; max-width: 95vw;">
        <q-card-section class="row items-center bg-grey-2">
          <div class="text-h6">Dettagli Registrazione</div>
          <q-space />
          <q-btn flat round dense icon="close" v-close-popup />
        </q-card-section>

        <q-separator />

        <q-card-section v-if="loadingDetails" class="flex flex-center" style="min-height: 200px">
           <q-spinner-dots size="3em" color="primary" />
        </q-card-section>

        <q-card-section v-else-if="detailsFull">
          <div class="row q-col-gutter-md q-mb-lg">
            <div class="col-12 col-sm-6">
               <div class="text-caption text-grey-7">ID Registrazione</div>
               <div class="text-body2 text-weight-bold text-primary text-break">{{ detailsFull.registration_id }}</div>
            </div>
            <div class="col-12 col-sm-6">
               <div class="text-caption text-grey-7">Ultima Modifica</div>
               <div class="text-body2">{{ fmtDate(detailsFull.timestamp_iso) }}</div>
            </div>
            
            <div class="col-12">
               <div class="text-caption text-grey-7">Partecipante</div>
               <div class="text-body1">
                 {{ getPersonName(detailsFull.participant) }}
                 <span v-if="detailsFull.contact?.email" class="text-grey-7 text-caption">({{ detailsFull.contact.email }})</span>
               </div>
            </div>
          </div>

          <div class="row q-gutter-sm q-mb-lg">
            <q-btn outline icon="edit" label="Modifica" color="primary" @click="editRegistration(detailsFull.registration_id)" />
            <q-btn outline icon="picture_as_pdf" label="Apri PDF" @click="openPdf(detailsFull.registration_id)" />
          </div>

          <q-separator class="q-my-md" />

          <div class="text-h6 q-mb-md text-grey-8">
            <q-icon name="history" /> Storico Modifiche
          </div>

          <div v-if="!detailsFull.audit_log || detailsFull.audit_log.length === 0" class="text-grey-6 text-center q-pa-md">
            Nessuna modifica registrata.
          </div>

          <q-timeline v-else color="secondary">
            <q-timeline-entry
              v-for="(log, idx) in detailsFull.audit_log"
              :key="idx"
              :title="translateAction(log.action)"
              :subtitle="fmtDate(log.iso_date)"
              :icon="getActionIcon(log.action)"
              :color="getActionColor(log.action)"
            >
              <div class="text-grey-8">
                {{ log.details || 'Nessun dettaglio' }}
              </div>
            </q-timeline-entry>
          </q-timeline>

        </q-card-section>
      </q-card>
    </q-dialog>
  </q-page>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { api } from 'src/boot/axios'
import { useQuasar } from 'quasar'
import { useRouter } from 'vue-router'

const $q = useQuasar()
const router = useRouter()

const loading = ref(false)
const rows = ref([])
const filter = ref('')

const detailsOpen = ref(false)
const loadingDetails = ref(false)
const detailsFull = ref(null) // Contiene i dati completi dall'API (incluso audit_log)

const pagination = ref({
  sortBy: 'timestamp_iso',
  descending: true,
  rowsPerPage: 20
})

const columns = [
  { name: 'timestamp_iso', label: 'Data/Ora', field: 'timestamp_iso', sortable: true, format: v => fmtDate(v) },
  { name: 'participant', label: 'Partecipante', field: row => `${row.participant_nome || ''} ${row.participant_cognome || ''}`.trim(), sortable: true },
  { name: 'email', label: 'Email', field: 'email', sortable: true },
  { name: 'is_minor', label: 'Minore', field: 'is_minor', sortable: true, align: 'center' },
  { name: 'locked', label: 'Bloccata', field: 'locked', align: 'center' },
  { name: 'actions', label: '', field: 'actions', align: 'right' }
]

function fmtDate (iso) {
  if (!iso) return ''
  const d = new Date(iso)
  if (Number.isNaN(d.getTime())) return iso
  return d.toLocaleString('it-IT')
}

const filteredRows = computed(() => {
  const q = filter.value.trim().toLowerCase()
  if (!q) return rows.value
  return rows.value.filter(r => {
    const hay = [r.registration_id, r.participant_nome, r.participant_cognome, r.email]
      .map(x => (x || '').toString().toLowerCase()).join(' ')
    return hay.includes(q)
  })
})

async function load () {
  loading.value = true
  try {
    const res = await api.get('/registration/list', { params: { limit: 1000 } })
    rows.value = res.data?.items || []
  } catch (e) {
    console.error(e)
    $q.notify({ type: 'negative', message: 'Impossibile caricare le registrazioni' })
  } finally {
    loading.value = false
  }
}

function openPdf (registrationId) {
  const url = api.getUri({ url: `/registration/${registrationId}/pdf` })
  window.open(url, '_blank')
}

// Nuova logica: Carica dettagli completi dall'API
async function openDetails (row) {
  detailsOpen.value = true
  loadingDetails.value = true
  detailsFull.value = null
  
  try {
    const res = await api.get(`/registration/details/${row.registration_id}`)
    detailsFull.value = res.data
  } catch (e) {
    console.error("Err caricamento dettagli:", e)
    $q.notify({ type: 'negative', message: 'Errore caricamento dettagli' })
    detailsOpen.value = false
  } finally {
    loadingDetails.value = false
  }
}

function editRegistration (registrationId) {
  router.push(`/scanner/${registrationId}`)
}

async function onToggleLock (row, locked) {
  const prev = !locked
  try {
    await api.post(`/registration/${row.registration_id}/lock`, { locked })
    $q.notify({ type: 'positive', message: locked ? 'Registrazione bloccata' : 'Registrazione sbloccata' })
  } catch (e) {
    console.error(e)
    row.locked = prev
    $q.notify({ type: 'negative', message: 'Errore aggiornando il blocco' })
  }
}

// Helpers per il template
function getPersonName(p) {
  if (!p) return 'Sconosciuto'
  return `${p.nome || ''} ${p.cognome || ''}`.trim()
}

// Helpers per Audit Log
function translateAction(action) {
  const map = {
    'CREATE': 'Registrazione Creata',
    'UPDATE': 'Modifica Dati',
    'EMAIL_SENT': 'Email Inviata',
    'EMAIL_ERROR': 'Errore Email',
    'LOCK_CHANGE': 'Stato Blocco Modificato'
  }
  return map[action] || action
}

function getActionIcon(action) {
  if (action === 'CREATE') return 'add_circle'
  if (action === 'UPDATE') return 'edit'
  if (action === 'EMAIL_SENT') return 'mail'
  if (action === 'EMAIL_ERROR') return 'error'
  if (action === 'LOCK_CHANGE') return 'lock'
  return 'info'
}

function getActionColor(action) {
  if (action === 'CREATE') return 'green'
  if (action === 'UPDATE') return 'orange'
  if (action === 'EMAIL_SENT') return 'blue'
  if (action === 'EMAIL_ERROR') return 'red'
  if (action === 'LOCK_CHANGE') return 'grey-8'
  return 'grey'
}

onMounted(load)
</script>

<style scoped>
.text-break {
  word-break: break-all;
}
</style>
<FILE_END>

<FILE_START path="web-app\src\pages\ScannerPage.vue">
<template>
  <q-page class="q-pa-md bg-grey-1">
    <div class="text-h4 q-mb-md text-primary text-weight-bold text-center">
      {{ store.isEditMode ? 'Modifica Registrazione ‚úèÔ∏è' : 'Registrazione Guidata üöÄ' }}
    </div>

    <div v-if="loadingData" class="flex flex-center q-pa-xl">
      <q-spinner-dots size="3em" color="primary" />
      <div class="q-mt-md text-grey-7">Caricamento dati...</div>
    </div>

    <q-stepper
      v-else
      v-model="step"
      ref="stepper"
      color="primary"
      animated
      alternative-labels
      header-nav
      class="shadow-2 rounded-borders"
    >
      <!-- STEP 1: LINGUA -->
      <q-step :name="1" :title="t.steps.lang" icon="translate" :done="step > 1">
        <div class="row justify-center text-center">
          <div class="col-12 col-md-6">
            <div class="text-h6 q-mb-md">Scegli la lingua / Choose language</div>
            <div class="row q-gutter-md justify-center">
              <q-btn unelevated size="lg" :color="store.language === 'it' ? 'primary' : 'grey-4'" label="Italiano üáÆüáπ" v-on:click="store.setLanguage('it')" />
              <q-btn unelevated size="lg" :color="store.language === 'en' ? 'primary' : 'grey-4'" label="English üá¨üáß" v-on:click="store.setLanguage('en')" />
            </div>
            <q-btn class="q-mt-lg" color="primary" :label="t.nav.continue" v-on:click="step = 2" />
          </div>
        </div>
      </q-step>

      <!-- STEP 2: DOCUMENTI -->
      <q-step :name="2" :title="t.steps.docs" icon="badge" :done="step > 2">
        <div class="row justify-center">
          <StepDocuments 
            v-on:next="step = 3"
            v-on:prev="step = 1"
            v-on:open-camera="openCamera"
          />
        </div>
      </q-step>

      <!-- STEP 3: CONTATTI -->
      <q-step :name="3" :title="t.steps.contact" icon="contact_phone" :done="step > 3">
        <div class="row justify-center">
          <div class="col-12 col-md-6">
            <q-form v-on:submit="step = 4">
              <div class="text-subtitle1 q-mb-md">Recapiti obbligatori</div>
              <q-input v-model="store.contact.email" label="Email *" type="email" outlined class="q-mb-md" :readonly="store.isEditMode" :rules="[val => !!val || 'Email obbligatoria', val => /.+@.+\..+/.test(val) || 'Non valida']" />
              <div class="row q-col-gutter-sm">
                <div class="col-4">
                  <q-select v-model="store.contact.prefix" :options="['+39', '+33', '+49', '+41', '+44', '+1']" label="Prefisso" outlined :readonly="store.isEditMode" />
                </div>
                <div class="col-8">
                  <q-input v-model="store.contact.telefono" label="Telefono *" type="tel" outlined :readonly="store.isEditMode" :rules="[val => !!val || 'Obbligatorio']" />
                </div>
              </div>
              <div class="row justify-end q-mt-lg q-gutter-sm">
                <q-btn flat :label="t.nav.back" v-on:click="step = 2" />
                <q-btn color="primary" :label="t.nav.continue" type="submit" />
              </div>
            </q-form>
          </div>
        </div>
      </q-step>

      <!-- STEP 4: PRIVACY (Embedded Logic for Dialogs) -->
      <q-step :name="4" :title="t.steps.privacy" icon="gavel" :done="step > 4">
        <div class="row justify-center">
          <div class="col-12 col-md-8">
            <q-banner v-if="store.isEditMode" class="bg-green-1 q-mb-md rounded-borders">
              <q-icon name="check_circle" color="green" /> Consensi gi√† accettati.
            </q-banner>
            <q-banner v-else class="bg-indigo-1 q-mb-md rounded-borders text-body1">
              <q-icon name="info" color="primary" size="sm" class="q-mr-sm"/> Accettare i termini <strong>per ogni partecipante</strong>.
            </q-banner>

            <!-- Guardian Legal -->
            <q-card v-if="store.tutorParticipates || !store.hasMinors" bordered class="q-mb-lg" :class="store.guardian.ocrData.legal.isComplete ? 'bg-green-1' : 'bg-white'">
              <q-card-section class="row items-center justify-between">
                <div class="text-subtitle1 text-weight-bold">
                  <q-icon name="person" class="q-mr-xs"/> {{ store.hasMinors ? 'Tutore' : 'Partecipante' }}
                </div>
                <q-btn :color="store.guardian.ocrData.legal.isComplete ? 'positive' : 'primary'" :icon="store.guardian.ocrData.legal.isComplete ? 'check' : 'edit'" label="Consensi" v-on:click="openLegalDialog(store.guardian.ocrData, 'Adulto', true)" />
              </q-card-section>
            </q-card>

            <!-- Minors Legal -->
            <div v-if="store.hasMinors">
              <div class="q-pa-md q-mb-lg rounded-borders shadow-1 transition-all" :class="canSync ? 'bg-white border-primary' : 'bg-grey-2 text-grey-6'">
                <q-checkbox v-model="syncWithTutor" @update:model-value="onSyncToggle" :disable="!canSync" label="Applica le scelte del Tutore a tutti i minori" color="green" />
              </div>
              <div v-for="(minor, idx) in store.minors" :key="minor.id" class="q-mb-md">
                <q-card bordered :class="minor.ocrData.legal.isComplete ? 'bg-green-1' : 'bg-white'">
                  <q-card-section class="row items-center justify-between">
                    <div class="text-subtitle1 text-weight-bold"><q-icon name="child_care" class="q-mr-xs"/> Minore #{{ idx + 1 }}</div>
                    <q-btn :disable="syncWithTutor" :color="minor.ocrData.legal.isComplete ? 'positive' : 'primary'" icon="edit" label="Consensi" v-on:click="openLegalDialog(minor.ocrData, `Minore #${idx + 1}`, false)" />
                  </q-card-section>
                </q-card>
              </div>
            </div>

            <div class="row justify-end q-mt-lg q-gutter-sm">
              <q-btn flat :label="t.nav.back" v-on:click="step = 3" />
              <q-btn color="primary" :label="t.nav.continue" :disable="!allLegalCompleted" v-on:click="finalizeLegalStep" />
            </div>
          </div>
        </div>
      </q-step>

      <!-- STEP 5: VERIFICA E FIRMA -->
      <q-step :name="5" :title="t.steps.review" icon="edit_note" :done="step > 5">
        <div v-if="loadingOcr" class="flex flex-center q-pa-xl">
          <q-spinner-dots size="3em" color="primary" />
          <div class="q-mt-md">Elaborazione dati documenti...</div>
        </div>
        <StepReview v-else v-on:prev="step = 4" v-on:next="step = 6" />
      </q-step>

      <!-- STEP 6: RIEPILOGO -->
      <q-step :name="6" :title="t.steps.summary" icon="summarize">
        <div class="row justify-center">
          <div class="col-12 col-md-8 text-center">
            <div class="text-h5 q-mb-lg">Riepilogo Finale</div>
            <p class="text-grey-7">Controlla i dati e conferma.</p>
            <div class="row justify-between q-mt-xl">
              <q-btn flat :label="t.nav.back" v-on:click="step = 5" />
              <q-btn color="positive" size="lg" icon="check" :label="store.isEditMode ? t.nav.confirm_edit : t.nav.confirm" v-on:click="submitAll" :loading="submitting" />
            </div>
          </div>
        </div>
      </q-step>
    </q-stepper>

    <!-- GLOBAL DIALOGS -->
    
    <!-- Camera -->
    <q-dialog v-model="cameraDialog.open" maximized transition-show="slide-up" transition-hide="slide-down">
      <q-card class="bg-black">
        <CameraCapture 
          v-if="cameraDialog.open"
          :doc-type="cameraDialog.currentDocType"
          v-on:capture="onCameraCapture"
          v-on:close="cameraDialog.open = false"
        />
      </q-card>
    </q-dialog>

    <!-- Legal Modal -->
    <q-dialog v-model="legalDialog.open" persistent maximized transition-show="slide-up" transition-hide="slide-down">
      <q-card class="bg-grey-1">
        <q-toolbar class="bg-primary text-white">
          <q-toolbar-title>Consensi: {{ legalDialog.title }}</q-toolbar-title>
          <q-btn flat round dense icon="close" v-close-popup />
        </q-toolbar>
        <q-card-section class="q-pa-md">
          <div class="row justify-center">
            <div class="col-12 col-md-8">
              <q-stepper v-model="legalDialog.step" vertical animated class="bg-white rounded-borders">
                <!-- Privacy -->
                <q-step :name="1" title="Privacy Policy" icon="policy" :done="currentLegalData.privacy">
                  <div class="legal-scroll" v-on:scroll="onDialogScroll('privacy', $event)">
                    <div class="text-body2">{{ LEGAL_TEXTS.privacy }}</div>
                  </div>
                  <div class="row justify-end q-mt-md">
                    <q-btn color="primary" :label="t.privacy.read_and_accept" :disable="!legalDialog.unlocked.privacy && !store.isEditMode" v-on:click="currentLegalData.privacy = true; legalDialog.step = 2" />
                  </div>
                </q-step>
                <!-- Informed -->
                <q-step :name="2" title="Consenso Informato" icon="assignment" :done="currentLegalData.informedConsent">
                  <div class="legal-scroll" v-on:scroll="onDialogScroll('informed', $event)">
                    <div class="text-body2">{{ LEGAL_TEXTS.informed }}</div>
                  </div>
                  <div class="row justify-end q-mt-md">
                    <q-btn color="primary" :label="t.privacy.read_and_accept" :disable="!legalDialog.unlocked.informed && !store.isEditMode" v-on:click="currentLegalData.informedConsent = true; legalDialog.step = 3" />
                  </div>
                </q-step>
                <!-- Photo -->
                <q-step :name="3" title="Consenso Foto" icon="photo_camera" :done="currentLegalData.photoConsent !== null">
                  <div class="q-pa-sm bg-grey-2 rounded-borders q-mb-md text-body2">{{ t.privacy.photo_consent_text }}</div>
                  <q-option-group v-model="currentLegalData.photoConsent" :options="yesNoOptions" type="radio" inline @update:model-value="v => { if(!v) $q.notify({type:'warning', message: t.privacy.warn_photo}) }" />
                  <div class="row justify-end q-mt-md"><q-btn color="primary" label="Conferma" :disable="currentLegalData.photoConsent === null" v-on:click="legalDialog.step = 4" /></div>
                </q-step>
                <!-- Newsletter -->
                <q-step :name="4" title="Newsletter" icon="mail" :done="currentLegalData.newsletterConsent !== null">
                  <div class="q-pa-sm bg-grey-2 rounded-borders q-mb-md text-body2">{{ t.privacy.newsletter_text }}</div>
                  <q-option-group v-model="currentLegalData.newsletterConsent" :options="yesNoOptions" type="radio" inline />
                  <div class="row justify-end q-mt-md"><q-btn color="primary" label="Conferma e Chiudi" :disable="currentLegalData.newsletterConsent === null" v-on:click="closeLegalDialog(true)" /></div>
                </q-step>
              </q-stepper>
            </div>
          </div>
        </q-card-section>
      </q-card>
    </q-dialog>

    <!-- Error/Warning Dialogs -->
    <q-dialog v-model="warningMismatchDialog.open">
      <q-card style="min-width: 350px">
        <q-card-section class="bg-orange-1 text-orange-9"><div class="text-h6"><q-icon name="warning" /> Verifica Documento</div></q-card-section>
        <q-card-section>
          <ul class="q-pl-md"><li v-for="(warn, i) in warningMismatchDialog.messages" :key="i">{{ warn }}</li></ul>
        </q-card-section>
        <q-card-actions align="right">
          <q-btn flat label="Correggi" color="primary" v-close-popup v-on:click="step = 2" />
          <q-btn unelevated label="Ignora" color="orange" text-color="white" v-close-popup v-on:click="step = 5" />
        </q-card-actions>
      </q-card>
    </q-dialog>

  </q-page>
</template>

<script setup>
import { ref, reactive, computed, onMounted, watch } from 'vue'
import { useRegistrationStore } from 'stores/registration-store'
import { useQuasar } from 'quasar'
import { useRoute, useRouter } from 'vue-router'
import { api } from 'src/boot/axios'
import { translations } from 'src/constants/translations' // Named Import Corretto
import { LEGAL_TEXTS } from 'src/constants/legal'
import CameraCapture from 'components/CameraCapture.vue'
import StepDocuments from 'components/scanner/steps/StepDocuments.vue'
import StepReview from 'components/scanner/steps/StepReview.vue'

// Init
const store = useRegistrationStore()
const $q = useQuasar()
const route = useRoute()
const router = useRouter()

// State
const step = ref(1)
const loadingData = ref(false)
const loadingOcr = ref(false)
const submitting = ref(false)
const syncWithTutor = ref(false)

const t = computed(() => translations[store.language] || translations.it)
const yesNoOptions = [{label: 'S√¨', value: true}, {label: 'No', value: false}]

// Dialogs
const warningMismatchDialog = reactive({ open: false, messages: [] })
const cameraDialog = reactive({ open: false, target: null, side: null, index: null, currentDocType: 'CIE' })
const legalDialog = reactive({ open: false, step: 1, title: '', targetRef: null, isGuardian: false, unlocked: { privacy: false, informed: false } })

const currentLegalData = computed(() => legalDialog.targetRef ? legalDialog.targetRef.legal : {})
const canSync = computed(() => store.guardian.ocrData.legal.isComplete)
const allLegalCompleted = computed(() => {
  if ((store.tutorParticipates || !store.hasMinors) && !store.guardian.ocrData.legal.isComplete) return false
  if (store.hasMinors && store.minors.some(m => !m.ocrData.legal.isComplete)) return false
  return true
})

// Lifecycle
onMounted(async () => {
  if (route.params.id) {
    loadingData.value = true
    try {
      await store.fetchRegistration(route.params.id)
      step.value = 4
    } catch (e) {
      console.error(e) // FIX: Logghiamo l'errore per evitare ESLint warning
      $q.notify({ type: 'negative', message: 'Errore caricamento dati.' })
    } finally { loadingData.value = false }
  } else {
    store.resetStore()
  }
})

watch(() => store.hasMinors, (val) => { if (val && store.minors.length === 0) store.addMinor() })

// Camera Logic
function openCamera({ target, side, index }) {
  cameraDialog.target = target
  cameraDialog.side = side
  cameraDialog.index = index
  cameraDialog.currentDocType = (target === 'guardian') ? store.guardian.ocrData.tipo_documento : store.minors[index].ocrData.tipo_documento
  cameraDialog.open = true
}

function onCameraCapture(file) {
  cameraDialog.open = false
  if (cameraDialog.target === 'guardian') {
    if (cameraDialog.side === 'FRONT') store.guardian.frontFile = file
    if (cameraDialog.side === 'BACK') store.guardian.backFile = file
    store.startGuardianScan()
  } else {
    const idx = cameraDialog.index
    if (cameraDialog.side === 'FRONT') store.minors[idx].frontFile = file
    if (cameraDialog.side === 'BACK') store.minors[idx].backFile = file
    store.startMinorScan(idx)
  }
  $q.notify({ type: 'positive', message: 'Analisi in corso...' })
}

// Legal Logic
function openLegalDialog(personData, title, isGuardian) {
  legalDialog.targetRef = personData
  legalDialog.title = title
  legalDialog.isGuardian = isGuardian
  legalDialog.step = 1
  legalDialog.unlocked = { privacy: store.isEditMode, informed: store.isEditMode }
  legalDialog.open = true
}

function onDialogScroll(type, e) {
  const el = e.target
  if(el.scrollTop + el.clientHeight >= el.scrollHeight - 50) {
    if(type === 'privacy') legalDialog.unlocked.privacy = true
    if(type === 'informed') legalDialog.unlocked.informed = true
  }
}

function closeLegalDialog(complete) {
  if (complete && legalDialog.targetRef) {
    legalDialog.targetRef.legal.isComplete = true
    if (legalDialog.isGuardian && syncWithTutor.value) onSyncToggle(true)
  }
  legalDialog.open = false
}

function onSyncToggle(val) {
  if (val && store.guardian.ocrData.legal.isComplete) {
    store.minors.forEach(m => m.ocrData.legal = { ...store.guardian.ocrData.legal })
    $q.notify({ type: 'positive', message: 'Consensi sincronizzati.' })
  }
}

async function finalizeLegalStep() {
  if (!store.isEditMode && !store.isManualMode) {
    loadingOcr.value = true
    try {
      await store.resolveAllOcr()
      const warnings = []
      if (store.guardian.ocrData.warning_mismatch) warnings.push('Tutore: Tipo documento errato?')
      store.minors.forEach((m, i) => { if (m.ocrData.warning_mismatch) warnings.push(`Minore ${i+1}: Tipo documento errato?`) })
      
      if (warnings.length > 0) {
        warningMismatchDialog.messages = warnings
        warningMismatchDialog.open = true
        return
      }
    } finally { loadingOcr.value = false }
  }
  step.value = 5
}

// Submission
function validatePerson(p, label) {
  if (!p.nome || !p.cognome || !p.data_nascita || !p.tipo_documento || !p.numero_documento) return `${label}: Dati mancanti`
  if (!p.signature) return `${label}: Firma mancante`
  return null
}

async function submitAll() {
  const errors = []
  if (store.tutorParticipates || !store.hasMinors) {
    const err = validatePerson(store.guardian.ocrData, store.hasMinors ? 'Tutore' : 'Partecipante')
    if(err) errors.push(err)
  }
  store.minors.forEach((m, i) => {
    const err = validatePerson(m.ocrData, `Minore ${i+1}`)
    if(err) errors.push(err)
  })

  if (errors.length > 0) {
    $q.notify({ type: 'negative', message: errors[0] })
    return
  }

  submitting.value = true
  // Costruzione payload semplificata per brevit√† (simile all'originale)
  const finalContact = { email: store.contact.email, telefono: `${store.contact.prefix} ${store.contact.telefono}` }
  const payloads = []
  
  if (store.tutorParticipates || !store.hasMinors) {
    payloads.push({
      participant: store.guardian.ocrData,
      contact: finalContact,
      signatureBase64: store.guardian.ocrData.signature, // Assicurato dal validatore
      is_minor: false,
      language: store.language
    })
  }
  store.minors.forEach(m => {
    payloads.push({
      participant: m.ocrData,
      guardian: store.guardian.ocrData, // Link al tutore
      contact: finalContact,
      signatureBase64: m.ocrData.signature || store.guardian.ocrData.signature,
      is_minor: true,
      language: store.language
    })
  })

  try {
    for (const p of payloads) {
      await api.post('/registration/submit', p, { params: store.isEditMode ? { update_id: store.editRegistrationId } : {} })
    }
    $q.notify({ type: 'positive', message: 'Fatto!' })
    router.push(store.isEditMode ? '/registrazioni' : '/')
  } catch(e) {
    console.error(e)
    $q.notify({ type: 'negative', message: 'Errore invio' })
  } finally { submitting.value = false }
}
</script>

<style scoped>
.legal-scroll {
  height: 200px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; background: #f9f9f9; white-space: pre-wrap;
}
.transition-all { transition: all 0.3s ease; }
.border-primary { border: 1px solid var(--q-primary); }
.border-orange { border: 1px solid var(--q-warning); }
</style>
<FILE_END>

<FILE_START path="web-app\src\router\index.js">
import { defineRouter } from '#q-app/wrappers'
import {
  createRouter,
  createMemoryHistory,
  createWebHistory,
  createWebHashHistory,
} from 'vue-router'
import routes from './routes'

/*
 * If not building with SSR mode, you can
 * directly export the Router instantiation;
 *
 * The function below can be async too; either use
 * async/await or return a Promise which resolves
 * with the Router instance.
 */

export default defineRouter(function (/* { store, ssrContext } */) {
  const createHistory = process.env.SERVER
    ? createMemoryHistory
    : process.env.VUE_ROUTER_MODE === 'history'
      ? createWebHistory
      : createWebHashHistory

  const Router = createRouter({
    scrollBehavior: () => ({ left: 0, top: 0 }),
    routes,

    // Leave this as is and make changes in quasar.conf.js instead!
    // quasar.conf.js -> build -> vueRouterMode
    // quasar.conf.js -> build -> publicPath
    history: createHistory(process.env.VUE_ROUTER_BASE),
  })

  return Router
})
<FILE_END>

<FILE_START path="web-app\src\router\routes.js">
const routes = [
  {
    path: '/',
    component: () => import('layouts/MainLayout.vue'),
    children: [
      // La Home √® la Dashboard
      { path: '', component: () => import('pages/DashboardPage.vue') },

      // Registrazione guidata (accetta ID opzionale per editing)
      { path: 'scanner/:id?', component: () => import('pages/ScannerPage.vue') },

      // Archivio registrazioni
      { path: 'registrazioni', component: () => import('pages/RegistrationPage.vue') }
    ]
  },

  
  {
    path: '/:catchAll(.*)*',
    component: () => import('pages/ErrorNotFound.vue')
  }
]

export default routes
<FILE_END>

<FILE_START path="web-app\src\services\ImageQualityService.js">
/**
 * ImageQualityService.js
 *
 * Implementazione leggera di algoritmi di Computer Vision lato client.
 * L'obiettivo √® filtrare immagini di bassa qualit√† (sfocate, buie, mosse)
 * direttamente nel browser prima dell'invio al backend.
 *
 * Riferimento Strategia: Sezione 3 (Algoritmi di Validazione) [cite: 65]
 */

export default {
  /**
   * Converte i dati RGBA del Canvas in Scala di Grigi (Luminanza).
   * Formula: L = 0.299R + 0.587G + 0.114B [cite: 77]
   * @param {Uint8ClampedArray} data - Dati pixel (R, G, B, A, R, G, B, A...)
   * @returns {Uint8Array} Array di sola luminanza
   */
  convertToGrayscale (data) {
    const gray = new Uint8Array(data.length / 4)
    for (let i = 0; i < data.length; i += 4) {
      // i = Red, i+1 = Green, i+2 = Blue
      gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]
    }
    return gray
  },

  /**
   * Calcola la luminosit√† media dell'immagine.
   * Utile per rilevare immagini sottoesposte o sovraesposte.
   * @param {Uint8Array} grayData - Array scala di grigi
   * @returns {number} Valore medio 0-255
   */
  calculateBrightness (grayData) {
    let sum = 0
    for (let i = 0; i < grayData.length; i++) {
      sum += grayData[i]
    }
    return Math.floor(sum / grayData.length)
  },

  /**
   * Rileva la nitidezza utilizzando una simulazione del filtro Laplaciano.
   * Calcola la varianza delle differenze tra pixel adiacenti (rilevamento bordi).
   * Una varianza alta indica bordi netti (a fuoco). Una bassa indica sfocatura.
   * Riferimento: Sezione 3.1 [cite: 70, 83]
   *
   * @param {Uint8Array} grayData - Array scala di grigi
   * @param {number} width - Larghezza immagine
   * @param {number} height - Altezza immagine
   * @returns {number} Punteggio di nitidezza (Varianza)
   */
  calculateBlurScore (grayData, width, height) {
    let sum = 0
    let sumSq = 0
    let count = 0

    // Kernel Laplaciano semplificato (croce):
    //  0  1  0
    //  1 -4  1
    //  0  1  0
    // Iteriamo saltando i bordi per evitare out-of-bounds
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const i = y * width + x

        // Convoluzione manuale per performance [cite: 78]
        const val =
          grayData[i - width] + // Top
          grayData[i - 1] +     // Left
          grayData[i + 1] +     // Right
          grayData[i + width] - // Bottom
          4 * grayData[i]       // Center

        sum += val
        sumSq += val * val
        count++
      }
    }

    const mean = sum / count
    const variance = (sumSq / count) - (mean * mean)
    return Math.floor(variance)
  },

  /**
   * Calcola la differenza quadratica media (MSE) tra due frame consecutivi.
   * Usato per rilevare se l'utente sta muovendo il telefono (Motion Detection).
   * Riferimento: Sezione 3.3 [cite: 97]
   *
   * @param {Uint8Array} currentGray - Frame corrente
   * @param {Uint8Array} previousGray - Frame precedente
   * @returns {number} Punteggio MSE (pi√π √® basso, pi√π √® stabile)
   */
  calculateStabilityMSE (currentGray, previousGray) {
    if (!previousGray || currentGray.length !== previousGray.length) return 9999

    // Ottimizzazione: campioniamo 1 pixel ogni 4 per velocit√† (downsampling implicito)
    // Non serve analizzare ogni pixel per rilevare il movimento macroscopico
    let errorSum = 0
    let count = 0
    const step = 4

    for (let i = 0; i < currentGray.length; i += step) {
      const diff = currentGray[i] - previousGray[i]
      errorSum += diff * diff
      count++
    }

    return errorSum / count
  },

  /**
   * Metodo helper che esegue l'analisi completa su dati ImageData.
   */
  analyzeFrame (imageData, previousGray = null) {
    const gray = this.convertToGrayscale(imageData.data)
    const brightness = this.calculateBrightness(gray)
    const blurScore = this.calculateBlurScore(gray, imageData.width, imageData.height)
    const stability = this.calculateStabilityMSE(gray, previousGray)

    return {
      grayBuffer: gray, // Da salvare per il prossimo ciclo come "previousGray"
      metrics: {
        brightness,
        blurScore,
        stability
      }
    }
  }
}
<FILE_END>

<FILE_START path="web-app\src\services\VisionService.js">
import { api } from 'src/boot/axios'

export default {
  /**
   * Invia i documenti al backend per l'analisi OCR.
   * Prova prima /registration/scan, poi fallback su /vision/analyze (compatibilit√†).
   */
  async analyzeDocument (frontFile, backFile = null, docType = 'AUTO') {
    const buildFormData = () => {
      const formData = new FormData()
      formData.append('front', frontFile)
      if (backFile) formData.append('back', backFile)

      // Compatibilit√† con endpoint legacy
      formData.append('use_local', 'true')
      formData.append('doc_type', docType)

      return formData
    }

    const postMultipart = async (url) => {
      const formData = buildFormData()
      return api.post(url, formData, { headers: { 'Content-Type': 'multipart/form-data' } })
    }

    try {
      // 1) Endpoint nuovo
      try {
        const res = await postMultipart('/registration/scan')
        const data = res.data
        return (data && typeof data === 'object' && data.extracted) ? data.extracted : data
      } catch (e) {
        const status = e?.response?.status
        if (status !== 404 && status !== 405) throw e
      }

      // 2) Fallback legacy
      const res = await postMultipart('/vision/analyze')
      return res.data
    } catch (error) {
      console.error('VisionService Error:', error)
      if (error?.response?.data?.detail) throw new Error(error.response.data.detail)
      throw new Error('Impossibile connettersi al server di Analisi.')
    }
  }
}
<FILE_END>

<FILE_START path="web-app\src\stores\index.js">
import { defineStore } from '#q-app/wrappers'
import { createPinia } from 'pinia'

/*
 * If not building with SSR mode, you can
 * directly export the Store instantiation;
 *
 * The function below can be async too; either use
 * async/await or return a Promise which resolves
 * with the Store instance.
 */

export default defineStore((/* { ssrContext } */) => {
  const pinia = createPinia()

  // You can add Pinia plugins here
  // pinia.use(SomePiniaPlugin)

  return pinia
})
<FILE_END>

<FILE_START path="web-app\src\stores\registration-store.js">
import { defineStore } from 'pinia'
import VisionService from 'src/services/VisionService'
import { api } from 'src/boot/axios'

// Helper per struttura dati persona vuota
const createEmptyPerson = (sourceType = 'MANUALE') => ({
  nome: '',
  cognome: '',
  data_nascita: '',

  // Geografici
  stato_nascita: 'ITALIA',
  comune_nascita: '',
  stato_residenza: 'ITALIA',
  comune_residenza: '',
  codice_fiscale: '',

  // Documento
  tipo_documento: 'CIE',
  numero_documento: '',
  scadenza_documento: '',

  // Fonte del dato (OCR_AUTO, MANUALE, CAMERA_SMART, ecc.)
  source: sourceType,

  // Dati di Debug e Warning
  debug: null,
  warning_mismatch: false,

  // Consensi SPECIFICI per questa persona
  legal: {
    privacy: false,
    informedConsent: false,
    tesseramento: false,
    photoConsent: null, // true/false/null
    newsletterConsent: null, // true/false/null
    isComplete: false // Helper flag
  },

  signature: null
})

export const useRegistrationStore = defineStore('registration', {
  state: () => ({
    // Edit Mode State
    editRegistrationId: null, // Se popolato, siamo in modifica

    // Step 1
    language: 'it',

    // Step 2
    tutorParticipates: true,
    hasMinors: false,

    // Modalit√† di Input: 'SCAN' (Default) o 'MANUAL' (Fallback/Emergency)
    inputMode: 'SCAN',

    guardian: {
      frontFile: null,
      backFile: null,
      ocrData: createEmptyPerson('MANUALE'),
      ocrPromise: null,
      isAnalyzed: false
    },

    minors: [], // Array di oggetti { id, frontFile, backFile, ocrData: createEmptyPerson(), ... }

    // Step 3
    contact: {
      email: '',
      prefix: '+39',
      telefono: ''
    },

    // Global settings
    tesseramentoRequired: true,

    // Step 5 (Firma principale/tutore)
    signatureBase64: null
  }),

  getters: {
    isEditMode: (state) => !!state.editRegistrationId,
    isManualMode: (state) => state.inputMode === 'MANUAL'
  },

  actions: {
    setLanguage (lang) {
      this.language = (lang === 'en') ? 'en' : 'it'
    },

    /**
     * Imposta la modalit√† di inserimento.
     * Se MANUAL, inizializza i dati vuoti e bypassa le richieste di file.
     *  Escape Hatch implementation.
     */
    setInputMode (mode) {
      this.inputMode = mode
      if (mode === 'MANUAL') {
        this.guardian.ocrData = createEmptyPerson('MANUALE')
        this.guardian.isAnalyzed = true // Consideriamo "analizzato" (skip OCR)
        // Reset file se presenti
        this.guardian.frontFile = null
        this.guardian.backFile = null
      } else {
        // Reset stato se torniamo a SCAN
        this.guardian.isAnalyzed = false
      }
    },

    addMinor () {
      if (this.minors.length >= 10) return
      // Se siamo in manual mode, il minore nasce gi√† "analizzato" e manuale
      const isManual = this.inputMode === 'MANUAL'
      this.minors.push({
        id: Date.now(),
        frontFile: null,
        backFile: null,
        ocrData: createEmptyPerson(isManual ? 'MANUALE' : 'OCR_AUTO'),
        ocrPromise: null,
        isAnalyzed: isManual
      })
    },

    removeMinor (index) {
      this.minors.splice(index, 1)
    },

    resetGuardianScanState () {
      this.guardian.isAnalyzed = false
      this.guardian.ocrPromise = null
    },

    resetMinorScanState (index) {
      const minor = this.minors[index]
      if (!minor) return
      minor.isAnalyzed = false
      minor.ocrPromise = null
    },

    startGuardianScan () {
      if (!this.guardian.frontFile) return

      // Passiamo il tipo documento come hint
      const docHint = this.guardian.ocrData.tipo_documento || 'AUTO'

      this.guardian.ocrPromise = VisionService.analyzeDocument(
        this.guardian.frontFile,
        this.guardian.backFile,
        docHint
      ).then(data => {
        const mapped = this.mapOcrToForm(data)
        // Merge dati mantenendo legal esistente
        this.guardian.ocrData = {
          ...this.guardian.ocrData,
          ...mapped,
          source: 'OCR_HYBRID', // Tracciamo che viene dall'AI
          legal: this.guardian.ocrData.legal
        }
        this.guardian.isAnalyzed = true
        return data
      }).catch(err => {
        console.error('Errore background Guardian:', err)
      })
    },

    startMinorScan (index) {
      const minor = this.minors[index]
      if (!minor?.frontFile) return

      const docHint = minor.ocrData.tipo_documento || 'AUTO'

      minor.ocrPromise = VisionService.analyzeDocument(
        minor.frontFile,
        minor.backFile,
        docHint
      ).then(data => {
        const mapped = this.mapOcrToForm(data)
        minor.ocrData = {
          ...minor.ocrData,
          ...mapped,
          source: 'OCR_HYBRID',
          legal: minor.ocrData.legal
        }
        minor.isAnalyzed = true
        return data
      }).catch(err => {
        console.error('Errore background Minore:', err)
      })
    },

    mapOcrToForm (data) {
      if (!data || data.error) return {}

      // Logica di fallback cittadinanza (usata solo se il backend non √® esplicito)
      const nat = (data.cittadinanza || data.mrz_nationality || '').toString().toUpperCase().trim()
      const isItalian = !nat || nat === 'ITA' || nat === 'IT' || nat === 'ITALIANA'

      return {
        nome: data.nome || '',
        cognome: data.cognome || '',
        data_nascita: data.data_nascita || '',

        // Mappatura esplicita backend o fallback
        stato_nascita: data.stato_nascita || (isItalian ? 'ITALIA' : (data.nazione_nascita || '')),
        stato_residenza: data.stato_residenza || (isItalian ? 'ITALIA' : ''),

        comune_nascita: data.comune_nascita || data.luogo_nascita || '',
        comune_residenza: data.comune_residenza || '',

        codice_fiscale: data.codice_fiscale || '',

        tipo_documento: data.tipo_documento || 'ALTRO',
        numero_documento: data.numero_documento || '',
        scadenza_documento: data.scadenza_documento || data.data_scadenza || '',

        source: data.source || 'OCR_AUTO',
        debug: data._debug_info || null,
        warning_mismatch: !!data.warning_mismatch
      }
    },

    async resolveAllOcr () {
      // Se siamo in manual mode, non c'√® nulla da attendere
      if (this.inputMode === 'MANUAL') return

      const promises = []
      if (this.guardian.ocrPromise) promises.push(this.guardian.ocrPromise)
      this.minors.forEach(m => {
        if (m.ocrPromise) promises.push(m.ocrPromise)
      })
      await Promise.allSettled(promises)
    },

    // --- LOGICA EDIT MODE ---
    async fetchRegistration (id) {
      this.resetStore()
      this.editRegistrationId = id

      try {
        const res = await api.get(`/registration/details/${id}`)
        const data = res.data

        // 1. Setta Lingua e Contatti
        this.language = data.language || 'it'
        if (data.contact) {
          this.contact.email = data.contact.email || ''
          this.contact.telefono = data.contact.telefono || ''
          // Gestione prefisso basic se presente nel numero
          if (this.contact.telefono.startsWith('+')) {
            this.contact.prefix = this.contact.telefono.substring(0, 3)
            this.contact.telefono = this.contact.telefono.substring(3)
          }
        }

        // Helper per mappare i dati anagrafici nel form
        const mapPersonData = (source) => {
          const empty = createEmptyPerson(source.source || 'DB_FETCH')
          if (!source) return empty

          // Mappatura diretta campi
          const dest = { ...empty, ...source }

          // Mappatura sub-oggetti geografici (gestione retrocompatibilit√†)
          if (source.italian) {
            dest.comune_nascita = source.italian.comune_nascita || source.comune_nascita
            dest.comune_residenza = source.italian.comune_residenza || source.comune_residenza
            dest.codice_fiscale = source.italian.codice_fiscale || source.codice_fiscale
          }

          // Mappatura Consensi:
          const oldLegal = source.legal_consents || source.legal || {}
          dest.legal = {
            privacy: true, // Pre-accettato
            informedConsent: true, // Pre-accettato
            tesseramento: true,
            photoConsent: oldLegal.photo,
            newsletterConsent: oldLegal.newsletter,
            isComplete: false // Forziamo l'utente a confermare
          }

          return dest
        }

        // 2. Popolamento Persone
        const isMinorReg = data.is_minor || false

        if (!isMinorReg) {
          // Caso Adulto
          this.tutorParticipates = true
          this.hasMinors = false
          this.guardian.ocrData = mapPersonData(data.participant)
          this.guardian.isAnalyzed = true // Evita OCR
        } else {
          // Caso Minore
          this.hasMinors = true
          this.tutorParticipates = data.tutor_participates // Dovrebbe venire dal payload

          // Popola Tutore
          if (data.guardian) {
            this.guardian.ocrData = mapPersonData(data.guardian)
            this.guardian.isAnalyzed = true
          }

          // Popola Minore
          this.addMinor()
          this.minors[0].ocrData = mapPersonData(data.participant)
          this.minors[0].isAnalyzed = true
        }

      } catch (e) {
        console.error("Errore fetch registration", e)
        throw e
      }
    },

    resetStore () {
      this.$reset()
      // Assicuriamoci che inputMode torni al default
      this.inputMode = 'SCAN'
    }
  }
})
<FILE_END>

