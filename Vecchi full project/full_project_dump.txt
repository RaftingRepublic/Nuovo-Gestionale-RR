RAFTING REPUBLIC - PROJECT DUMP
GENERATED: 2026-02-10 09:14:22
==================================================

=== PROJECT STRUCTURE ===
./
    README.md
    backend/
        dataset.yaml
        main.py
        app/
            __init__.py
            api/
                __init__.py
                v1/
                    api.py
                    __init__.py
                    endpoints/
                        registration.py
                        vision.py
                        waivers.py
                        __init__.py
            schemas/
                registration.py
                __init__.py
            services/
                document_specs.py
                image_utils.py
                local_vision_service.py
                waiver_mailer.py
                waiver_service.py
                __init__.py
                registration/
                    email_service.py
                    mrz_native.py
                    pdf_service.py
                    registration_service.py
                    storage_service.py
        assets/
            models/
            templates/
        storage/
            daily_freezes/
                freeze_report_2026-02-09.json
            dataset_raw/
            debug_captures/
            registrations/
                151564a6-3ef8-4426-9b04-1b538b6d241f/
                    audit.json
                    payload.json
                30899da0-a1a9-4590-820a-fe32a3e2ed79/
                    audit.json
                    payload.json
        test/
            check_libs.py
            check_models.py
            test_ocr_isolation.py
            test_ocr_noise.py
            test_ocr_refinement.py
            test_ocr_rotation.py
            test_tesseract.py
        tools/
            check_full_stack.py
            convert_labelstudio_to_yolo.py
            daily_freeze.py
            diagnose_env.py
            env_audit.py
            fix_dependencies.py
            fix_gliner.py
            generate_synthetic_data.py
            project_export.json
            test_yolo_inference.py
            train_yolo.py
            verify_paddle.py
            zone_calibrator.py
    Vecchi full project/
    web-app/
        .prettierrc.json
        eslint.config.js
        index.html
        jsconfig.json
        package.json
        postcss.config.js
        quasar.config.js
        README.md
        public/
            icons/
        src/
            App.vue
            assets/
            boot/
                axios.js
            components/
                CameraCapture.vue
                ModuleCard.vue
                scanner/
                    PersonForm.vue
                    SignaturePad.vue
                    steps/
                        StepDocuments.vue
                        StepReview.vue
            constants/
                legal.js
                translations.js
            css/
                app.scss
                quasar.variables.scss
            layouts/
                MainLayout.vue
            pages/
                DashboardPage.vue
                ErrorNotFound.vue
                IndexPage.vue
                RegistrationPage.vue
                ScannerPage.vue
            router/
                index.js
                routes.js
            services/
                ImageQualityService.js
                VisionService.js
            stores/
                index.js
                registration-store.js

==================================================

=== FILE CONTENTS ===

<FILE_START path="README.md">
üö£ Rafting Republic - Gestionale AI (GDPR Compliant)
Versione: 2.0 (Migration & Compliance Edition) Stack: Python 3.10 (FastAPI) + Vue 3 (Quasar) Focus: OCR Ibrido (Paddle+YOLO+GLiNER), Sicurezza Legale (FEA), Zero-Data-Retention.

‚ö†Ô∏è 1. Prerequisiti Tassativi (Windows)
Prima di scaricare il codice, assicurati di avere questi componenti. Non ignorare questa sezione, √® la causa del 99% dei crash (Error 127).

Python 3.10.x: Scarica qui.

Non usare 3.11 o 3.12 (incompatibili con alcune lib AI).

Spunta "Add Python to PATH" durante l'installazione.

Visual C++ Redistributable 2015-2022 (x64): Scarica Ufficiale Microsoft.

Necessario per PyTorch e PaddleOCR. Riavvia il PC dopo l'installazione.

Node.js (LTS): Scarica qui.

Git: Scarica qui.

üõ†Ô∏è 2. Installazione Backend (Il Motore AI)
Il backend richiede una gestione chirurgica delle dipendenze per evitare il "DLL Hell" di Windows.

2.1 Setup Ambiente
Apri PowerShell come Amministratore nella cartella del progetto:

PowerShell
cd backend

# 1. Crea Ambiente Virtuale (Python 3.10)
py -3.10 -m venv venv

# 2. Attiva Ambiente
.\venv\Scripts\activate
# (Dovresti vedere "(venv)" all'inizio della riga)

# 3. Aggiorna PIP
python -m pip install --upgrade pip setuptools wheel
2.2 Installazione "Golden Version" (CPU Only)
Esegui questi comandi in ordine per installare le versioni stabili e certificate:

PowerShell
# A. Installa PyTorch CPU (Evita driver Nvidia pesanti)
pip install torch==2.4.1 torchvision==0.19.1 torchaudio==2.4.1 --index-url https://download.pytorch.org/whl/cpu

# B. Installa librerie Core e AI
pip install paddlepaddle==2.6.2 paddleocr==2.7.3 ultralytics==8.3.20 opencv-python-headless fastapi uvicorn[standard] python-multipart python-dotenv

# C. Installa GLiNER Compatibile (Versione 0.2.7 per evitare crash su huggingface)
pip install gliner==0.2.7 huggingface-hub==0.23.0

# D. Fix per Windows "Error 127" (Librerie Intel OpenMP)
pip install intel-openmp
2.3 Configurazione Privacy (.env)
Crea un file chiamato .env dentro la cartella backend/ con questo contenuto:

Ini, TOML
# backend/.env

APP_ENV=production
LOG_LEVEL=INFO

# --- COMPLIANCE LEGALE (GDPR) ---
# NONE: Le immagini vengono elaborate in RAM e distrutte subito (Produzione)
# DEBUG: Le immagini vengono salvate in storage/dataset_raw (Sviluppo)
ID_IMAGE_RETENTION=NONE

# Configurazione Email (Opzionale)
SMTP_HOST=localhost
SMTP_PORT=1025
SMTP_USER=none
SMTP_PASS=none
SMTP_FROM=noreply@raftingrepublic.it
2.4 Patch Critica "Main.py"
Assicurati che il file backend/main.py inizi con questo blocco per prevenire conflitti DLL:

Python
# backend/main.py
import os
import sys
try:
    import torch  # <-- DEVE ESSERE IL PRIMO IMPORT
except ImportError:
    pass
from fastapi import FastAPI
# ... resto del codice
üé® 3. Installazione Frontend (Quasar)
Apri un nuovo terminale (non quello del backend):

PowerShell
cd web-app

# 1. Installa dipendenze
npm install

# (Opzionale) Se npm da errori strani, usa: npm install --legacy-peer-deps
üöÄ 4. Avvio del Sistema
Terminale 1: Backend
PowerShell
cd backend
.\venv\Scripts\activate
# Avvia il server (su 0.0.0.0 per essere raggiungibile da mobile in LAN)
uvicorn main:app --host 0.0.0.0 --port 8000
Attendi finch√© non leggi: "Application startup complete".

Terminale 2: Frontend
PowerShell
cd web-app
npx quasar dev
Si aprir√† il browser automaticamente.

‚öñÔ∏è 5. Architettura di Compliance Legale
Questa installazione include tre pilastri fondamentali per la protezione legale dell'azienda:

Minimizzazione Dati (GDPR Art. 5):

Logica "Scan & Discard". Le immagini dei documenti (CIE/Passaporti) vengono processate in memoria volatile (RAM) e distrutte immediatamente dopo l'estrazione dei dati. Non vengono mai salvate su disco se ID_IMAGE_RETENTION=NONE.

Firma Grafometrica (Predisposizione FEA):

Il componente di firma (SignaturePad.vue) non cattura solo l'immagine, ma registra i vettori biometrici (coordinate X/Y, tempo, velocit√† del tratto). Questi dati vengono passati al backend per eventuale hashing/crittografia forense.

Integrit√† dei Log (Hash Chaining):

Il registro delle operazioni (audit.json) utilizza una catena di hash stile Blockchain. Ogni log contiene l'hash del precedente. Qualsiasi manomissione manuale di un file di log (es. per nascondere un errore) rompe la catena matematica, rendendo la manomissione evidente ("Tamper-Evident").

üöë 6. Troubleshooting Rapido
Errore [WinError 127] ... shm.dll: Manca Visual C++ Redistributable o c'√® un conflitto di ordine.

Fix: Riavvia PC -> Controlla che import torch sia la prima riga di main.py -> Esegui pip install intel-openmp.

Errore GLiNER ... missing arguments: Versione GLiNER troppo nuova.

Fix: pip install gliner==0.2.7 huggingface-hub==0.23.0.

Errore Ultralytics settings reset: Normale al primo avvio, ignorare.
<FILE_END>

<FILE_START path="backend\dataset.yaml">
# backend/dataset.yaml

# Percorso base dove si trovano i dati (relativo alla cartella backend)
path: datasets/id_cards

# Dove trovare le immagini di training (relativo a 'path')
train: train/images

# Dove trovare le immagini di validazione (relativo a 'path')
val: val/images

# Numero di classi (solo 1: il documento d'identit√† generico)
nc: 1

# Nomi delle classi
names:
  0: id_card
<FILE_END>

<FILE_START path="backend\main.py">
# backend/main.py
# --- FIX CRITICO WINDOWS ---
# Importiamo torch per primo per evitare conflitti DLL (WinError 127) 
# con altre lib come Paddle o OpenCV.
import os
import sys
try:
    import torch
except ImportError:
    pass
# ---------------------------

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.api.v1.endpoints import vision
from app.api.v1.endpoints import registration

app = FastAPI(title="AI Modular Backend", version="0.1.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
def read_root():
    return {"status": "active", "message": "Backend Operativo"}

# Rotte
app.include_router(vision.router, prefix="/api/v1/vision", tags=["AI Vision"])

# Nota: registration.router ha gi√† prefix interno "/registration"
# Risultato: /api/v1/registration/...
app.include_router(registration.router, prefix="/api/v1", tags=["Registration"])
<FILE_END>

<FILE_START path="backend\app\__init__.py">
<FILE_END>

<FILE_START path="backend\app\api\__init__.py">
<FILE_END>

<FILE_START path="backend\app\api\v1\api.py">
from fastapi import APIRouter

from app.api.v1.endpoints.ai import router as ai_router
from app.api.v1.endpoints.vision import router as vision_router

try:
    from app.api.v1.endpoints.registration import router as registration_router
except Exception:
    registration_router = None

try:
    from app.api.v1.endpoints.waivers import router as waivers_router
except Exception:
    waivers_router = None

api_router = APIRouter()

api_router.include_router(ai_router, prefix="/ai", tags=["ai"])
api_router.include_router(vision_router, prefix="/vision", tags=["vision"])

# IMPORTANTE: il router registration ha gi√† prefix interno "/registration"
# quindi qui NON aggiungiamo "/registration" per evitare doppio prefisso.
if registration_router:
    api_router.include_router(registration_router, prefix="", tags=["registration"])

if waivers_router:
    api_router.include_router(waivers_router, prefix="/waivers", tags=["waivers"])
<FILE_END>

<FILE_START path="backend\app\api\v1\__init__.py">
<FILE_END>

<FILE_START path="backend\app\api\v1\endpoints\registration.py">
from __future__ import annotations

from io import BytesIO
from typing import Optional

from fastapi import APIRouter, Body, File, Form, HTTPException, Query, UploadFile
from fastapi.responses import FileResponse
from PIL import Image

from app.schemas.registration import (
    DocumentScanResponse,
    RegistrationPayload,
    RegistrationSubmitResponse,
)
from app.services.local_vision_service import analyze_documents_locally
from app.services.registration.registration_service import RegistrationService

router = APIRouter(prefix="/registration", tags=["registration"])
service = RegistrationService()


def _open_image_bytes(content: bytes, filename: str) -> Image.Image:
    try:
        return Image.open(BytesIO(content)).convert("RGB")
    except Exception:
        raise HTTPException(status_code=400, detail=f"Immagine non valida: {filename}")


@router.post("/scan", response_model=DocumentScanResponse)
async def scan_document(
    front: UploadFile = File(...),
    back: Optional[UploadFile] = File(None),
    doc_type: str = Form("AUTO"),
):
    f_content = await front.read()
    front_img = _open_image_bytes(f_content, front.filename)

    back_img = None
    if back:
        b_content = await back.read()
        try:
            back_img = _open_image_bytes(b_content, back.filename)
        except Exception:
            back_img = None

    extracted = analyze_documents_locally(front_img, back_img, doc_type_hint=doc_type)

    if "error" in extracted:
        raise HTTPException(status_code=500, detail=extracted["error"])

    detected = extracted.get("tipo_documento", "ALTRO")
    mrz_nat = extracted.get("cittadinanza")

    return DocumentScanResponse(
        detected_doc_type=detected,
        mrz_nationality=mrz_nat,
        extracted=extracted,
    )


@router.post("/submit", response_model=RegistrationSubmitResponse)
async def submit_registration(
    payload: RegistrationPayload, 
    update_id: Optional[str] = Query(None, description="ID registrazione da aggiornare")
):
    try:
        # Passiamo update_id al service
        result = service.submit(payload, registration_id=update_id)
        return RegistrationSubmitResponse(
            registration_id=result.registration_id,
            timestamp_iso=result.timestamp_iso,
            pdf_filename=result.pdf_filename,
            emailed_to=result.emailed_to,
        )
    except FileNotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/details/{registration_id}")
async def get_registration_details(registration_id: str):
    """Restituisce il JSON completo per la modifica."""
    try:
        data = service.get_registration_details(registration_id)
        return data
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Registrazione non trovata")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/list")
async def list_registrations(
    limit: int = Query(200, ge=1, le=2000),
    offset: int = Query(0, ge=0),
    q: Optional[str] = Query(None, description="Filtro testuale (nome, cognome, email, id)"),
):
    items = service.list_registrations(limit=limit, offset=offset, query=q)
    return {"items": items}


@router.post("/{registration_id}/lock")
async def set_registration_lock(
    registration_id: str,
    body: dict = Body(...),
):
    locked = bool(body.get("locked", True))
    try:
        return service.set_locked(registration_id, locked)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="Registrazione non trovata")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{registration_id}/pdf")
async def get_pdf(registration_id: str):
    try:
        pdf_path = service.find_pdf_path(registration_id)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="PDF non trovato")

    return FileResponse(
        pdf_path,
        media_type="application/pdf",
        filename=f"registrazione_{registration_id}.pdf",
    )
<FILE_END>

<FILE_START path="backend\app\api\v1\endpoints\vision.py">
from fastapi import APIRouter, UploadFile, File, Form, HTTPException
from PIL import Image
import io
from app.services.local_vision_service import analyze_documents_locally

router = APIRouter()


@router.post("/analyze")
async def analyze_document(
    front: UploadFile = File(...),
    back: UploadFile = File(None),
    doc_type: str = Form("AUTO"),  # default pi√π sensato
    use_local: bool = Form(True),  # compat
):
    """
    Riceve le immagini e un hint opzionale sul tipo di documento.
    """
    # 1. Leggi fronte
    try:
        f_content = await front.read()
        front_image = Image.open(io.BytesIO(f_content)).convert("RGB")
    except Exception:
        raise HTTPException(status_code=400, detail="Immagine Fronte non valida")

    # 2. Leggi retro (se c'√®)
    back_image = None
    if back:
        try:
            b_content = await back.read()
            back_image = Image.open(io.BytesIO(b_content)).convert("RGB")
        except Exception:
            back_image = None

    hint = (doc_type or "AUTO").strip()
    print(f"üß† Analisi Vision avviata. Hint: {hint}")

    # ‚úÖ Passaggio POSIZIONALE (anti 'unexpected keyword argument' se cambiano i nomi)
    result = analyze_documents_locally(front_image, back_image, hint)

    return result
<FILE_END>

<FILE_START path="backend\app\api\v1\endpoints\waivers.py">
from __future__ import annotations

import os
from fastapi import APIRouter, HTTPException, Request, Query
from fastapi.responses import FileResponse

from app.services.waiver_service import (
    WaiverService,
    WaiverDraftRequest,
    WaiverDraftResponse,
    WaiverFinalizeRequest,
    WaiverFinalizeResponse,
)

router = APIRouter()


def _public_base_url(request: Request) -> str:
    # Se sei dietro reverse proxy, in produzione metteremo header forward.
    # Per ora ok cos√¨ in locale.
    return str(request.base_url).rstrip("/")


@router.post("/waivers/draft", response_model=WaiverDraftResponse)
def create_draft(req: WaiverDraftRequest, request: Request):
    try:
        svc = WaiverService()
        return svc.create_draft(req=req, public_base_url=_public_base_url(request))
    except ValueError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Errore draft: {e}")


@router.post("/waivers/{waiver_id}/finalize", response_model=WaiverFinalizeResponse)
def finalize(waiver_id: str, req: WaiverFinalizeRequest, request: Request):
    try:
        svc = WaiverService()
        return svc.finalize(waiver_id=waiver_id, req=req, public_base_url=_public_base_url(request))
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail="waiver_id non trovato")
    except ValueError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Errore finalize: {e}")


@router.get("/waivers/{waiver_id}/pdf")
def get_pdf(waiver_id: str, which: str = Query(default="final", pattern="^(draft|final)$")):
    # Nota: in produzione potresti voler mettere auth o token temporanei
    from pathlib import Path
    base = Path(__file__).resolve().parents[3] / "storage" / "waivers" / waiver_id
    pdf = base / ("draft.pdf" if which == "draft" else "final.pdf")
    if not pdf.exists():
        raise HTTPException(status_code=404, detail="PDF non trovato")
    return FileResponse(path=str(pdf), media_type="application/pdf", filename=f"{waiver_id}_{which}.pdf")
<FILE_END>

<FILE_START path="backend\app\api\v1\endpoints\__init__.py">
<FILE_END>

<FILE_START path="backend\app\schemas\registration.py">
from __future__ import annotations

from typing import Literal, Optional
from pydantic import BaseModel, Field, EmailStr, ConfigDict, model_validator
from datetime import datetime

CitizenshipChoice = Literal["ITALIANA", "NON_ITALIANA"]

DocType = Literal[
    "CIE",
    "CI_CARTACEA",
    "PATENTE_IT",
    "PASSAPORTO",
    "PERMESSO_SOGGIORNO",
    "ALTRO",
]

class LegalConsents(BaseModel):
    """
    Schema consensi con alias per compatibilit√† Frontend (camelCase).
    """
    privacy: bool = False
    informed_consent: bool = Field(False, alias="informedConsent")
    responsibility: bool = False
    tesseramento: bool = False
    
    photo: bool = Field(False, alias="photoConsent") 
    newsletter: bool = Field(False, alias="newsletterConsent")

    model_config = ConfigDict(populate_by_name=True)

class PersonData(BaseModel):
    """
    Dati anagrafici con alias per mapping diretto dallo Store Frontend.
    """
    model_config = ConfigDict(extra="allow", populate_by_name=True)

    nome: str = Field(..., min_length=1)
    cognome: str = Field(..., min_length=1)
    data_nascita: str = Field(..., description="dd/mm/yyyy")
    
    # Geografici
    stato_nascita: Optional[str] = None
    comune_nascita: Optional[str] = None
    
    stato_residenza: Optional[str] = None
    comune_residenza: Optional[str] = None
    indirizzo_residenza: Optional[str] = None 

    cittadinanza_scelta: Optional[CitizenshipChoice] = None

    # Documento
    tipo_documento: DocType = Field(..., description="Tipo documento obbligatorio")
    numero_documento: str = Field(..., min_length=2)
    scadenza_documento: str = Field(..., description="dd/mm/yyyy")

    source: Optional[str] = None
    
    # FIRME
    signature_base64: Optional[str] = Field(default=None, alias="signature")
    
    # NUOVO: Dati biometrici forensi (FEA)
    # Riceve la stringa JSON grezza dal frontend
    signature_biometrics: Optional[str] = Field(default=None, alias="signatureBiometrics")

    legal_consents: Optional[LegalConsents] = Field(default=None, alias="legal")

class ContactData(BaseModel):
    email: EmailStr
    telefono: str = Field(..., min_length=5)

class RegistrationPayload(BaseModel):
    """
    Payload registrazione completo.
    """
    model_config = ConfigDict(populate_by_name=True)

    language: str = "it"
    booking_id: Optional[str] = None

    tutor_participates: Optional[bool] = Field(default=None, alias="tutorParticipates")
    has_minors: Optional[bool] = Field(default=None, alias="hasMinors")

    is_minor: bool = False
    participant: PersonData
    guardian: Optional[PersonData] = None

    contact: ContactData
    
    # Legacy root legal, mantenuto per sicurezza
    legal: Optional[LegalConsents] = None

    signature_base64: str = Field(..., alias="signatureBase64")

    @model_validator(mode="after")
    def _validate(self):
        # 1. Validazione Consensi
        consents = self.participant.legal_consents or self.legal
        
        if not consents:
            raise ValueError(f"Consensi mancanti per {self.participant.nome}")

        if not consents.privacy:
            raise ValueError(f"Privacy Policy non accettata per {self.participant.nome}")
        if not consents.informed_consent:
            raise ValueError(f"Consenso informato non accettato per {self.participant.nome}")
        
        # 2. Minore e Guardian
        if self.is_minor and self.guardian is None:
            raise ValueError("Partecipante minorenne: guardian obbligatorio.")

        # 3. Validit√† Date
        self._check_date_format(self.participant.data_nascita, "Data nascita partecipante")
        self._check_date_format(self.participant.scadenza_documento, "Scadenza documento partecipante")
        
        if self.guardian:
            self._check_date_format(self.guardian.data_nascita, "Data nascita tutore")
            self._check_date_format(self.guardian.scadenza_documento, "Scadenza documento tutore")

        # 4. Firma (Controllo sulla firma root del payload)
        if not self.signature_base64 or len(self.signature_base64.strip()) < 20:
            raise ValueError("Firma principale mancante o non valida.")

        return self

    def _check_date_format(self, date_str: str, field_name: str):
        try:
            datetime.strptime(date_str, "%d/%m/%Y")
        except (ValueError, TypeError):
            raise ValueError(f"{field_name}: formato data non valido (richiesto GG/MM/AAAA)")

class DocumentScanResponse(BaseModel):
    detected_doc_type: DocType
    mrz_nationality: Optional[str] = None
    extracted: dict = Field(default_factory=dict)

class RegistrationSubmitResponse(BaseModel):
    registration_id: str
    timestamp_iso: str
    pdf_filename: str
    emailed_to: Optional[EmailStr] = None
<FILE_END>

<FILE_START path="backend\app\schemas\__init__.py">
<FILE_END>

<FILE_START path="backend\app\services\document_specs.py">
from __future__ import annotations
import re

# ==============================================================================
# DOCUMENT SPECIFICATIONS & REGEX KNOWLEDGE BASE
# Reference: Configurazione Nuovi Campi Documenti Stranieri.pdf (Sez. 3, 6.1)
# ==============================================================================

# Regex universale per date (dd/mm/yyyy, dd.mm.yyyy, dd-mm-yyyy)
# Fonte: Tabella 1, Sez 6.1 [cite: 887]
GENERIC_DATE_REGEX = re.compile(r"\b(0[1-9]|[12]\d|3[01])[-/.](0[1-9]|1[0-2])[-/.](19|20)\d{2}\b")

DOCUMENT_SPECS = {
    "CIE": {
        # Keywords per il "Promo Step" (Validazione preliminare) [cite: 726]
        "keywords": [
            "CARTA D'IDENTITA", 
            "IDENTITY CARD", 
            "REPUBBLICA ITALIANA",
            "MINISTERO DELL'INTERNO"
        ],
        # Regex Rigida CIE 3.0: Inizia con C, 1 lettera, 5 numeri, 2 lettere 
        "doc_number_regex": re.compile(r"\b[C][A-Z]\d{5}[A-Z]{2}\b"),
        "has_mrz": True,
        "required_sides": ["FRONT", "BACK"], # Retro obbligatorio per indirizzo 
        "date_format": "%d/%m/%Y",
        "description": "Carta d'Identit√† Elettronica Italiana"
    },

    "PATENTE_IT": {
        # Keywords identificative [cite: 773]
        "keywords": [
            "PATENTE DI GUIDA", 
            "DRIVING LICENSE", 
            "REPUBBLICA ITALIANA"
        ],
        # Regex Unificata: Formato Card (2L 7N 1L) O Formato U1 (U1 + 7+ alfanum) [cite: 781, 886]
        "doc_number_regex": re.compile(r"(?i)\b(U1[0-9A-Z]{7,}|[A-Z]{2}\d{7}[A-Z])\b"),
        "has_mrz": False,
        "required_sides": ["FRONT", "BACK"], # UPDATE: Retro reso obbligatorio per estrazione ente/indirizzo
        "date_format": "%d/%m/%Y",
        "description": "Patente di Guida Italiana"
    },

    "PASSAPORTO": {
        "keywords": [
            "PASSAPORTO", 
            "PASSPORT"
        ],
        # Standard Internazionale Generico (9 chars) o Italiano (2L 7N) 
        # Usiamo il pattern ICAO 9 chars come baseline robusta
        "doc_number_regex": re.compile(r"\b[A-Z0-9]{9}\b"),
        "has_mrz": True,
        "required_sides": ["FRONT"], # Indirizzo non affidabile su passaporto [cite: 764]
        "date_format": "%d %b %Y", # Es. 22 JAN 2026
        "description": "Passaporto Internazionale/Italiano"
    },

    "CI_CARTACEA": {
        "keywords": [
            "CARTA D'IDENTITA", 
            "REPUBBLICA ITALIANA", 
            "CONNOTATI"
        ],
        # Vecchio formato cartaceo: 2 lettere + 7 numeri (spesso con spazi)
        "doc_number_regex": re.compile(r"\b[A-Z]{2}\s?\d{7}\b"),
        "has_mrz": False,
        "required_sides": ["FRONT", "BACK"], # Dati sparsi su due lati
        "date_format": "%d/%m/%Y",
        "description": "Carta d'Identit√† Cartacea (Vecchio Modello)"
    },

    "PERMESSO_SOGGIORNO": {
        "keywords": [
            "PERMESSO DI SOGGIORNO", 
            "RESIDENCE PERMIT"
        ],
        # Pattern generico alphanumeric
        "doc_number_regex": re.compile(r"\b[A-Z0-9]{8,12}\b"),
        "has_mrz": True,
        "required_sides": ["FRONT", "BACK"], # UPDATE: Obbligatorio per sicurezza
        "date_format": "%d/%m/%Y",
        "description": "Permesso di Soggiorno"
    },

    "ALTRO": {
        "keywords": [],
        "doc_number_regex": None, # Nessuna validazione rigida, ci affidiamo a GLINER [cite: 892]
        "has_mrz": False,
        "required_sides": ["FRONT", "BACK"], # UPDATE: Obbligatorio per massimizzare info estratte
        "date_format": "%d/%m/%Y",
        "description": "Documento Generico / Estero non classificato"
    }
}

# Alias per CIE Europee generiche (mappate come logica light)
DOCUMENT_SPECS["CIE_EU"] = {
    "keywords": ["IDENTITY CARD", "PERSONALAUSWEIS", "CARTE D'IDENTITE"],
    "doc_number_regex": re.compile(r"\b[A-Z0-9]{8,12}\b"), # [cite: 833]
    "has_mrz": True,
    "required_sides": ["FRONT", "BACK"],
    "date_format": "%d/%m/%Y",
    "description": "Carta d'Identit√† UE (Non Italiana)"
}
<FILE_END>

<FILE_START path="backend\app\services\image_utils.py">
# backend/app/services/image_utils.py
import cv2
import numpy as np
import os
import time
import uuid
from pathlib import Path
from PIL import Image

# [FASE 2] Integrazione Libreria YOLO
try:
    from ultralytics import YOLO
    YOLO_AVAILABLE = True
except ImportError:
    YOLO_AVAILABLE = False
    print("‚ö†Ô∏è Ultralytics non installato. YOLO non disponibile.")

# --- CONFIGURAZIONE PERCORSI ROBUSTA ---
BASE_DIR = Path(__file__).resolve().parent.parent.parent
DEBUG_DIR = BASE_DIR / "storage" / "debug_captures"
DATASET_DIR = BASE_DIR / "storage" / "dataset_raw"
MODELS_DIR = BASE_DIR / "assets" / "models"

# Costanti per la standardizzazione ID-1 (formato carta di credito/CIE/Patente)
# Rapporto aspetto standard: 85.60mm / 53.98mm ‚âà 1.585
TARGET_WIDTH = 1000
TARGET_HEIGHT = 630 # 1000 / 1.585

try:
    DEBUG_DIR.mkdir(parents=True, exist_ok=True)
    DATASET_DIR.mkdir(parents=True, exist_ok=True)
    MODELS_DIR.mkdir(parents=True, exist_ok=True)
except Exception as e:
    print(f"‚ùå ERRORE CREAZIONE DIR: {e}")

# --- SINGLETON MODELLO YOLO ---
_yolo_model = None

def get_yolo_model():
    """
    Carica il modello YOLOv11n-OBB una volta sola (Singleton).
    """
    global _yolo_model
    if not YOLO_AVAILABLE:
        return None
        
    if _yolo_model is None:
        model_path = MODELS_DIR / "id_card_detector_v11n.pt"
        if model_path.exists():
            print(f"üß† [SETUP] Caricamento Modello YOLO da: {model_path}")
            try:
                _yolo_model = YOLO(str(model_path))
                print("üß† [SETUP] Modello caricato correttamente.")
            except Exception as e:
                print(f"‚ùå [SETUP] Errore caricamento pesi YOLO: {e}")
                return None
        else:
            print(f"‚ö†Ô∏è [SETUP] Modello YOLO non trovato in {model_path}. Esegui il training prima!")
            return None
    return _yolo_model

def order_points(pts):
    """
    Ordina le coordinate (top-left, top-right, bottom-right, bottom-left)
    necessario per il perspective warp corretto.
    """
    rect = np.zeros((4, 2), dtype="float32")
    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)] # TL
    rect[2] = pts[np.argmax(s)] # BR
    diff = np.diff(pts, axis=1)
    rect[1] = pts[np.argmin(diff)] # TR
    rect[3] = pts[np.argmax(diff)] # BL
    return rect

def isolate_document_yolo(image: Image.Image, debug_prefix: str = "yolo") -> Image.Image | None:
    """
    [FASE 2 STRATEGIA]
    Usa YOLOv11-OBB per rilevare il documento, trovare i 4 angoli 
    e applicare la correzione prospettica (Warp) su una griglia standardizzata.
    Include LOG DETTAGLIATI per debug.
    """
    print(f"\nüîç [YOLO DETECT] Avvio analisi su immagine sorgente ({debug_prefix})")
    
    model = get_yolo_model()
    if model is None:
        print("   ‚ùå [YOLO] Modello non caricato. Salto.")
        return None
    
    if image is None:
        print("   ‚ùå [YOLO] Immagine input vuota (None).")
        return None

    img_cv = pil_to_cv2(image)
    if img_cv is None: 
        print("   ‚ùå [YOLO] Conversione PIL->CV2 fallita.")
        return None

    # Inferenza (verbose=False per pulizia log, li facciamo noi manuali)
    results = model(img_cv, verbose=False)
    
    if not results or len(results) == 0:
        print(f"   ‚ùå [YOLO] Nessun risultato restituito dal modello.")
        return None

    r = results[0]
    
    # Controllo se √® OBB
    if r.obb is None or len(r.obb) == 0:
        print(f"   ‚ö†Ô∏è [YOLO] Nessun oggetto rilevato (OBB vuoto).")
        return None

    # Prendi il box con confidenza maggiore
    best_idx = int(r.obb.conf.argmax())
    conf = float(r.obb.conf[best_idx])
    
    # LOG CONFIDENZA
    print(f"   ‚úÖ [YOLO] Documento TROVATO! Confidenza: {conf:.4f}")
    
    # Estrazione angoli (xyxyxyxy)
    corners = r.obb.xyxyxyxy[best_idx].cpu().numpy()
    
    # LOG COORDINATE GREZZE
    print(f"      [YOLO] Angoli grezzi rilevati:\n{corners}")
    
    # 1. Ordina i punti rilevati: TL, TR, BR, BL
    rect = order_points(corners)
    (tl, tr, br, bl) = rect

    # 2. Calcola larghezza e altezza reali rilevate (per decidere l'orientamento)
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    detected_width = max(int(widthA), int(widthB))

    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    detected_height = max(int(heightA), int(heightB))
    
    # LOG DIMENSIONI
    print(f"      [YOLO] Dimensioni stimate crop: {detected_width}x{detected_height} px")

    # 3. Logica "Smart Orientation"
    final_w, final_h = TARGET_WIDTH, TARGET_HEIGHT
    
    # Se l'altezza rilevata √® maggiore della larghezza, la carta √® verticale (ruotata di 90 o 270)
    is_vertical = detected_height > detected_width
    
    if is_vertical:
            print(f"      [YOLO] üîÑ Rilevata carta VERTICALE (H > W). Preparo rotazione per OCR...")
            # Impostiamo il target del warp verticale (630x1000)
            warp_w, warp_h = TARGET_HEIGHT, TARGET_WIDTH 
    else:
            print(f"      [YOLO] ‚û°Ô∏è Rilevata carta ORIZZONTALE. Procedo standard.")
            # Impostiamo il target del warp orizzontale (1000x630)
            warp_w, warp_h = TARGET_WIDTH, TARGET_HEIGHT

    # Punti sorgente (dal detection)
    src_pts = rect
    
    # Punti destinazione (rettangolo perfetto)
    dst_dynamic = np.array([
        [0, 0],
        [warp_w - 1, 0],
        [warp_w - 1, warp_h - 1],
        [0, warp_h - 1]], dtype="float32")

    # Calcolo matrice e Warp
    M = cv2.getPerspectiveTransform(src_pts, dst_dynamic)
    warped = cv2.warpPerspective(img_cv, M, (warp_w, warp_h))
    
    # Se abbiamo fatto il warp verticale, ora ruotiamo di 90¬∞ per averla orizzontale
    if is_vertical:
        warped = cv2.rotate(warped, cv2.ROTATE_90_CLOCKWISE)
        print("      [YOLO] üîÑ Rotazione 90¬∞ applicata post-warp.")

    # A questo punto abbiamo SEMPRE un'immagine ~1000x630 orizzontale.
    _save_debug_step(warped, debug_prefix, "YOLO_WARP_HD")
    
    print(f"      [YOLO] ‚úÖ Operazione completata. Immagine pronta per OCR.")
    return cv2_to_pil(warped)


def save_raw_dataset_image(img, label: str):
    """
    Salva l'immagine grezza in storage/dataset_raw per il futuro training di YOLOv11.
    """
    if img is None: return
    try:
        unique_id = str(uuid.uuid4())[:8]
        ts = int(time.time())
        filename = f"{ts}_{unique_id}_{label}.jpg"
        path = DATASET_DIR / filename
        if isinstance(img, Image.Image):
            img.save(str(path), quality=95)
        else:
            cv2.imwrite(str(path), img)
    except Exception as e:
        print(f"   ‚ö†Ô∏è [DATASET ERROR]: {e}")

def _save_debug_step(img, prefix, step_name):
    if img is None: return None
    try:
        ts = int(time.time() * 1000)
        safe_prefix = "".join(c for c in prefix if c.isalnum() or c in ('_', '-'))
        filename = f"debug_{safe_prefix}_{ts}_{step_name}.jpg"
        path = DEBUG_DIR / filename
        if isinstance(img, Image.Image):
            img.save(str(path))
        else:
            cv2.imwrite(str(path), img)
        return filename
    except Exception as e:
        print(f"   ‚ùå [DEBUG ERROR] {step_name}: {e}")
        return None

def cv2_to_pil(img_cv):
    if img_cv is None: return None
    try:
        if len(img_cv.shape) == 2: return Image.fromarray(img_cv)
        if len(img_cv.shape) == 3 and img_cv.shape[2] == 3:
            return Image.fromarray(cv2.cvtColor(img_cv, cv2.COLOR_BGR2RGB))
        if len(img_cv.shape) == 3 and img_cv.shape[2] == 4:
            return Image.fromarray(cv2.cvtColor(img_cv, cv2.COLOR_BGRA2RGBA))
        return Image.fromarray(img_cv)
    except: return None

def pil_to_cv2(img_pil):
    try:
        if img_pil.mode != "RGB":
            img_pil = img_pil.convert("RGB")
        return cv2.cvtColor(np.array(img_pil), cv2.COLOR_RGB2BGR)
    except: return None

# --- FUNZIONI LEGACY/HELPER (Mantenute per retrocompatibilit√†) ---
def apply_clahe(image):
    try:
        if len(image.shape) == 3:
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        else:
            gray = image
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        return clahe.apply(gray)
    except:
        return image

def align_images_orb(image, template, max_features=5000, debug_prefix="align", mask=None):
    # Deprecato in favore di YOLO, ma mantenuto per sicurezza
    try:
        if image is None or template is None: return None
        h_tpl, w_tpl = template.shape[:2]
        h_img, w_img = image.shape[:2]
        scale_factor = 1.0
        working_image = image.copy()
        if w_img > w_tpl * 1.5:
            scale_factor = w_tpl / w_img
            new_w = int(w_img * scale_factor)
            new_h = int(h_img * scale_factor)
            working_image = cv2.resize(image, (new_w, new_h), interpolation=cv2.INTER_AREA)

        imgGray = apply_clahe(working_image)
        tmplGray = apply_clahe(template)
        orb = cv2.ORB_create(nfeatures=max_features)
        kpsA, descsA = orb.detectAndCompute(imgGray, None)
        kpsB, descsB = orb.detectAndCompute(tmplGray, mask=mask)

        if descsA is None or descsB is None: return None
        matcher = cv2.DescriptorMatcher_create(cv2.DESCRIPTOR_MATCHER_BRUTEFORCE_HAMMING)
        knn_matches = matcher.knnMatch(descsA, descsB, 2)
        good_matches = []
        for m, n in knn_matches:
            if m.distance < 0.75 * n.distance: good_matches.append(m)

        if len(good_matches) < 10: return None
        ptsA = np.zeros((len(good_matches), 2), dtype="float")
        ptsB = np.zeros((len(good_matches), 2), dtype="float")
        for (i, m) in enumerate(good_matches):
            ptsA[i] = np.array(kpsA[m.queryIdx].pt) * (1.0 / scale_factor)
            ptsB[i] = kpsB[m.trainIdx].pt

        (H, mask_ransac) = cv2.findHomography(ptsA, ptsB, method=cv2.RANSAC, ransacReprojThreshold=5.0)
        if H is None: return None
        (h, w) = template.shape[:2]
        aligned = cv2.warpPerspective(image, H, (w, h))
        return aligned
    except Exception as e:
        print(f"‚ùå ALIGN CRASH: {e}")
        return None

def enhance_image_for_mrz(pil_image, debug_prefix="mrz"):
    try:
        image = pil_to_cv2(pil_image)
        if image is None: return pil_image
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) if len(image.shape) == 3 else image
        h, w = gray.shape[:2]
        if w < 1000:
            scale = 2.0
            gray = cv2.resize(gray, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        gray = clahe.apply(gray)
        _, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
        thresh = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=1)
        return cv2_to_pil(thresh)
    except Exception: return pil_image

def enhance_field_crop(pil_image, debug_prefix="field"):
    try:
        image = pil_to_cv2(pil_image)
        if image is None: return pil_image
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) if len(image.shape) == 3 else image
        h, w = gray.shape[:2]
        if h < 60:
            scale = 2.0
            gray = cv2.resize(gray, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)
        gray = cv2.fastNlMeansDenoising(gray, None, 10, 7, 21)
        blur = cv2.GaussianBlur(gray, (25, 25), 0)
        norm = cv2.divide(gray, blur, scale=255)
        binary = cv2.adaptiveThreshold(norm, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 15, 5)
        return cv2_to_pil(binary)
    except Exception: return pil_image

def assess_image_quality(image_cv):
    if image_cv is None: return False, {"error": "No image"}
    try:
        gray = cv2.cvtColor(image_cv, cv2.COLOR_BGR2GRAY)
        blur_score = cv2.Laplacian(gray, cv2.CV_64F).var()
        mean_brightness = np.mean(gray)
        return True, {"blur": blur_score, "brightness": mean_brightness}
    except: return False, {}
<FILE_END>

<FILE_START path="backend\app\services\local_vision_service.py">
from __future__ import annotations
import os
import re
import time
import logging
import threading
import numpy as np
from datetime import datetime
from PIL import Image
from pathlib import Path

# Importiamo la Knowledge Base
from app.services.document_specs import DOCUMENT_SPECS, GENERIC_DATE_REGEX

# --- CONFIGURAZIONE AMBIENTALE ---
os.environ["FLAGS_use_mkldnn"] = "0"
os.environ["FLAGS_enable_mkldnn"] = "0"
os.environ["GLOG_minloglevel"] = "2"
os.environ["DISABLE_MODEL_SOURCE_CHECK"] = "True"

# POLICY DI RITENZIONE IMMAGINI (GDPR COMPLIANCE)
# 'NONE': Nessun salvataggio su disco (solo RAM) - Consigliato per produzione
# 'DEBUG': Salva su disco per debug, richiede pulizia periodica
ID_IMAGE_RETENTION = os.getenv("ID_IMAGE_RETENTION", "NONE")

logger = logging.getLogger("vision_service")
logger.setLevel(logging.INFO)
if not logger.handlers:
    handler = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

# --- IMPORT MODULI AI ---
try:
    import paddle
    from paddleocr import PaddleOCR
    paddle.set_device('cpu') 
    PADDLE_AVAILABLE = True
except ImportError as e:
    PADDLE_AVAILABLE = False
    logger.error(f"PaddleOCR non disponibile: {e}")

try:
    from gliner import GLiNER
    GLINER_AVAILABLE = True
except ImportError as e:
    GLINER_AVAILABLE = False
    logger.warning(f"GLINER non disponibile: {e}")

from app.services.image_utils import (
    isolate_document_yolo, 
    pil_to_cv2, 
    save_raw_dataset_image
)

# --- CONFIGURAZIONE SCHEMI DI ESTRAZIONE ---
STANDARD_SCHEMA = {
    "cognome": {"labels": ["Cognome", "Surname", "Last Name"], "threshold": 0.40, "type": "text"},
    "nome": {"labels": ["Nome", "Name", "Given Names"], "threshold": 0.40, "type": "text"},
    "data_nascita": {"labels": ["Data di nascita", "Birth Date", "Nato il"], "threshold": 0.30, "type": "date"},
    "comune_nascita": {"labels": ["Luogo di nascita", "Comune di nascita", "Place of Birth", "Nato a"], "threshold": 0.25, "type": "text"},
    "comune_residenza": {"labels": ["Comune di residenza", "Citt√†", "Residenza", "Abitazione", "Living in"], "threshold": 0.20, "type": "text"},
    "codice_fiscale": {"labels": ["Codice Fiscale", "Tax Code", "CF"], "threshold": 0.35, "type": "alphanum"},
    "numero_documento": {"labels": ["Numero Documento", "Card Number", "Document No"], "threshold": 0.30, "type": "alphanum"},
    "scadenza_documento": {"labels": ["Scadenza", "Valid until", "Expiry Date"], "threshold": 0.30, "type": "date"},
    "cittadinanza": {"labels": ["Cittadinanza", "Nationality"], "threshold": 0.45, "type": "text"}
}

# OTTIMIZZAZIONE PATENTE: Label numeriche standard UE
PATENTE_SCHEMA = {
    "cognome": {"labels": ["1.", "1 ", "Cognome"], "threshold": 0.25, "type": "text"},
    "nome": {"labels": ["2.", "2 ", "Nome"], "threshold": 0.25, "type": "text"},
    "data_nascita": {"labels": ["3.", "3 ", "Data di nascita"], "threshold": 0.25, "type": "date"},
    "comune_nascita": {"labels": ["3.", "3 ", "Luogo di nascita"], "threshold": 0.25, "type": "text"},
    "data_rilascio": {"labels": ["4a", "4a.", "4 a", "Rilascio"], "threshold": 0.25, "type": "date"},
    "scadenza_documento": {"labels": ["4b", "4b.", "46", "4 b", "Scadenza"], "threshold": 0.25, "type": "date"},
    "numero_documento": {"labels": ["5.", "5 ", "Numero Patente"], "threshold": 0.30, "type": "alphanum"},
    "ente_rilascio": {"labels": ["4c", "4c.", "Rilasciato da"], "threshold": 0.20, "type": "text"}
}

# NUOVO: SCHEMA VISIVO PASSAPORTO (Fallback quando MRZ fallisce o per dati extra)
PASSPORT_VISUAL_SCHEMA = {
    "cognome": {"labels": ["Surname", "Nom", "Cognome"], "threshold": 0.35, "type": "text"},
    "nome": {"labels": ["Given Names", "Prenoms", "Nome"], "threshold": 0.35, "type": "text"},
    "data_nascita": {"labels": ["Date of birth", "Date de naissance"], "threshold": 0.35, "type": "date"},
    "numero_documento": {"labels": ["Passport No", "Passeport N", "Document No"], "threshold": 0.40, "type": "alphanum"},
    "scadenza_documento": {"labels": ["Date of expiry", "Date d'expiration"], "threshold": 0.35, "type": "date"},
    "cittadinanza": {"labels": ["Nationality", "Nationalite", "Cittadinanza"], "threshold": 0.40, "type": "text"},
    "stato_nascita": {"labels": ["Place of birth", "Lieu de naissance", "Luogo di nascita"], "threshold": 0.25, "type": "text"}
}

BLACKLIST_VALUES = [
    "COGNOME", "NOME", "NATO", "IL", "RESIDENZA", "CITTADINANZA", 
    "LUOGO", "COMUNE", "VIA", "PIAZZA", "SCADENZA", "RILASCIO", "EMISSIONE", 
    "SURNAME", "NAME", "DATE", "BIRTH", "PLACE", "ADDRESS", "SEX", "F", "M",
    "REPUBBLICA", "ITALIANA", "MINISTERO", "INTERNO", "FISCAL", "CODE",
    "DRIVING", "LICENSE", "PERMESSO", "SOGGIORNO", "PASSPORT"
]

FRONT_ONLY_KEYS = ["nome", "cognome", "data_nascita", "comune_nascita", "numero_documento", "scadenza_documento", "cittadinanza"]
BACK_ONLY_KEYS = ["comune_residenza", "codice_fiscale"]

# Regex locale per date permissive (supporta 2 cifre anno)
# Es: 22/01/99 o 22.01.2024
BROAD_DATE_REGEX = re.compile(r"\b(0[1-9]|[12]\d|3[01])[-/.](0[1-9]|1[0-2])[-/.](?:19|20)?(\d{2})\b")

# -------------------------
# BACKEND CLASSES
# -------------------------
class PaddleBackend:
    _instance = None
    _lock = threading.Lock()
    model = None

    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = cls()
        return cls._instance

    def __init__(self):
        if not PADDLE_AVAILABLE: return
        logger.info("‚ö° Init PaddleOCR...")
        try:
            self.model = PaddleOCR(use_angle_cls=True, lang='it', enable_mkldnn=False, show_log=False, use_gpu=False)
            self.model.ocr(np.zeros((100, 100, 3), dtype=np.uint8), cls=True)
            logger.info("‚úÖ PaddleOCR Pronto.")
        except Exception as e:
            logger.critical(f"‚ùå Errore Init PaddleOCR: {e}")
            self.model = None

    def infer(self, img_array: np.ndarray):
        if not self.model: return None
        with self._lock: 
            try:
                return self.model.ocr(img_array, cls=True)
            except Exception as e:
                logger.error(f"Paddle Inference Crash: {e}")
                return None

class GlinerBackend:
    _model = None
    @classmethod
    def get_model(cls):
        if not GLINER_AVAILABLE: return None
        if cls._model is None:
            logger.info("üß† Caricamento GLINER...")
            try:
                cls._model = GLiNER.from_pretrained("urchade/gliner_medium-v2.1")
            except Exception as e:
                logger.error(f"Errore GLINER: {e}")
        return cls._model

# -------------------------
# HELPERS
# -------------------------
def _mrz_char_value(c):
    if '0' <= c <= '9': return int(c)
    if 'A' <= c <= 'Z': return ord(c) - 55
    return 0

def _calculate_mrz_checksum(value_str):
    weights = [7, 3, 1]
    total = 0
    for i, char in enumerate(value_str):
        val = _mrz_char_value(char)
        weight = weights[i % 3]
        total += val * weight
    return total % 10

def _validate_and_fix_mrz_field(raw_value, expected_check_digit):
    if not raw_value or not expected_check_digit.isdigit():
        return None, False
    if str(_calculate_mrz_checksum(raw_value)) == expected_check_digit:
        return raw_value, True
    corrections = {'O': '0', 'I': '1', 'Z': '2', 'S': '5', 'B': '8', 'D': '0'}
    fixed_val = list(raw_value)
    for i, char in enumerate(fixed_val):
        if char in corrections: fixed_val[i] = corrections[char]
    fixed_str = "".join(fixed_val)
    if str(_calculate_mrz_checksum(fixed_str)) == expected_check_digit:
        print(f"      üîß MRZ Checksum Fix: {raw_value} -> {fixed_str}")
        return fixed_str, True
    return raw_value, False

def _extract_mrz_data(text_blob: str, label: str = "GENERIC") -> dict:
    if not text_blob or len(text_blob) < 30: return {}

    print(f"\n    üïµÔ∏è [MRZ SCANNER - {label}] Analisi e Ricostruzione...")
    schema = {}
    
    compact_text = text_blob.replace(" ", "").replace("\n", "").upper()
    fuzzy_mrz = re.sub(r"[K¬´\(\{\[\¬£]", "<", compact_text)
    
    # 1. Numeri e Date
    # Pattern esteso per supportare ID-1 (3 righe) e ID-3 (Passaporto, 2 righe, inizia con P)
    # ID-3 Passaporto: P<ITA...
    ita_anchor = re.search(r"([ACIPV]<|[ACIPV])([A-Z]{3})", fuzzy_mrz)
    
    if ita_anchor:
        start_idx = ita_anchor.start()
        stream = fuzzy_mrz[start_idx:]
        anchor_len = len(ita_anchor.group(0))
        
        country_code = ita_anchor.group(2) 
        schema["stato_emittente"] = country_code
        
        # ID-3 Passaporto: Numero documento segue subito il codice paese (es. P<ITAYY1234567)
        raw_doc_num = stream[anchor_len : anchor_len+9]
        doc_check = stream[anchor_len+9 : anchor_len+10]
        
        val_doc, ok_doc = _validate_and_fix_mrz_field(raw_doc_num, doc_check)
        if ok_doc:
            schema["numero_documento"] = val_doc
            first_char = ita_anchor.group(0)[0]
            if first_char in ['C', 'I']: schema["tipo_documento"] = "CIE" if country_code == 'ITA' else "ID_CARD"
            elif first_char == 'P': schema["tipo_documento"] = "PASSAPORTO"
            print(f"      ‚úÖ DOC NUM VALIDATO: {val_doc}")
        elif re.match(r"^[A-Z0-9]{9}$", raw_doc_num):
            schema["numero_documento"] = raw_doc_num

        # Date: Nascita e Scadenza
        # ID-3: Le date sono sulla seconda riga nel formato:
        # [Num Personale opzionale] [Nascita YYMMDD][Check] [Sesso] [Scadenza YYMMDD][Check]
        # Cerchiamo pattern di date valide
        date_candidates = re.finditer(r"(\d{6})(\d)([MF<X])(\d{6})(\d)", stream)
        for match in date_candidates:
            birth_raw, birth_check, sex, expiry_raw, expiry_check = match.groups()
            
            # Data Nascita
            v_birth, ok_birth = _validate_and_fix_mrz_field(birth_raw, birth_check)
            if ok_birth:
                try:
                    yy, mm, dd = int(v_birth[:2]), int(v_birth[2:4]), int(v_birth[4:])
                    if 1 <= mm <= 12 and 1 <= dd <= 31:
                        curr_yy = int(datetime.now().strftime("%y"))
                        prefix = "19" if yy > (curr_yy + 5) else "20"
                        schema["data_nascita"] = f"{dd:02d}/{mm:02d}/{prefix}{yy:02d}"
                except: pass

            # Scadenza
            v_exp, ok_exp = _validate_and_fix_mrz_field(expiry_raw, expiry_check)
            candidate_exp = v_exp if ok_exp else expiry_raw
            
            try:
                yy, mm, dd = int(candidate_exp[:2]), int(candidate_exp[2:4]), int(candidate_exp[4:])
                if 1 <= mm <= 12 and 1 <= dd <= 31:
                    full_year = 2000 + yy
                    # Scadenza deve essere futura o recente
                    if full_year >= datetime.now().year - 5:
                        schema["scadenza_documento"] = f"{dd:02d}/{mm:02d}/{full_year}"
            except: pass
                
            if sex in ['M', 'F']:
                schema['sesso'] = sex

    # 2. NOMI DA MRZ
    # Cerca pattern tipo COGNOME<<NOME<SECONDO
    # ID-3 Passaporto: P<ITACOGNOME<<NOME sulla prima riga
    name_match = re.search(r"([A-Z]+(?:<[A-Z]+)*)<<([A-Z]+(?:<[A-Z]+)*)", fuzzy_mrz)
    if name_match:
        raw_sur = name_match.group(1).replace("<", " ").strip()
        raw_names = name_match.group(2).replace("<", " ").strip()
        
        # Filtra parole chiave comuni che finiscono nell'MRZ
        if "ITA" not in raw_sur and "REPUBBLICA" not in raw_sur and len(raw_sur) > 1: 
            schema["cognome"] = raw_sur.title()
            schema["nome"] = raw_names.title()
            print(f"      ‚úÖ NOMI MRZ: {schema['cognome']} {schema['nome']}")

    return schema

def _inject_spaces_in_address(text: str) -> str:
    patterns = [
        (r'(?i)(VIA|PIAZZA|CORSO|L\.GO|LARGO|V\.LE|VIALE|STRADA)(?=[A-Z0-9])', r'\1 '),
        (r'(?i)(N\.|NUM\.)(?=[0-9])', r'\1 '), 
        (r'(?i)([a-z])(N\.|NUM\.)', r'\1 \2'),
    ]
    for p, r in patterns:
        text = re.sub(p, r, text)
    
    text = re.sub(r'(\d+)([A-Z]{3,})', r'\1 \2', text) 
    text = re.sub(r'([A-Z]{3,})(\d+)', r'\1 \2', text)
    
    return text

def _clean_text_blob(ocr_result, label="UNK") -> str:
    print(f"\n   üìù [OCR RAW {label}] Analisi righe grezze (FULL):")
    if not ocr_result: return ""
    raw_lines = ocr_result[0] if isinstance(ocr_result, list) and len(ocr_result) > 0 else []
    if not raw_lines: return ""

    sorted_lines = sorted(raw_lines, key=lambda line: sum([p[1] for p in line[0]]) / 4)
    text_parts = []
    
    # MOD: Usiamo newline per mantenere la struttura, vitale per la logica posizionale "neighborhood"
    for i, line in enumerate(sorted_lines):
        txt = line[1][0].strip()
        if len(txt) > 1:
            txt_fixed = _inject_spaces_in_address(txt)
            text_parts.append(txt_fixed)
            print(f"      Line {i:02d}: {txt} -> {txt_fixed}")
            
    return "\n".join(text_parts)

def _smart_clean_field(raw_value: str, field_type: str, regex_pattern: re.Pattern | None = None) -> str | None:
    if not raw_value: return None
    val = raw_value.strip()
    
    # 1. VALIDAZIONE REGEX RIGIDA
    if regex_pattern:
        match = regex_pattern.search(val)
        if match:
            if match.groups():
                for g in match.groups():
                    if g: return g
            return match.group(0)
        else:
            # Secondo tentativo: rimuovi spazi per codici
            val_nospace = val.replace(" ", "")
            match = regex_pattern.search(val_nospace)
            if match: return match.group(0)
            
            # Se la regex fallisce, non ritorniamo nulla
            return None
    
    # 2. Pulizia standard per altri campi
    if field_type == "text":
        headers = ["CITTADINANZA", "LUOGO", "NASCITA", "NATA A", "TARTAA", "COMUNE", "RESIDENZA", "DI", "RILASCIATO", "DA"]
        for h in headers:
            val = re.sub(f"(?i){h}", "", val)
        val = re.sub(r"[^a-zA-Z√†√®√©√¨√≤√π√Ä√à√â√å√í√ô\s'\(\)-]", "", val) 
        return val.title().strip()
    
    elif field_type == "alphanum":
        return val.upper().replace(" ", "").replace(".", "").replace("-", "")
    
    elif field_type == "date":
        # Ottimizzazione Date Patente (spesso incollate tipo 14.05.20254c)
        val = val.replace("-", "/").replace(".", "/").replace("\\", "/")
        
        # Regex pi√π robusta per date sporche (Supporta 2 o 4 cifre anno)
        # Es: 22/01/99 -> 1999, 12/07/2017 -> 2017
        date_match = BROAD_DATE_REGEX.search(val)
        if date_match:
            d, m, y_part = date_match.group(1), date_match.group(2), date_match.group(3)
            
            # Gestione Anno a 2 o 4 cifre
            if len(y_part) == 4:
                final_year = y_part
            elif len(y_part) == 2:
                # Pivot: se > 50 √® 19xx, altrimenti 20xx
                y_val = int(y_part)
                prefix = "19" if y_val > 50 else "20"
                final_year = f"{prefix}{y_part}"
            else:
                return None # Formato strano

            return f"{d}/{m}/{final_year}"
            
        return None
    
    elif field_type == "address":
        val = re.sub(r"\s+", " ", val)
        val = re.sub(r"^(RESIDENZA|ABITAZIONE|INDIRIZZO)\s*", "", val, flags=re.IGNORECASE)
        return val.strip()
    return val

def _run_gliner_extraction(text_blob: str, target_keys: list[str] | None = None, schema_map: dict = STANDARD_SCHEMA, doc_specs: dict = None) -> dict:
    if not target_keys: return {}
    
    print(f"\n   üß† [GLINER AI] Inferenza su campi: {target_keys}")
    gliner = GlinerBackend.get_model()
    if not gliner: return {}
    
    all_labels = []
    label_to_key_map = {}
    
    for key in target_keys:
        config = schema_map.get(key)
        if config:
            for lbl in config["labels"]:
                all_labels.append(lbl)
                label_to_key_map[lbl] = key
            
    mapped = {}
    try:
        entities = gliner.predict_entities(text_blob, all_labels, threshold=0.10)
        entities.sort(key=lambda x: x['score'], reverse=True)
        
        for e in entities:
            raw_label = e['label']
            txt = e['text'].strip()
            score = e['score']
            
            if txt.upper() in BLACKLIST_VALUES or len(txt) < 2: continue
            canonical_key = label_to_key_map.get(raw_label)
            if not canonical_key: continue
            
            field_conf = schema_map[canonical_key]
            # Patente: threshold pi√π bassa perch√© i numeri confondono GLINER
            min_score = field_conf["threshold"]
            if score < min_score: continue
            
            if canonical_key not in mapped:
                spec_regex = None
                if canonical_key == "numero_documento" and doc_specs:
                    spec_regex = doc_specs.get("doc_number_regex")

                clean_val = _smart_clean_field(txt, field_conf["type"], regex_pattern=spec_regex)
                if clean_val:
                    mapped[canonical_key] = clean_val
                    print(f"      ‚úÖ {canonical_key}: {clean_val} (score {score:.2f})")
        return mapped
    except Exception as e:
        print(f"      ‚ùå GLINER Error: {e}")
        return {}

def _extract_and_repair_cf(text: str) -> str | None:
    digit_sim = r"[0-9OQILZASGB]"
    fuzzy_pattern = r"([A-Z]{6})(" + digit_sim + r"{2})([A-Z])(" + digit_sim + r"{2})([A-Z])(" + digit_sim + r"{3})([A-Z])"
    match = re.search(fuzzy_pattern, text.upper())
    if match:
        groups = list(match.groups())
        rep_map = {'O': '0', 'Q': '0', 'I': '1', 'L': '1', 'Z': '2', 'A': '4', 'S': '5', 'G': '6', 'B': '8'}
        for i in [1, 3, 5]:
            fixed = ""
            for char in groups[i]: fixed += rep_map.get(char, char)
            groups[i] = fixed
        final_cf = "".join(groups)
        print(f"      üîß CF REPAIR: {match.group(0)} -> {final_cf}")
        return final_cf
    return None

def _extract_all_dates(text_blob: str) -> list[str]:
    """
    Trova TUTTE le date possibili nel testo (dd/mm/yy o dd/mm/yyyy).
    Ritorna una lista di stringhe normalizzate DD/MM/YYYY.
    """
    found = []
    matches = BROAD_DATE_REGEX.findall(text_blob)
    for m in matches:
        d, month, y = m
        # Normalizza anno
        if len(y) == 2:
            y_val = int(y)
            prefix = "19" if y_val > 50 else "20"
            y = f"{prefix}{y}"
        
        normalized = f"{d}/{month}/{y}"
        found.append(normalized)
    return found

def _solve_dates_heuristic(dates: list[str]) -> dict:
    """
    Logica deduttiva per assegnare le date trovate ai campi corretti:
    - La pi√π vecchia -> Data Nascita
    - La pi√π futura -> Scadenza
    - L'intermedia -> Rilascio
    """
    if not dates: return {}
    
    # De-duplicate
    unique_dates = list(set(dates))
    
    # Converti in oggetti datetime per ordinare
    dt_objs = []
    for ds in unique_dates:
        try:
            dt = datetime.strptime(ds, "%d/%m/%Y")
            dt_objs.append((dt, ds))
        except: pass
        
    if not dt_objs: return {}
    
    # Ordina dal pi√π vecchio al pi√π nuovo
    dt_objs.sort(key=lambda x: x[0])
    sorted_dates = [x[1] for x in dt_objs]
    
    result = {}
    
    # 1. Nascita √® sempre la prima (pi√π vecchia)
    result["data_nascita"] = sorted_dates[0]
    
    # 2. Se abbiamo pi√π di 1 data
    if len(sorted_dates) >= 2:
        # L'ultima √® quasi sicuramente la scadenza (futuro)
        # Ma verifichiamo che sia nel futuro rispetto a "oggi" o molto recente
        last_dt = dt_objs[-1][0]
        if last_dt.year > datetime.now().year - 5: # Scadenza valida (non scaduta da secoli)
            result["scadenza_documento"] = sorted_dates[-1]
            
    # 3. Se abbiamo 3 date, quella in mezzo √® il rilascio
    if len(sorted_dates) >= 3:
        result["data_rilascio"] = sorted_dates[1]
    elif len(sorted_dates) == 2:
        # Se ne abbiamo solo 2 (Nascita e Scadenza), il rilascio manca.
        pass
        
    print(f"      üß† [DATE HEURISTIC] Sorted: {sorted_dates} -> {result}")
    return result

def _extract_patente_regex(text_lines: list[str]) -> dict:
    """
    Nuova logica posizionale basata sulle righe fisiche dell'OCR (Neighborhood Scan).
    Risolve il problema dei dati "scivolati" sopra o sotto l'etichetta.
    """
    print(f"\n   üèéÔ∏è [PATENTE LINE SCAN] Analisi posizionale su {len(text_lines)} righe...")
    data = {}
    
    # Parole da ignorare se trovate sopra/sotto un numero
    HEADERS_BLOCKLIST = ["REPUBBLICA", "ITALIANA", "PATENTE", "GUIDA", "COMUNITA", "UNIONE", "EUROPEA", "MODEL"]

    def is_header(s):
        u = s.upper()
        return any(k in u for k in HEADERS_BLOCKLIST)

    # Helper per validare candidati nome/cognome
    def is_valid_person_text(s):
        if len(s) < 2: return False
        if is_header(s): return False
        # Nomi e Cognomi non hanno parentesi (es. luogo nascita) o numeri (date)
        if re.search(r'[\(\)\d]', s): return False
        return True

    # Iteriamo sulle righe cercando i marker "1.", "2.", ecc.
    for i, line in enumerate(text_lines):
        clean_line = line.strip()
        
        # --- 1. COGNOME ---
        # Caso A: "1. COGNOME" sulla stessa riga
        match_inline = re.search(r'1\s*[\.,]?\s*([A-Z\s]+)', clean_line, re.IGNORECASE)
        if match_inline and len(match_inline.group(1)) > 2:
            candidate = match_inline.group(1).strip().title()
            if is_valid_person_text(candidate):
                data["cognome"] = candidate
                print(f"      ‚úÖ Cognome (Inline): {data['cognome']}")
        
        # Caso B: Riga √® solo "1." o "1"
        elif re.match(r'^1\s*[\.,]?$', clean_line):
            # STRATEGIA SMART PRIORITY: PRIMA guarda INDIETRO, POI AVANTI
            found = False
            
            # 1. Check Previous Line (per casi "Dato poi Etichetta")
            if i > 0:
                candidate_prev = text_lines[i-1].strip()
                if is_valid_person_text(candidate_prev):
                    data["cognome"] = candidate_prev.title()
                    print(f"      ‚úÖ Cognome (Previous Line): {data['cognome']}")
                    found = True

            # 2. Check Next Line (per casi "Etichetta poi Dato") - Solo se non trovato prima
            if not found and i < len(text_lines) - 1:
                candidate_next = text_lines[i+1].strip()
                if is_valid_person_text(candidate_next):
                    data["cognome"] = candidate_next.title()
                    print(f"      ‚úÖ Cognome (Next Line): {data['cognome']}")

        # --- 2. NOME ---
        # Caso A: "2. NOME" sulla stessa riga
        match_inline = re.search(r'2\s*[\.,]?\s*([A-Z\s]+)', clean_line, re.IGNORECASE)
        if match_inline and len(match_inline.group(1)) > 2:
            candidate = match_inline.group(1).strip().title()
            if is_valid_person_text(candidate):
                data["nome"] = candidate
                print(f"      ‚úÖ Nome (Inline): {data['nome']}")
        
        # Caso B: Riga √® solo "2."
        elif re.match(r'^2\s*[\.,]?$', clean_line):
            found = False
            
            # 1. Check Previous Line
            if i > 0:
                candidate_prev = text_lines[i-1].strip()
                # Evita di prendere il cognome se sono vicini
                if "1." not in candidate_prev and is_valid_person_text(candidate_prev):
                    if data.get("cognome", "").lower() != candidate_prev.lower():
                        data["nome"] = candidate_prev.title()
                        print(f"      ‚úÖ Nome (Previous Line): {data['nome']}")
                        found = True

            # 2. Check Next Line
            if not found and i < len(text_lines) - 1:
                candidate_next = text_lines[i+1].strip()
                if is_valid_person_text(candidate_next):
                    data["nome"] = candidate_next.title()
                    print(f"      ‚úÖ Nome (Next Line): {data['nome']}")

        # --- 5. NUMERO DOCUMENTO ---
        # Cerca ovunque nella riga un pattern patente valido
        match_doc = DOCUMENT_SPECS["PATENTE_IT"]["doc_number_regex"].search(clean_line)
        if match_doc:
            data["numero_documento"] = match_doc.group(0)
            print(f"      ‚úÖ Num Doc (Line Scan): {data['numero_documento']}")
        
        # --- COMUNE DI NASCITA ---
        # Pattern: Cerca stringhe tipo "MAGENTA (MI)" o "ROMA (RM)"
        # Regex: Parola (anche composta) seguita da (XX. Accetta anche senza parentesi chiusa.
        match_comune = re.search(r'([A-Z\s\']+?)\s*\(\s*([A-Z]{2})', clean_line)
        if match_comune:
            city = match_comune.group(1).strip()
            prov = match_comune.group(2).strip()
            # Filtra falsi positivi
            if len(city) > 2 and not is_header(city):
                data["comune_nascita"] = city.title()
                print(f"      ‚úÖ Comune Nascita (Pattern): {data['comune_nascita']} [{prov}]")

    return data

def _extract_passport_visual(text_lines: list[str]) -> dict:
    print(f"\n    üõÇ [PASSPORT VISUAL SCAN] Analisi posizionale su {len(text_lines)} righe...")
    data = {}
    
    # Helper per date strane dei passaporti (es. 08GIU/JUN2020)
    def clean_ppt_date(txt):
        txt = txt.upper().replace("O", "0").replace("Q", "0").replace(" ", "")
        # Cerca pattern DD MMM YYYY dove MMM sono lettere
        match = re.search(r"(\d{2})([A-Z]{3}).*?(\d{4})", txt)
        if match:
            d, m_str, y = match.groups()
            # Mappa mesi multilingua (ITA/ENG/FRA)
            months = {
                'GEN': '01', 'JAN': '01', 
                'FEB': '02', 'F√âV': '02',
                'MAR': '03', 
                'APR': '04', 'AVR': '04',
                'MAG': '05', 'MAY': '05', 'MAI': '05',
                'GIU': '06', 'JUN': '06', 'JUI': '06',
                'LUG': '07', 'JUL': '07', 'JUI': '07',
                'AGO': '08', 'AUG': '08', 'AO√õ': '08',
                'SET': '09', 'SEP': '09', 
                'OTT': '10', 'OCT': '10', 
                'NOV': '11', 
                'DIC': '12', 'DEC': '12', 'D√âC': '12'
            }
            # Cerca parziale
            for k, v in months.items():
                if k in m_str:
                    return f"{d}/{v}/{y}"

        # Fallback numeric
        return _smart_clean_field(txt, "date")

    for i, line in enumerate(text_lines):
        clean_line = line.strip().upper()
        
        # 1. COGNOME (sotto "Cognome/Surname")
        if "COGNOME" in clean_line or "SURNAME" in clean_line:
            if i < len(text_lines) - 1:
                val = text_lines[i+1].strip()
                if len(val) > 2 and "PASSEPORT" not in val: # Avoid noise
                    data["cognome"] = val.title()
                    print(f"      ‚úÖ Cognome (Visual): {data['cognome']}")

        # 2. NOME (sotto "Nome/Given Names")
        if "NOME" in clean_line and ("GIVEN" in clean_line or "PRENOMS" in clean_line):
            if i < len(text_lines) - 1:
                val = text_lines[i+1].strip()
                if len(val) > 2:
                    data["nome"] = val.title()
                    print(f"      ‚úÖ Nome (Visual): {data['nome']}")

        # 3. DATA NASCITA (sotto "Data di nascita")
        if "NASCITA" in clean_line and "DATA" in clean_line:
            if i < len(text_lines) - 1:
                val = text_lines[i+1].strip()
                dt = clean_ppt_date(val)
                if dt:
                    data["data_nascita"] = dt
                    print(f"      ‚úÖ Nascita (Visual): {dt}")

        # 4. LUOGO NASCITA (sotto "Luogo di nascita")
        if "LUOGO" in clean_line and "NASCITA" in clean_line:
            # A volte √® sulla stessa riga se l'OCR unisce, ma spesso sotto
            # Nel log: Line 16: Sesso...Luogo... -> Line 17: Autorita
            # Wait, log says: Line 16: Sesso...Luogo... 
            # Line 18: AOSTAAO (skip line 17 Autorita header?)
            # Sometimes values are 2 lines below if headers are wrapped.
            # Simple approach: Check i+1 and i+2
            candidates = []
            if i < len(text_lines) - 1: candidates.append(text_lines[i+1])
            if i < len(text_lines) - 2: candidates.append(text_lines[i+2])
            
            for cand in candidates:
                if len(cand.strip()) > 3 and not any(x in cand.upper() for x in ["AUTORITA", "AUTHORITY", "SESS"]):
                    data["comune_nascita"] = cand.strip().title()
                    print(f"      ‚úÖ Luogo Nascita (Visual): {data['comune_nascita']}")
                    break

        # 5. SCADENZA (sotto "Data di scadenza")
        if "SCADENZA" in clean_line and "DATA" in clean_line:
            if i < len(text_lines) - 1:
                val = text_lines[i+1].strip()
                dt = clean_ppt_date(val)
                if dt:
                    data["scadenza_documento"] = dt
                    print(f"      ‚úÖ Scadenza (Visual): {dt}")

        # 6. NUMERO PASSAPORTO (spesso prima riga o vicino a "Passaporto N")
        if "PASSAPORTO N" in clean_line:
             # Look around
             # Usually top right of page.
             pass
        
    # Fallback Numero Documento: Cerca pattern 9 chars alfanumerici nelle prime 3 righe
    if "numero_documento" not in data:
        for k in range(min(5, len(text_lines))):
            # Passaporto ITA: 2 lettere + 7 numeri
            m = re.search(r'\b([A-Z]{2}\d{7})\b', text_lines[k].upper())
            if m:
                data["numero_documento"] = m.group(1)
                print(f"      ‚úÖ Num Doc (Header Scan): {data['numero_documento']}")
                break

    return data

def _regex_fallback(text_blob: str, context: str = "ALL", doc_specs: dict = None) -> dict:
    schema = {}
    text_upper = text_blob.upper()
    text_compact = text_upper.replace(" ", "").replace("\n", "").replace(".", "").replace("-", "")
    
    # 1. CF con Riparazione
    if context in ["ALL", "BACK"]:
        cf_match = re.search(r'[A-Z]{6}\d{2}[A-Z]\d{2}[A-Z]\d{3}[A-Z]', text_compact)
        if cf_match:
            schema["codice_fiscale"] = cf_match.group(0)
            print(f"      üîß REGEX: Trovato CF: {cf_match.group(0)}")
        else:
            repaired = _extract_and_repair_cf(text_compact)
            if repaired: schema["codice_fiscale"] = repaired

    # 2. Doc Number Specifico
    if context in ["ALL", "FRONT"] and doc_specs:
        regex = doc_specs.get("doc_number_regex")
        if regex:
            match = regex.search(text_blob) or regex.search(text_upper)
            if match:
                val = match.group(0)
                if match.groups():
                    for g in match.groups():
                        if g: val = g; break
                schema["numero_documento"] = val.replace(" ", "")
                print(f"      üîß REGEX SPECIFICA: Trovato Doc Num: {schema['numero_documento']}")

    return schema

def _parse_cf_to_data(cf: str) -> dict:
    if len(cf) != 16: return {}
    data = {}
    try:
        yy = int(cf[6:8])
        month_map = {'A':1, 'B':2, 'C':3, 'D':4, 'E':5, 'H':6, 'L':7, 'M':8, 'P':9, 'R':10, 'S':11, 'T':12}
        mm = month_map.get(cf[8].upper())
        dd_val = int(cf[9:11])
        sex = 'M'
        dd = dd_val
        if dd_val > 40:
            sex = 'F'
            dd = dd_val - 40
        if mm and 1 <= dd <= 31:
            curr_year = datetime.now().year % 100
            prefix = "19" if yy > curr_year else "20"
            data["data_nascita"] = f"{dd:02d}/{mm:02d}/{prefix}{yy:02d}"
            data["sesso"] = sex
    except: pass
    return data

def verify_document_coherence(text_blob: str, doc_type: str) -> bool:
    specs = DOCUMENT_SPECS.get(doc_type)
    if not specs or not specs["keywords"]:
        return True 
    text_upper = text_blob.upper()
    for kw in specs["keywords"]:
        if kw in text_upper:
            print(f"     ‚úÖ [PROMO] Keyword trovata: {kw}")
            return True
    if specs.get("doc_number_regex") and specs["doc_number_regex"].search(text_upper):
        print(f"   ‚úÖ [PROMO] Keyword assente ma trovato numero documento valido.")
        return True
    print(f"   ‚ö†Ô∏è [PROMO] Nessuna keyword per {doc_type} trovata nel testo.")
    return False

def detect_nationality_context(text_blob: str, mrz_data: dict, doc_type_hint: str) -> bool:
    # Se il documento √® dichiarato Patente Italiana, √® italiana a prescindere dal testo OCR
    if doc_type_hint == "PATENTE_IT":
        return True
        
    if mrz_data.get("stato_emittente") == "ITA" or mrz_data.get("nationality") == "ITA":
        return True
        
    # Check testo OCR pi√π robusto (ignora spazi)
    text_compact = text_blob.upper().replace(" ", "")
    if "REPUBBLICAITALIANA" in text_compact or "CITTADINANZAITALIANA" in text_compact:
        return True
        
    return False

# -------------------------
# CORE PIPELINE
# -------------------------
def analyze_documents_locally(front_img: Image.Image, back_img: Image.Image | None = None, doc_type_hint: str = "AUTO") -> dict:
    debug_log = {"steps": [], "sources": {}}
    
    print("\n" + "="*80)
    print(f"üöÄ AVVIO ANALISI IBRIDA V7.12 GDPR-COMPLIANT [Time: {datetime.now().strftime('%H:%M:%S')}]")
    print(f"   Documento Dichiarato: {doc_type_hint}")
    print("="*80)
    
    final_data = {
        "source": "HYBRID_NEURAL_V7", 
        "tipo_documento": doc_type_hint if doc_type_hint != "AUTO" else "ALTRO"
    }
    
    # 0. Gestione Immagini (GDPR: Minimizzazione)
    # MODIFICA ESSENZIALE: Non salviamo di default su disco
    if ID_IMAGE_RETENTION == "DEBUG":
        if front_img: save_raw_dataset_image(front_img, f"{doc_type_hint}_FRONT")
        if back_img: save_raw_dataset_image(back_img, f"{doc_type_hint}_BACK")
        print("   ‚ö†Ô∏è WARNING: Salvataggio immagini RAW attivo (ID_IMAGE_RETENTION=DEBUG). Non usare in produzione.")
    else:
        print("   üîí GDPR: Immagini trattate in RAM e non persistite su disco (ID_IMAGE_RETENTION=NONE).")

    doc_specs = DOCUMENT_SPECS.get(doc_type_hint, DOCUMENT_SPECS["ALTRO"])
    paddle_engine = PaddleBackend.get_instance()
    ocr_texts = {"FRONT": "", "BACK": ""}
    
    # 1. OCR Scanning
    for side, img in [("FRONT", front_img), ("BACK", back_img)]:
        if not img: continue
        print(f"\n--- üì∏ ELABORAZIONE LATO: {side} ---")
        cropped = isolate_document_yolo(img, debug_prefix=side)
        target = cropped if cropped else img
        if paddle_engine:
            cv_img = pil_to_cv2(target)
            res = paddle_engine.infer(cv_img)
            text = _clean_text_blob(res, label=side)
            ocr_texts[side] = text
            debug_log[f"{side}_raw_ocr"] = text[:200]

    full_text = ocr_texts["FRONT"] + "\n" + ocr_texts["BACK"]

    # 2. PROMO Check
    if doc_type_hint not in ["AUTO", "ALTRO"]:
        is_coherent = verify_document_coherence(full_text, doc_type_hint)
        if not is_coherent:
            print("   ‚ùå [PROMO] Warning: Mismatch documento.")
            final_data["warning_mismatch"] = True

    # 3. MRZ Extraction (PRIORITARIA PER PASSAPORTO)
    mrz_data = {}
    
    # Se Patente, evitiamo MRZ per non sporcare i dati
    if doc_type_hint == "PATENTE_IT":
        print("   üö´ [MRZ] Saltato per Patente (Prevenzione garbage)")
    else:
        # Se Passaporto, la MRZ √® quasi sempre sul fronte o unica pagina
        if ocr_texts["FRONT"]:
            mrz_data = _extract_mrz_data(ocr_texts["FRONT"], label="FRONT")
        # Fallback retro (CIE)
        if not mrz_data and ocr_texts["BACK"]:
            mrz_data = _extract_mrz_data(ocr_texts["BACK"], label="BACK")

    # 4. Residence Context
    is_italian_resident = detect_nationality_context(full_text, mrz_data, doc_type_hint)
    print(f"   üåç Contesto Residenza: {'ITALIA' if is_italian_resident else 'ESTERO'}")
    
    # Selezione Schema AI
    if doc_type_hint == "PATENTE_IT":
        active_schema = PATENTE_SCHEMA
    elif doc_type_hint == "PASSAPORTO":
        active_schema = PASSPORT_VISUAL_SCHEMA 
    else:
        active_schema = STANDARD_SCHEMA
    
    target_front = list(FRONT_ONLY_KEYS)
    target_back = list(BACK_ONLY_KEYS)
    
    if not is_italian_resident:
        if "codice_fiscale" in target_back: target_back.remove("codice_fiscale")
        if "comune_residenza" in target_back: target_back.remove("comune_residenza")

    # 5. AI EXTRACTION
    ai_front_data = {}
    ai_back_data = {}

    # --- FRONTE ---
    if ocr_texts["FRONT"]:
        if doc_type_hint == "PATENTE_IT":
            # Logica Patente (Line Scan + Date Heuristic)
            lines = ocr_texts["FRONT"].split('\n')
            regex_patente = _extract_patente_regex(lines)
            ai_front_data.update(regex_patente)
            
            all_dates_front = _extract_all_dates(ocr_texts["FRONT"])
            all_dates_back = _extract_all_dates(ocr_texts["BACK"])
            combined_dates = all_dates_front + all_dates_back
            date_logic = _solve_dates_heuristic(combined_dates)
            ai_front_data.update(date_logic)
            
            missing_keys = [k for k in ["comune_nascita", "ente_rilascio"] if k not in ai_front_data]
            if missing_keys:
                gliner_data = _run_gliner_extraction(ocr_texts["FRONT"], target_keys=missing_keys, schema_map=active_schema, doc_specs=doc_specs)
                ai_front_data.update(gliner_data)
        
        elif doc_type_hint == "PASSAPORTO":
            # 1. Prova MRZ (Autorit√† Suprema)
            # Se MRZ ha trovato i dati, ottimo. Altrimenti attiva Fallback Visuale.
            
            # 2. Visual Fallback (Line Scan sui label ICAO)
            # Utile se MRZ √® illeggibile (es. crop sbagliato) o per dati mancanti (Luogo Nascita)
            lines = ocr_texts["FRONT"].split('\n')
            visual_ppt = _extract_passport_visual(lines)
            ai_front_data.update(visual_ppt)
            
            # 3. GLiNER come ultima spiaggia
            missing = [k for k in list(active_schema.keys()) if k not in ai_front_data]
            if missing:
                gliner_data = _run_gliner_extraction(ocr_texts["FRONT"], target_keys=missing, schema_map=active_schema, doc_specs=doc_specs)
                ai_front_data.update(gliner_data)
        
        else:
            # Standard (CIE, Altro)
            ai_front_data = _run_gliner_extraction(ocr_texts["FRONT"], target_keys=target_front, schema_map=active_schema, doc_specs=doc_specs)
        
        regex_front = _regex_fallback(ocr_texts["FRONT"], context="FRONT", doc_specs=doc_specs)
        for k, v in regex_front.items():
            if k not in ai_front_data: ai_front_data[k] = v
    
    # --- RETRO ---
    if ocr_texts["BACK"]:
        if doc_type_hint != "PATENTE_IT":
             ai_back_data = _run_gliner_extraction(ocr_texts["BACK"], target_keys=target_back, schema_map=active_schema, doc_specs=doc_specs)
        
        regex_back = _regex_fallback(ocr_texts["BACK"], context="BACK", doc_specs=doc_specs)
        ai_back_data.update(regex_back)

    # 6. MERGE STRATEGY (CRITICA)
    print("\n--- üèÜ MERGE DATI ---")
    
    raw_merged = {}
    
    # STRATEGIA A: PASSAPORTO -> MRZ VINCE SU TUTTO
    if doc_type_hint == "PASSAPORTO":
        # 1. MRZ (se c'√®)
        if mrz_data:
            print("   üëë [PASSAPORTO] MRZ √® l'autorit√† suprema.")
            for k, v in mrz_data.items():
                raw_merged[k] = (v, "MRZ")
        
        # 2. Visual Fill (riempie i buchi o tutto se MRZ manca)
        for k, v in ai_front_data.items():
            if k not in raw_merged:
                raw_merged[k] = (v, "AI_VISUAL_FILL")
    
    # STRATEGIA B: STANDARD -> MRZ > AI_FRONT > AI_BACK
    else:
        for k, v in mrz_data.items(): 
            if v: raw_merged[k] = (v, "MRZ")
        for k, v in ai_front_data.items(): 
            if v and k not in raw_merged: raw_merged[k] = (v, "AI_FRONT")
        for k, v in ai_back_data.items(): 
            if v and k not in raw_merged: raw_merged[k] = (v, "AI_BACK")

    # Trasferimento a final_data
    for k, (val, src) in raw_merged.items():
        final_data[k] = val
        debug_log["sources"][k] = src

    # E. CF Fallback
    if is_italian_resident and final_data.get("codice_fiscale") and not final_data.get("data_nascita"):
        math_data = _parse_cf_to_data(final_data["codice_fiscale"])
        if math_data.get("data_nascita"):
            final_data["data_nascita"] = math_data["data_nascita"]
            debug_log["sources"]["data_nascita"] = "MATH"

    # 7. VALIDAZIONE FINALE
    allowed_keys = {
        "nome", "cognome", "data_nascita", "stato_residenza", "stato_nascita",
        "tipo_documento", "numero_documento", "scadenza_documento", 
        "source", "_debug_info", "cittadinanza", "sesso", "warning_mismatch", "needs_review",
        "comune_nascita", "comune_residenza", "codice_fiscale"
    }

    if is_italian_resident:
        final_data["stato_residenza"] = "ITALIA"
        if doc_type_hint == "PATENTE_IT":
            final_data["comune_residenza"] = ""
            final_data["codice_fiscale"] = ""
    else:
        if not final_data.get("comune_residenza"):
            final_data["comune_residenza"] = final_data.get("stato_residenza") or "ESTERO"
            debug_log["sources"]["comune_residenza"] = "FALLBACK_FOREIGN"

    keys_to_remove = [k for k in final_data.keys() if k not in allowed_keys]
    for k in keys_to_remove: del final_data[k]

    # Log finale
    for k, v in final_data.items():
        if k not in ["source", "_debug_info"]:
            src = debug_log["sources"].get(k, "UNK")
            print(f"‚úÖ {k}: {v} [{src}]")

    final_data["_debug_info"] = debug_log
    return final_data
<FILE_END>

<FILE_START path="backend\app\services\waiver_mailer.py">
from __future__ import annotations

import os
import smtplib
from dataclasses import dataclass
from email.message import EmailMessage
from pathlib import Path
from typing import Optional


@dataclass(frozen=True)
class WaiverMailer:
    enabled: bool
    host: str
    port: int
    username: Optional[str]
    password: Optional[str]
    use_tls: bool
    mail_from: str

    @staticmethod
    def from_env() -> "WaiverMailer":
        enabled = os.getenv("SMTP_ENABLED", "false").lower() == "true"
        host = os.getenv("SMTP_HOST", "localhost")
        port = int(os.getenv("SMTP_PORT", "25"))
        username = os.getenv("SMTP_USER") or None
        password = os.getenv("SMTP_PASS") or None
        use_tls = os.getenv("SMTP_TLS", "false").lower() == "true"
        mail_from = os.getenv("SMTP_FROM", "noreply@localhost")
        return WaiverMailer(
            enabled=enabled,
            host=host,
            port=port,
            username=username,
            password=password,
            use_tls=use_tls,
            mail_from=mail_from,
        )

    def send_pdf(self, to_email: str, subject: str, body: str, pdf_path: Path) -> None:
        msg = EmailMessage()
        msg["Subject"] = subject
        msg["From"] = self.mail_from
        msg["To"] = to_email
        msg.set_content(body)

        data = pdf_path.read_bytes()
        msg.add_attachment(
            data,
            maintype="application",
            subtype="pdf",
            filename=pdf_path.name,
        )

        with smtplib.SMTP(self.host, self.port, timeout=30) as smtp:
            if self.use_tls:
                smtp.starttls()
            if self.username and self.password:
                smtp.login(self.username, self.password)
            smtp.send_message(msg)
<FILE_END>

<FILE_START path="backend\app\services\waiver_service.py">
from __future__ import annotations

import base64
import json
import os
import uuid
from dataclasses import dataclass
from datetime import datetime, date
from pathlib import Path
from typing import Literal, Optional, Dict, Any

from zoneinfo import ZoneInfo

from pydantic import BaseModel, Field, model_validator

from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.platypus import (
    SimpleDocTemplate,
    Paragraph,
    Spacer,
    Table,
    TableStyle,
    Image as RLImage,
)
from reportlab.lib import colors

from .waiver_mailer import WaiverMailer


TZ_ROME = ZoneInfo("Europe/Rome")


def _parse_ddmmyyyy(value: str) -> date:
    # accetta "DD/MM/YYYY"
    dd, mm_, yyyy = value.strip().split("/")
    return date(int(yyyy), int(mm_), int(dd))


def _calc_age(birth: date, on: date) -> int:
    years = on.year - birth.year
    if (on.month, on.day) < (birth.month, birth.day):
        years -= 1
    return years


class PersonaItalia(BaseModel):
    cittadinanza: Literal["ITA"] = "ITA"

    nome: str
    cognome: str
    comune_nascita: str
    data_nascita: str  # DD/MM/YYYY
    comune_residenza: str
    codice_fiscale: str

    tipo_documento: str
    numero_documento: str
    scadenza_documento: str  # DD/MM/YYYY

    email: str
    telefono: str


class PersonaEstera(BaseModel):
    cittadinanza: Literal["NON_ITA"] = "NON_ITA"

    nome: str
    cognome: str
    stato_nascita: str
    data_nascita: str  # DD/MM/YYYY
    stato_residenza: str

    tipo_documento: str
    numero_documento: str
    scadenza_documento: str  # DD/MM/YYYY

    email: str
    telefono: str


Persona = PersonaItalia | PersonaEstera


class WaiverDraftRequest(BaseModel):
    # dati del minore SEMPRE presenti se stiamo facendo la pratica ‚Äúminore‚Äù
    minore: Persona

    # richiesti SOLO se minore < 18 (validiamo server-side)
    genitore: Optional[Persona] = None

    # testo legale: in questa fase lo teniamo lato server, ma puoi anche passarlo dal client se vuoi.
    # qui lo lasciamo opzionale per poterlo aggiornare facilmente in futuro.
    waiver_title: str = "Modulo di scarico responsabilit√† / privacy / consenso informato"
    waiver_body: Optional[str] = None

    @model_validator(mode="after")
    def _validate_minor_guardian(self) -> "WaiverDraftRequest":
        today = datetime.now(TZ_ROME).date()
        dn = _parse_ddmmyyyy(self.minore.data_nascita)
        eta = _calc_age(dn, today)
        if eta < 18 and self.genitore is None:
            raise ValueError("Minore < 18: il campo 'genitore' √® obbligatorio.")
        return self


class WaiverDraftResponse(BaseModel):
    waiver_id: str
    created_at_iso: str
    is_minor: bool
    draft_pdf_path: str  # path su server (per debug / log)
    draft_pdf_url: str   # endpoint per scaricarlo


class WaiverFinalizeRequest(BaseModel):
    # firma SOLO genitore/tutore (PNG base64). Obbligatoria se minore < 18.
    signature_png_base64: Optional[str] = None

    # opzionale: se vuoi mandare anche a un indirizzo specifico (altrimenti usiamo email genitore)
    send_to_email: Optional[str] = None


class WaiverFinalizeResponse(BaseModel):
    waiver_id: str
    finalized_at_iso: str
    final_pdf_path: str
    final_pdf_url: str
    emailed_to: Optional[str] = None


@dataclass(frozen=True)
class WaiverPaths:
    root: Path
    meta_json: Path
    draft_pdf: Path
    final_pdf: Path
    signature_png: Path


class WaiverService:
    """
    Storage 100% locale:
      backend/app/storage/waivers/<waiver_id>/
         meta.json
         draft.pdf
         final.pdf
         signature.png
    """

    def __init__(self, storage_root: Optional[Path] = None, mailer: Optional[WaiverMailer] = None):
        base = storage_root or (Path(__file__).resolve().parents[1] / "storage" / "waivers")
        self.storage_root = base
        self.storage_root.mkdir(parents=True, exist_ok=True)

        self.mailer = mailer or WaiverMailer.from_env()

    def _paths(self, waiver_id: str) -> WaiverPaths:
        root = self.storage_root / waiver_id
        root.mkdir(parents=True, exist_ok=True)
        return WaiverPaths(
            root=root,
            meta_json=root / "meta.json",
            draft_pdf=root / "draft.pdf",
            final_pdf=root / "final.pdf",
            signature_png=root / "signature.png",
        )

    def create_draft(self, req: WaiverDraftRequest, public_base_url: str) -> WaiverDraftResponse:
        waiver_id = str(uuid.uuid4())
        paths = self._paths(waiver_id)

        now = datetime.now(TZ_ROME)
        today = now.date()
        minore_eta = _calc_age(_parse_ddmmyyyy(req.minore.data_nascita), today)
        is_minor = minore_eta < 18

        # testo legale (placeholder ‚Äúvero‚Äù ma breve: poi lo sostituisci con il testo ufficiale)
        waiver_body = req.waiver_body or (
            "DICHIARAZIONE:\n"
            "Il sottoscritto dichiara di aver ricevuto informativa privacy, di aver compreso i rischi "
            "connessi all'attivit√† e di sollevare l'organizzazione da responsabilit√† nei limiti di legge. "
            "Conferma inoltre la veridicit√† dei dati inseriti.\n\n"
            "PRIVACY:\n"
            "Autorizzo il trattamento dei dati personali per finalit√† organizzative e di sicurezza.\n\n"
            "CONSENSO INFORMATO:\n"
            "Dichiaro di aver compreso natura e rischi dell'attivit√† svolta."
        )

        meta: Dict[str, Any] = {
            "waiver_id": waiver_id,
            "created_at_iso": now.isoformat(),
            "is_minor": is_minor,
            "minore": req.minore.model_dump(),
            "genitore": req.genitore.model_dump() if req.genitore else None,
            "waiver_title": req.waiver_title,
            "waiver_body": waiver_body,
        }
        paths.meta_json.write_text(json.dumps(meta, ensure_ascii=False, indent=2), encoding="utf-8")

        self._render_pdf(
            out_path=paths.draft_pdf,
            meta=meta,
            signature_path=None,  # draft: niente firma
        )

        return WaiverDraftResponse(
            waiver_id=waiver_id,
            created_at_iso=now.isoformat(),
            is_minor=is_minor,
            draft_pdf_path=str(paths.draft_pdf),
            draft_pdf_url=f"{public_base_url.rstrip('/')}/api/v1/waivers/{waiver_id}/pdf?which=draft",
        )

    def finalize(self, waiver_id: str, req: WaiverFinalizeRequest, public_base_url: str) -> WaiverFinalizeResponse:
        paths = self._paths(waiver_id)
        if not paths.meta_json.exists():
            raise FileNotFoundError("waiver_id non trovato")

        meta = json.loads(paths.meta_json.read_text(encoding="utf-8"))
        is_minor = bool(meta.get("is_minor"))

        # Firma SOLO genitore/tutore: obbligatoria se minore
        if is_minor:
            if not req.signature_png_base64:
                raise ValueError("Minore: la firma del genitore/tutore √® obbligatoria (PNG base64).")
            self._save_signature_png(paths.signature_png, req.signature_png_base64)
            signature_path = paths.signature_png
        else:
            # se non √® minore, NON chiediamo firma (come da tua richiesta ‚Äúsolo firma genitore‚Äù)
            signature_path = None

        finalized_at = datetime.now(TZ_ROME)
        meta["finalized_at_iso"] = finalized_at.isoformat()
        paths.meta_json.write_text(json.dumps(meta, ensure_ascii=False, indent=2), encoding="utf-8")

        self._render_pdf(
            out_path=paths.final_pdf,
            meta=meta,
            signature_path=signature_path,
        )

        # invio email (se abilitato)
        emailed_to: Optional[str] = None
        if self.mailer.enabled:
            # preferenza: invia a req.send_to_email, altrimenti all‚Äôemail genitore (se presente),
            # altrimenti all‚Äôemail minore (caso adulto o edge).
            to_email = (
                (req.send_to_email or "").strip()
                or ((meta.get("genitore") or {}).get("email") or "").strip()
                or ((meta.get("minore") or {}).get("email") or "").strip()
            )
            if to_email:
                subject = f"Modulo firmato - {waiver_id}"
                body = "In allegato trovi il modulo compilato e firmato."
                self.mailer.send_pdf(to_email=to_email, subject=subject, body=body, pdf_path=paths.final_pdf)
                emailed_to = to_email

        return WaiverFinalizeResponse(
            waiver_id=waiver_id,
            finalized_at_iso=finalized_at.isoformat(),
            final_pdf_path=str(paths.final_pdf),
            final_pdf_url=f"{public_base_url.rstrip('/')}/api/v1/waivers/{waiver_id}/pdf?which=final",
            emailed_to=emailed_to,
        )

    def _save_signature_png(self, out_path: Path, signature_b64: str) -> None:
        # accetta sia base64 ‚Äúpuro‚Äù che data URL "data:image/png;base64,..."
        raw = signature_b64.strip()
        if raw.startswith("data:"):
            raw = raw.split(",", 1)[-1]
        data = base64.b64decode(raw)
        out_path.write_bytes(data)

    def _render_pdf(self, out_path: Path, meta: Dict[str, Any], signature_path: Optional[Path]) -> None:
        styles = getSampleStyleSheet()
        style_h = styles["Heading1"]
        style_b = styles["BodyText"]

        doc = SimpleDocTemplate(
            str(out_path),
            pagesize=A4,
            leftMargin=15 * mm,
            rightMargin=15 * mm,
            topMargin=15 * mm,
            bottomMargin=15 * mm,
            title="Waiver",
            author="Rafting Registration System",
        )

        elems = []

        title = meta.get("waiver_title", "Modulo")
        elems.append(Paragraph(title, style_h))
        elems.append(Spacer(1, 6 * mm))

        created_at_iso = meta.get("created_at_iso", "")
        finalized_at_iso = meta.get("finalized_at_iso", "")
        ts_line = f"Creato il: {created_at_iso}"
        if finalized_at_iso:
            ts_line += f" ‚Äî Firmato il: {finalized_at_iso}"
        elems.append(Paragraph(ts_line, style_b))
        elems.append(Spacer(1, 6 * mm))

        # Dati minore
        elems.append(Paragraph("<b>Dati partecipante (minore)</b>", styles["Heading3"]))
        elems.append(Spacer(1, 2 * mm))
        elems.extend(self._person_table(meta.get("minore") or {}))
        elems.append(Spacer(1, 6 * mm))

        # Dati genitore/tutore (se presenti)
        if meta.get("genitore"):
            elems.append(Paragraph("<b>Dati genitore/tutore</b>", styles["Heading3"]))
            elems.append(Spacer(1, 2 * mm))
            elems.extend(self._person_table(meta.get("genitore") or {}))
            elems.append(Spacer(1, 6 * mm))

        # Testo legale
        body = meta.get("waiver_body", "")
        for block in body.split("\n\n"):
            block = block.strip()
            if not block:
                continue
            safe = block.replace("\n", "<br/>")
            elems.append(Paragraph(safe, style_b))
            elems.append(Spacer(1, 4 * mm))

        elems.append(Spacer(1, 8 * mm))
        elems.append(Paragraph("<b>Firma genitore/tutore</b>", styles["Heading3"]))
        elems.append(Spacer(1, 2 * mm))

        # Area firma
        if signature_path and signature_path.exists():
            try:
                img = RLImage(str(signature_path), width=60 * mm, height=20 * mm)
            except Exception:
                img = Paragraph("(Firma non leggibile)", style_b)
        else:
            img = Paragraph("__________________________________________", style_b)

        sign_table = Table(
            [[img, Paragraph("Data: ____________________", style_b)]],
            colWidths=[90 * mm, 60 * mm],
        )
        sign_table.setStyle(
            TableStyle(
                [
                    ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
                    ("BOX", (0, 0), (0, 0), 0.5, colors.black),
                    ("LEFTPADDING", (0, 0), (-1, -1), 6),
                    ("RIGHTPADDING", (0, 0), (-1, -1), 6),
                    ("TOPPADDING", (0, 0), (-1, -1), 6),
                    ("BOTTOMPADDING", (0, 0), (-1, -1), 6),
                ]
            )
        )
        elems.append(sign_table)

        doc.build(elems)

    def _person_table(self, p: Dict[str, Any]) -> list:
        styles = getSampleStyleSheet()
        style_b = styles["BodyText"]

        # Normalizziamo campi ITA vs NON_ITA
        rows = []
        def add(label: str, key: str):
            val = (p.get(key) or "").strip() if isinstance(p.get(key), str) else (p.get(key) or "")
            if val:
                rows.append([Paragraph(f"<b>{label}</b>", style_b), Paragraph(str(val), style_b)])

        add("Nome", "nome")
        add("Cognome", "cognome")
        add("Cittadinanza", "cittadinanza")

        if p.get("cittadinanza") == "ITA":
            add("Comune di nascita", "comune_nascita")
            add("Comune di residenza", "comune_residenza")
            add("Codice fiscale", "codice_fiscale")
        else:
            add("Stato di nascita", "stato_nascita")
            add("Stato di residenza", "stato_residenza")

        add("Data di nascita", "data_nascita")
        add("Tipo documento", "tipo_documento")
        add("Numero documento", "numero_documento")
        add("Scadenza documento", "scadenza_documento")
        add("Email", "email")
        add("Telefono", "telefono")

        table = Table(rows, colWidths=[50 * mm, 120 * mm])
        table.setStyle(
            TableStyle(
                [
                    ("GRID", (0, 0), (-1, -1), 0.25, colors.grey),
                    ("VALIGN", (0, 0), (-1, -1), "TOP"),
                    ("LEFTPADDING", (0, 0), (-1, -1), 5),
                    ("RIGHTPADDING", (0, 0), (-1, -1), 5),
                    ("TOPPADDING", (0, 0), (-1, -1), 3),
                    ("BOTTOMPADDING", (0, 0), (-1, -1), 3),
                ]
            )
        )
        return [table]
<FILE_END>

<FILE_START path="backend\app\services\__init__.py">
<FILE_END>

<FILE_START path="backend\app\services\registration\email_service.py">
from __future__ import annotations

import os
import smtplib
from email.message import EmailMessage
from typing import Optional


class EmailService:
    def __init__(self):
        self.host = os.getenv("SMTP_HOST", "")
        self.port = int(os.getenv("SMTP_PORT", "587"))
        self.user = os.getenv("SMTP_USER", "")
        self.password = os.getenv("SMTP_PASS", "")
        self.use_starttls = os.getenv("SMTP_USE_STARTTLS", "true").lower() in ("1", "true", "yes")
        self.mail_from = os.getenv("SMTP_FROM", self.user)

    def is_configured(self) -> bool:
        return bool(self.host and self.port and self.mail_from)

    def send_pdf(self, to_email: str, subject: str, body: str, pdf_bytes: bytes, filename: str):
        if not self.is_configured():
            return

        msg = EmailMessage()
        msg["From"] = self.mail_from
        msg["To"] = to_email
        msg["Subject"] = subject
        msg.set_content(body)

        msg.add_attachment(pdf_bytes, maintype="application", subtype="pdf", filename=filename)

        with smtplib.SMTP(self.host, self.port, timeout=15) as smtp:
            if self.use_starttls:
                smtp.starttls()
            if self.user and self.password:
                smtp.login(self.user, self.password)
            smtp.send_message(msg)
<FILE_END>

<FILE_START path="backend\app\services\registration\mrz_native.py">
# backend/app/services/registration/mrz_native.py
from __future__ import annotations

import ctypes
import os
from dataclasses import dataclass
from typing import Optional


@dataclass(frozen=True)
class MrzParsed:
    format: str
    doc_type: str
    issuer: str
    nationality: str
    surname: str
    given_names: str
    document_number: str
    birth_date: str   # YYMMDD
    sex: str
    expiry_date: str  # YYMMDD


class MrzNative:
    def __init__(self):
        dll_path = os.getenv("MRZ_DLL_PATH", os.path.join("backend", "native", "mrz", "build", "mrz.dll"))
        self.dll_path = os.path.abspath(dll_path)
        self.lib = None

        if os.path.exists(self.dll_path):
            try:
                self.lib = ctypes.CDLL(self.dll_path)
                self.lib.mrz_parse_td3.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int]
                self.lib.mrz_parse_td3.restype = ctypes.c_int
                self.lib.mrz_parse_td1.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int]
                self.lib.mrz_parse_td1.restype = ctypes.c_int
            except Exception:
                self.lib = None

    def parse_td3(self, line1: str, line2: str) -> Optional[dict]:
        if not self.lib:
            return None
        out = ctypes.create_string_buffer(2048)
        ok = self.lib.mrz_parse_td3(line1.encode("utf-8"), line2.encode("utf-8"), out, ctypes.sizeof(out))
        if ok != 1:
            return None
        import json
        return json.loads(out.value.decode("utf-8"))

    def parse_td1(self, line1: str, line2: str, line3: str) -> Optional[dict]:
        if not self.lib:
            return None
        out = ctypes.create_string_buffer(2048)
        ok = self.lib.mrz_parse_td1(line1.encode("utf-8"), line2.encode("utf-8"), line3.encode("utf-8"), out, ctypes.sizeof(out))
        if ok != 1:
            return None
        import json
        return json.loads(out.value.decode("utf-8"))
<FILE_END>

<FILE_START path="backend\app\services\registration\pdf_service.py">
from __future__ import annotations

import base64
import re
from dataclasses import dataclass
from datetime import datetime
from io import BytesIO
from typing import Optional

from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm
from reportlab.pdfgen import canvas
from reportlab.lib.utils import ImageReader


@dataclass(frozen=True)
class PdfResult:
    filename: str
    pdf_bytes: bytes


class PdfService:
    def __init__(self, legal_text: Optional[str] = None):
        """
        Inizializza il servizio PDF.
        :param legal_text: Testo legale opzionale da includere (non ancora utilizzato nel layout, ma predisposto).
        """
        self.legal_text = legal_text

    def decode_signature_png(self, signature_base64: str) -> bytes:
        """
        Accetta sia base64 puro sia dataURL: data:image/png;base64,...
        """
        s = signature_base64.strip()
        m = re.match(r"^data:image\/png;base64,(.*)$", s)
        if m:
            s = m.group(1)
        return base64.b64decode(s)

    def generate(
        self,
        registration_id: str,
        timestamp: datetime,
        participant_block: str,
        guardian_block: Optional[str],
        consents_block: str,
        signature_png_bytes: bytes,
        signature_label: str,
    ) -> PdfResult:
        buf = BytesIO()
        c = canvas.Canvas(buf, pagesize=A4)
        w, h = A4

        y = h - 20 * mm
        c.setFont("Helvetica-Bold", 16)
        c.drawString(20 * mm, y, "Rafting Republic - Registrazione")
        y -= 8 * mm

        c.setFont("Helvetica", 10)
        c.drawString(20 * mm, y, f"ID: {registration_id}")
        y -= 5 * mm
        c.drawString(20 * mm, y, f"Data/Ora: {timestamp.isoformat()}")
        y -= 10 * mm

        c.setFont("Helvetica-Bold", 12)
        c.drawString(20 * mm, y, "Dati partecipante")
        y -= 6 * mm

        c.setFont("Helvetica", 10)
        for line in participant_block.splitlines():
            c.drawString(20 * mm, y, line[:120])
            y -= 4.5 * mm

        if guardian_block:
            y -= 4 * mm
            c.setFont("Helvetica-Bold", 12)
            c.drawString(20 * mm, y, "Dati genitore/tutore")
            y -= 6 * mm

            c.setFont("Helvetica", 10)
            for line in guardian_block.splitlines():
                c.drawString(20 * mm, y, line[:120])
                y -= 4.5 * mm

        y -= 4 * mm
        c.setFont("Helvetica-Bold", 12)
        c.drawString(20 * mm, y, "Consensi")
        y -= 6 * mm

        c.setFont("Helvetica", 10)
        for line in consents_block.splitlines():
            c.drawString(20 * mm, y, line[:120])
            y -= 4.5 * mm

        y -= 6 * mm
        c.setFont("Helvetica-Bold", 12)
        c.drawString(20 * mm, y, signature_label)
        y -= 6 * mm

        # firma
        try:
            img = ImageReader(BytesIO(signature_png_bytes))
            c.rect(20 * mm, y - 30 * mm, 80 * mm, 30 * mm)
            c.drawImage(img, 20 * mm, y - 30 * mm, width=80 * mm, height=30 * mm, preserveAspectRatio=True, mask='auto')
        except Exception:
            # Fallback se l'immagine non √® valida
            c.drawString(20 * mm, y - 10 * mm, "[Firma non valida]")

        c.showPage()
        c.save()

        pdf_bytes = buf.getvalue()
        filename = f"registrazione_{registration_id}.pdf"
        return PdfResult(filename=filename, pdf_bytes=pdf_bytes)
<FILE_END>

<FILE_START path="backend\app\services\registration\registration_service.py">
from __future__ import annotations

import os
import uuid
import json
from dataclasses import dataclass
from datetime import datetime
from zoneinfo import ZoneInfo

from app.schemas.registration import RegistrationPayload
from app.services.registration.email_service import EmailService
from app.services.registration.pdf_service import PdfService
from app.services.registration.storage_service import StorageService


def _parse_ddmmyyyy(s: str) -> datetime:
    """Helper per parsare date DD/MM/YYYY."""
    try:
        return datetime.strptime(s, "%d/%m/%Y")
    except ValueError:
        return datetime(2000, 1, 1)


def _calculate_age(birth_ddmmyyyy: str, now: datetime) -> int:
    b = _parse_ddmmyyyy(birth_ddmmyyyy).date()
    t = now.date()
    years = t.year - b.year - ((t.month, t.day) < (b.month, b.day))
    return years


def _safe_get(obj, key, default=None):
    """Helper universale per propriet√† Oggetti o chiavi Dizionari."""
    if obj is None:
        return default
    if isinstance(obj, dict):
        return obj.get(key, default)
    return getattr(obj, key, default)


def _fmt_consents_block(payload: RegistrationPayload) -> str:
    legal = _safe_get(payload, "legal")
    privacy = _safe_get(legal, "privacy")
    informed = _safe_get(legal, "informed_consent")
    resp = _safe_get(legal, "responsibility")
    tess = _safe_get(legal, "tesseramento")
    photo = _safe_get(legal, "photo")
    newsletter = _safe_get(legal, "newsletter")

    return "\n".join([
        f"Lingua: {_safe_get(payload, 'language')}",
        f"Privacy: {'SI' if privacy else 'NO'}",
        f"Consenso Inf.: {'SI' if informed else 'NO'}",
        f"Responsabilit√†: {'SI' if resp else 'NO'}",
        f"Tesseramento: {'SI' if tess else 'NO'}",
        f"Foto: {'SI' if photo else 'NO'}",
        f"Newsletter: {'SI' if newsletter else 'NO'}",
    ])


def _fmt_person_block(p) -> str:
    if not p:
        return ""
    
    nome = _safe_get(p, "nome", "")
    cognome = _safe_get(p, "cognome", "")
    nascita = _safe_get(p, "data_nascita", "")
    
    lines = [
        f"Nome: {nome}",
        f"Cognome: {cognome}",
        f"Nascita: {nascita}",
    ]
    
    cittadinanza = _safe_get(p, "cittadinanza_scelta")
    
    if cittadinanza == "ITALIANA":
        cf = _safe_get(p, "codice_fiscale") or _safe_get(_safe_get(p, "italian"), "codice_fiscale")
        if cf: lines.append(f"CF: {cf}")
            
    doc_type = _safe_get(p, "tipo_documento")
    doc_num = _safe_get(p, "numero_documento")
    
    if doc_type: lines.append(f"Doc: {doc_type}")
    if doc_num: lines.append(f"Num: {doc_num}")

    return "\n".join(lines)


def _fmt_full_participant_block(payload: RegistrationPayload, age: int) -> str:
    p = _safe_get(payload, "participant")
    base_info = _fmt_person_block(p)
    
    contact = _safe_get(payload, "contact")
    email = _safe_get(contact, "email")
    tel = _safe_get(contact, "telefono")

    contacts = []
    if email: contacts.append(f"Email: {email}")
    if tel: contacts.append(f"Tel: {tel}")
        
    consents = _fmt_consents_block(payload)
    
    return f"{base_info}\nEt√†: {age}\n" + "\n".join(contacts) + "\n\n=== CONSENSI ===\n" + consents


@dataclass(frozen=True)
class SubmitResult:
    registration_id: str
    timestamp_iso: str
    pdf_filename: str
    emailed_to: str | None


class RegistrationService:
    def __init__(self):
        tz = os.getenv("APP_TZ", "Europe/Rome")
        self.tz = ZoneInfo(tz)
        
        storage_dir = os.getenv("REGISTRATION_STORAGE_DIR", os.path.join("storage", "registrations"))
        self.storage = StorageService(storage_dir)
        
        self.pdf = PdfService(legal_text=os.getenv("LEGAL_TEXT", None))
        self.email = EmailService()

    def get_registration_details(self, registration_id: str) -> dict:
        if not self.storage.exists(registration_id):
            raise FileNotFoundError("Registrazione non trovata")
        
        paths = self.storage.create_registration_dir(registration_id)
        data = self.storage.load_json(paths.json_path)
        if not data:
            raise ValueError("Dati registrazione corrotti o vuoti")
        
        audit_logs = self.storage.load_json(paths.audit_path) or []
        data["audit_log"] = audit_logs

        return data

    def submit(self, payload: RegistrationPayload, registration_id: str | None = None) -> SubmitResult:
        now = datetime.now(self.tz)
        
        p = _safe_get(payload, "participant")
        data_nascita = _safe_get(p, "data_nascita", "01/01/2000")
        
        age = _calculate_age(data_nascita, now)
        is_minor = age < 18
        
        guardian = _safe_get(payload, "guardian")
    
        if is_minor and not guardian:
            raise ValueError("Partecipante minorenne: dati tutore mancanti.")

        # LOGICA UPDATE vs CREATE
        is_update = False
        if registration_id:
            if not self.storage.exists(registration_id):
                raise FileNotFoundError(f"Impossibile aggiornare: ID {registration_id} non esiste.")
            # ARCHIVIAZIONE VERSIONE PRECEDENTE (Snapshot)
            self.storage.archive_current_version(registration_id)
            is_update = True
        else:
            registration_id = str(uuid.uuid4())

        paths = self.storage.create_registration_dir(registration_id)

        # 1. SALVATAGGIO FIRMA GRAFICA (Immagine)
        sig_base64 = _safe_get(payload, "signature_base64", "")
        signature_png = self.pdf.decode_signature_png(sig_base64)
        self.storage.save_bytes(paths.signature_path, signature_png)

        # 2. SALVATAGGIO FIRMA BIOMETRICA (Vettoriale FEA) - NUOVO
        # Estraiamo i dati grezzi dal payload
        sig_bio_str = _safe_get(payload, "signature_biometrics")
        if sig_bio_str:
            try:
                # Se √® una stringa JSON, proviamo a parsare per validare, poi salviamo
                if isinstance(sig_bio_str, str):
                    bio_data = json.loads(sig_bio_str)
                    self.storage.save_json(paths.biometrics_path, bio_data)
                else:
                    # Se √® gi√† oggetto
                    self.storage.save_json(paths.biometrics_path, sig_bio_str)
            except Exception as e:
                print(f"Errore salvataggio biometrici: {e}")
                # Non blocchiamo il flusso, ma logghiamo
                self.storage.append_audit_log(registration_id, "BIO_ERROR", str(e))

        # 3. GENERAZIONE PDF
        participant_block = _fmt_full_participant_block(payload, age)
        guardian_block = _fmt_person_block(guardian) if is_minor and guardian else None
        consents_block = _fmt_consents_block(payload)
        signature_label = "Firma genitore/tutore" if is_minor else "Firma partecipante"

        pdf_result = self.pdf.generate(
            registration_id=registration_id,
            timestamp=now,
            participant_block=participant_block,
            guardian_block=guardian_block,
            consents_block=consents_block, 
            signature_png_bytes=signature_png,
            signature_label=signature_label,
        )
        self.storage.save_bytes(paths.pdf_path, pdf_result.pdf_bytes)

        # 4. SALVATAGGIO DATI JSON
        if hasattr(payload, 'model_dump'):
            payload_dict = payload.model_dump()
        else:
            payload_dict = dict(payload)

        payload_dict.update({
            "registration_id": registration_id,
            "timestamp_iso": now.isoformat(),
            "computed_age": age,
            "is_minor": is_minor,
            "locked": True
        })
        self.storage.save_json(paths.json_path, payload_dict)

        # 5. AUDIT LOG
        action_type = "UPDATE" if is_update else "CREATE"
        details = "Preferenze aggiornate" if is_update else "Nuova registrazione"
        self.storage.append_audit_log(registration_id, action_type, details)

        # 6. INVIO EMAIL
        emailed_to = None
        contact = _safe_get(payload, "contact")
        recipient = _safe_get(contact, "email")
        
        if recipient:
            try:
                subject_text = "Rafting Republic - Registrazione Aggiornata" if is_update else "Rafting Republic - Registrazione"
                body_text = "In allegato il documento aggiornato." if is_update else "In allegato il documento firmato."
                
                self.email.send_pdf(
                    to_email=str(recipient),
                    subject=subject_text,
                    body=body_text,
                    pdf_bytes=pdf_result.pdf_bytes,
                    filename=pdf_result.filename,
                )
                emailed_to = str(recipient)
                self.storage.append_audit_log(registration_id, "EMAIL_SENT", f"To: {emailed_to}")
            except Exception as e:
                self.storage.append_audit_log(registration_id, "EMAIL_ERROR", str(e))

        return SubmitResult(
            registration_id=registration_id,
            timestamp_iso=now.isoformat(),
            pdf_filename=pdf_result.filename,
            emailed_to=emailed_to,
        )

    def list_registrations(self, limit: int = 200, offset: int = 0, query: str | None = None) -> list[dict]:
        root = self.storage.storage_dir
        if not os.path.exists(root):
            return []

        q = (query or "").strip().lower()
        items = []

        try:
            entries = os.listdir(root)
        except OSError:
            return []

        for entry in entries:
            reg_dir = os.path.join(root, entry)
            if not os.path.isdir(reg_dir):
                continue
            
            payload_path = os.path.join(reg_dir, "payload.json")
            data = self.storage.load_json(payload_path)
            
            if not data:
                continue

            p = _safe_get(data, "participant", {})
            contact = _safe_get(data, "contact", {})
            
            reg_id = _safe_get(data, "registration_id", entry)
            nome = _safe_get(p, "nome", "")
            cognome = _safe_get(p, "cognome", "")
            email = _safe_get(contact, "email", "")
            
            searchable_text = f"{reg_id} {nome} {cognome} {email}".lower()
            if q and q not in searchable_text:
                continue

            items.append({
                "registration_id": reg_id,
                "timestamp_iso": _safe_get(data, "timestamp_iso"),
                "participant_nome": nome,
                "participant_cognome": cognome,
                "email": email,
                "is_minor": _safe_get(data, "is_minor", False),
                "locked": _safe_get(data, "locked", False),
            })

        items.sort(key=lambda x: x.get("timestamp_iso") or "", reverse=True)
        return items[offset : offset + limit]

    def set_locked(self, registration_id: str, locked: bool) -> dict:
        paths = self.storage.create_registration_dir(registration_id)
        data = self.storage.load_json(paths.json_path)
        
        if not data:
            raise FileNotFoundError("Registrazione non trovata")
        
        data["locked"] = locked
        self.storage.save_json(paths.json_path, data)
        
        self.storage.append_audit_log(registration_id, "LOCK_CHANGE", f"Locked: {locked}")
        
        return {"registration_id": registration_id, "locked": locked}

    def find_pdf_path(self, registration_id: str) -> str:
        paths = self.storage.create_registration_dir(registration_id)
        if os.path.exists(paths.pdf_path):
            return paths.pdf_path
        raise FileNotFoundError("PDF non trovato")
<FILE_END>

<FILE_START path="backend\app\services\registration\storage_service.py">
from __future__ import annotations

import json
import os
import shutil
import time
import hashlib
from dataclasses import dataclass
from pathlib import Path

@dataclass(frozen=True)
class RegistrationPaths:
    root: str
    json_path: str
    pdf_path: str
    signature_path: str
    biometrics_path: str # NUOVO
    audit_path: str
    history_dir: str

class StorageService:
    def __init__(self, storage_dir: str):
        self.storage_dir = storage_dir
        if not os.path.exists(self.storage_dir):
            os.makedirs(self.storage_dir, exist_ok=True)

    def create_registration_dir(self, registration_id: str) -> RegistrationPaths:
        reg_dir = os.path.join(self.storage_dir, registration_id)
        if not os.path.exists(reg_dir):
            os.makedirs(reg_dir, exist_ok=True)
        
        return RegistrationPaths(
            root=reg_dir,
            json_path=os.path.join(reg_dir, "payload.json"),
            pdf_path=os.path.join(reg_dir, "signed.pdf"),
            signature_path=os.path.join(reg_dir, "signature.png"),
            biometrics_path=os.path.join(reg_dir, "biometrics.json"), # NUOVO
            audit_path=os.path.join(reg_dir, "audit.json"),
            history_dir=os.path.join(reg_dir, "history")
        )

    def exists(self, registration_id: str) -> bool:
        path = os.path.join(self.storage_dir, registration_id, "payload.json")
        return os.path.exists(path)

    def archive_current_version(self, registration_id: str) -> None:
        """
        Sposta i file correnti in una cartella history/v_{timestamp}.
        Include anche i dati biometrici se presenti.
        """
        paths = self.create_registration_dir(registration_id)
        if not os.path.exists(paths.json_path): return

        if not os.path.exists(paths.history_dir):
            os.makedirs(paths.history_dir, exist_ok=True)

        version_name = f"v_{int(time.time())}"
        version_dir = os.path.join(paths.history_dir, version_name)
        os.makedirs(version_dir, exist_ok=True)

        try:
            # Copia file standard
            if os.path.exists(paths.json_path):
                shutil.copy2(paths.json_path, os.path.join(version_dir, "payload.json"))
            if os.path.exists(paths.pdf_path):
                shutil.copy2(paths.pdf_path, os.path.join(version_dir, "signed.pdf"))
            if os.path.exists(paths.signature_path):
                shutil.copy2(paths.signature_path, os.path.join(version_dir, "signature.png"))
            
            # Copia file biometrico (NUOVO)
            if os.path.exists(paths.biometrics_path):
                shutil.copy2(paths.biometrics_path, os.path.join(version_dir, "biometrics.json"))
                
        except Exception as e:
            print(f"Errore archiviazione storico {registration_id}: {e}")

    def append_audit_log(self, registration_id: str, action: str, details: str = ""):
        paths = self.create_registration_dir(registration_id)
        
        previous_hash = "0000000000000000000000000000000000000000000000000000000000000000"
        logs = []

        if os.path.exists(paths.audit_path):
            try:
                with open(paths.audit_path, "r", encoding="utf-8") as f:
                    logs = json.load(f)
                    if logs and isinstance(logs, list) and len(logs) > 0:
                        last_entry = logs[-1]
                        previous_hash = last_entry.get("hash", previous_hash)
            except Exception:
                logs = []

        entry = {
            "timestamp": time.time(),
            "iso_date": time.strftime("%Y-%m-%dT%H:%M:%S%z"),
            "action": action,
            "details": details,
            "previous_hash": previous_hash
        }
        
        entry_string = json.dumps(entry, sort_keys=True)
        current_hash = hashlib.sha256(entry_string.encode("utf-8")).hexdigest()
        entry["hash"] = current_hash
        
        logs.append(entry)
        
        temp_path = f"{paths.audit_path}.tmp"
        with open(temp_path, "w", encoding="utf-8") as f:
            json.dump(logs, f, ensure_ascii=False, indent=2)
        
        os.replace(temp_path, paths.audit_path)

    def save_bytes(self, path: str, data: bytes):
        with open(path, "wb") as f:
            f.write(data)

    def save_json(self, path: str, data: dict):
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

    def load_json(self, path: str) -> dict | None:
        if not os.path.exists(path): return None
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return None
<FILE_END>

<FILE_START path="backend\storage\daily_freezes\freeze_report_2026-02-09.json">
{
  "freeze_date": "2026-02-09",
  "generated_at": "2026-02-09T21:40:30.534807",
  "registrations": [
    {
      "id": "151564a6-3ef8-4426-9b04-1b538b6d241f",
      "files": {
        "signed.pdf": "df1838f623fad38c9b70b8815c9a46e96c0d1593902274cf4af94907075a1b47",
        "audit.json": "ad9315002d900a4860f899dd3d5fcf1096880cac63cd4293fe4619646fd840f7",
        "payload.json": "3f08e7771a92216bb9c7c8e14809ad92b83793d30e6279c12b0b24670d09e325"
      }
    }
  ],
  "total_files": 3,
  "cumulative_hash": "1d92ea5d196712ba4d86391fa717d41c2f93d297e5efd5fb75bc179e79192a6e"
}
<FILE_END>

<FILE_START path="backend\storage\registrations\151564a6-3ef8-4426-9b04-1b538b6d241f\audit.json">
[
  {
    "timestamp": 1770647937.3990805,
    "iso_date": "2026-02-09T15:38:57+0100",
    "action": "CREATE",
    "details": "Nuova registrazione",
    "previous_hash": "0000000000000000000000000000000000000000000000000000000000000000",
    "hash": "33528bd7ddc630acb889f04e2588b9c4175f37125d9678039ef9ced568f75644"
  },
  {
    "timestamp": 1770647937.4227793,
    "iso_date": "2026-02-09T15:38:57+0100",
    "action": "EMAIL_SENT",
    "details": "To: theo.bellotti@live.it",
    "previous_hash": "33528bd7ddc630acb889f04e2588b9c4175f37125d9678039ef9ced568f75644",
    "hash": "d4c09ad39bcd8c858db4e89619782a1d4058da6071d634a750faa88a8443ff10"
  }
]
<FILE_END>

<FILE_START path="backend\storage\registrations\151564a6-3ef8-4426-9b04-1b538b6d241f\payload.json">
{
  "language": "it",
  "booking_id": null,
  "tutor_participates": true,
  "has_minors": false,
  "is_minor": false,
  "participant": {
    "nome": "dcxsa",
    "cognome": "Hnosshoioh",
    "data_nascita": "22/01/1999",
    "stato_nascita": "ITALIA",
    "comune_nascita": "dxsa",
    "stato_residenza": "ITALIA",
    "comune_residenza": "Vigevano",
    "indirizzo_residenza": null,
    "cittadinanza_scelta": null,
    "tipo_documento": "CIE",
    "numero_documento": "IRMADELTI",
    "scadenza_documento": "14/02/2022",
    "source": "OCR_HYBRID",
    "signature_base64": "data:image/png;base64,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",
    "signature_biometrics": "[{\"x\":306,\"y\":106,\"t\":0,\"type\":0},{\"x\":305,\"y\":106,\"t\":11,\"type\":1},{\"x\":305,\"y\":107,\"t\":78,\"type\":1},{\"x\":305,\"y\":108,\"t\":95,\"type\":1},{\"x\":305,\"y\":109,\"t\":129,\"type\":1},{\"x\":315,\"y\":104,\"t\":145,\"type\":1},{\"x\":327,\"y\":98,\"t\":162,\"type\":1},{\"x\":338,\"y\":89,\"t\":177,\"type\":1},{\"x\":345,\"y\":78,\"t\":193,\"type\":1},{\"x\":347,\"y\":67,\"t\":210,\"type\":1},{\"x\":347,\"y\":60,\"t\":227,\"type\":1},{\"x\":341,\"y\":53,\"t\":243,\"type\":1},{\"x\":330,\"y\":48,\"t\":260,\"type\":1},{\"x\":315,\"y\":48,\"t\":277,\"type\":1},{\"x\":298,\"y\":51,\"t\":293,\"type\":1},{\"x\":277,\"y\":66,\"t\":311,\"type\":1},{\"x\":261,\"y\":86,\"t\":328,\"type\":1},{\"x\":252,\"y\":115,\"t\":345,\"type\":1},{\"x\":251,\"y\":130,\"t\":360,\"type\":1},{\"x\":256,\"y\":138,\"t\":378,\"type\":1},{\"x\":269,\"y\":142,\"t\":393,\"type\":1},{\"x\":290,\"y\":143,\"t\":410,\"type\":1},{\"x\":308,\"y\":143,\"t\":426,\"type\":1},{\"x\":322,\"y\":139,\"t\":443,\"type\":1},{\"x\":334,\"y\":130,\"t\":461,\"type\":1},{\"x\":345,\"y\":113,\"t\":479,\"type\":1},{\"x\":346,\"y\":106,\"t\":493,\"type\":1},{\"x\":344,\"y\":101,\"t\":510,\"type\":1},{\"x\":330,\"y\":97,\"t\":526,\"type\":1},{\"x\":304,\"y\":90,\"t\":543,\"type\":1},{\"x\":285,\"y\":87,\"t\":560,\"type\":1},{\"x\":278,\"y\":86,\"t\":577,\"type\":1},{\"x\":278,\"y\":85,\"t\":593,\"type\":1},{\"x\":281,\"y\":85,\"t\":610,\"type\":1},{\"x\":306,\"y\":85,\"t\":627,\"type\":1},{\"x\":403,\"y\":94,\"t\":643,\"type\":1},{\"x\":478,\"y\":110,\"t\":660,\"type\":1},{\"x\":518,\"y\":119,\"t\":677,\"type\":1},{\"x\":535,\"y\":125,\"t\":693,\"type\":1},{\"x\":535,\"y\":126,\"t\":709,\"type\":1},{\"x\":527,\"y\":126,\"t\":726,\"type\":1},{\"x\":481,\"y\":122,\"t\":743,\"type\":1},{\"x\":439,\"y\":114,\"t\":760,\"type\":1},{\"x\":397,\"y\":107,\"t\":777,\"type\":1},{\"x\":379,\"y\":103,\"t\":793,\"type\":1},{\"x\":380,\"y\":103,\"t\":844,\"type\":1},{\"x\":385,\"y\":103,\"t\":861,\"type\":1},{\"x\":388,\"y\":103,\"t\":877,\"type\":1},{\"x\":387,\"y\":103,\"t\":910,\"type\":1},{\"x\":355,\"y\":103,\"t\":927,\"type\":1},{\"x\":323,\"y\":105,\"t\":943,\"type\":1},{\"x\":294,\"y\":105,\"t\":960,\"type\":1},{\"x\":279,\"y\":105,\"t\":976,\"type\":1},{\"x\":277,\"y\":105,\"t\":993,\"type\":1},{\"x\":278,\"y\":104,\"t\":1010,\"type\":1},{\"x\":326,\"y\":101,\"t\":1027,\"type\":1},{\"x\":360,\"y\":100,\"t\":1043,\"type\":1},{\"x\":445,\"y\":98,\"t\":1060,\"type\":1},{\"x\":484,\"y\":97,\"t\":1077,\"type\":1},{\"x\":499,\"y\":97,\"t\":1093,\"type\":1},{\"x\":500,\"y\":97,\"t\":1110,\"type\":1},{\"x\":496,\"y\":97,\"t\":1163,\"type\":1},{\"x\":471,\"y\":97,\"t\":1177,\"type\":1},{\"x\":426,\"y\":107,\"t\":1193,\"type\":1},{\"x\":364,\"y\":122,\"t\":1210,\"type\":1},{\"x\":322,\"y\":137,\"t\":1227,\"type\":1},{\"x\":297,\"y\":146,\"t\":1244,\"type\":1},{\"x\":296,\"y\":146,\"t\":1260,\"type\":1},{\"x\":297,\"y\":146,\"t\":1283,\"type\":1},{\"x\":301,\"y\":146,\"t\":1293,\"type\":1},{\"x\":311,\"y\":144,\"t\":1310,\"type\":1},{\"x\":328,\"y\":136,\"t\":1326,\"type\":1},{\"x\":347,\"y\":126,\"t\":1343,\"type\":1},{\"x\":370,\"y\":110,\"t\":1360,\"type\":1},{\"x\":387,\"y\":96,\"t\":1377,\"type\":1},{\"x\":402,\"y\":79,\"t\":1393,\"type\":1},{\"x\":414,\"y\":62,\"t\":1410,\"type\":1},{\"x\":417,\"y\":55,\"t\":1427,\"type\":1},{\"x\":417,\"y\":51,\"t\":1444,\"type\":1},{\"x\":417,\"y\":50,\"t\":1460,\"type\":1},{\"x\":416,\"y\":52,\"t\":1483,\"type\":1},{\"x\":412,\"y\":57,\"t\":1493,\"type\":1},{\"x\":392,\"y\":84,\"t\":1510,\"type\":1},{\"x\":364,\"y\":124,\"t\":1527,\"type\":1},{\"x\":373,\"y\":143,\"t\":1677,\"type\":1},{\"x\":384,\"y\":130,\"t\":1693,\"type\":1},{\"x\":394,\"y\":120,\"t\":1710,\"type\":1},{\"x\":401,\"y\":110,\"t\":1727,\"type\":1},{\"x\":406,\"y\":107,\"t\":1743,\"type\":1},{\"x\":408,\"y\":105,\"t\":1761,\"type\":1},{\"x\":409,\"y\":104,\"t\":1778,\"type\":1},{\"x\":410,\"y\":103,\"t\":1822,\"type\":1},{\"t\":1822,\"type\":2}]",
    "legal_consents": {
      "privacy": true,
      "informed_consent": true,
      "responsibility": false,
      "tesseramento": false,
      "photo": false,
      "newsletter": false
    },
    "codice_fiscale": "BLLTHE99A22E801M",
    "debug": {
      "steps": [],
      "sources": {
        "stato_emittente": "MRZ",
        "numero_documento": "MRZ",
        "cittadinanza": "AI_FRONT",
        "cognome": "AI_FRONT",
        "scadenza_documento": "AI_FRONT",
        "comune_residenza": "AI_BACK",
        "codice_fiscale": "AI_BACK",
        "data_nascita": "MATH"
      },
      "FRONT_raw_ocr": "HNOSSHOIOH\nFIRMADELTITOLARE\n33058\n14.02.2022\n22.01.2033\nDNRSSI/ENOSSINE\nSCADENZA/EXPIRY\n175\nTAA\nX35\nNATIONALITY\n05535\nSTATURA\nCITTADINANZA\nMAGENTA(MI22.01.1999\nPLACEAWDDATEOFRIRTH\nLUDGOEDATADINASCITA\n",
      "BACK_raw_ocr": "BELLOTTI<<THEO<<<<<<<<<<<<<<<<\n9901225M3301225 ITA<<<<<<<<<<<6\nC<ITACA 21644LG2<<<<<<<<<<<<<<<\nVIA GRAVELLONA,N. 36 VIGEVANO(PV)\nBLLTHE 99A22E801M\n42plsAVIG.-1999\nESTREMIATTODINASCITA\nCODICEFISCALE\nCO"
    },
    "warning_mismatch": false
  },
  "guardian": null,
  "contact": {
    "email": "theo.bellotti@live.it",
    "telefono": "+39 36992655"
  },
  "legal": null,
  "signature_base64": "data:image/png;base64,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",
  "registration_id": "151564a6-3ef8-4426-9b04-1b538b6d241f",
  "timestamp_iso": "2026-02-09T15:38:57.374580+01:00",
  "computed_age": 27,
  "locked": true
}
<FILE_END>

<FILE_START path="backend\storage\registrations\30899da0-a1a9-4590-820a-fe32a3e2ed79\audit.json">
[
  {
    "timestamp": 1770648278.787311,
    "iso_date": "2026-02-09T15:44:38+0100",
    "action": "CREATE",
    "details": "Nuova registrazione",
    "previous_hash": "0000000000000000000000000000000000000000000000000000000000000000",
    "hash": "d1067d15cfa57731646d31458dcee8e4ab39358561f8f332e9184f51376141ac"
  },
  {
    "timestamp": 1770648278.8065195,
    "iso_date": "2026-02-09T15:44:38+0100",
    "action": "EMAIL_SENT",
    "details": "To: theo.bellotti@live.it",
    "previous_hash": "d1067d15cfa57731646d31458dcee8e4ab39358561f8f332e9184f51376141ac",
    "hash": "4688b956c973ed4f04ba76f9564f582edef795d3a4e88f6bbe804580c5039db4"
  }
]
<FILE_END>

<FILE_START path="backend\storage\registrations\30899da0-a1a9-4590-820a-fe32a3e2ed79\payload.json">
{
  "language": "it",
  "booking_id": null,
  "tutor_participates": true,
  "has_minors": false,
  "is_minor": true,
  "participant": {
    "nome": "cdxsdcxs",
    "cognome": "Hnosshoioh",
    "data_nascita": "22/01/1999",
    "stato_nascita": "ITALIA",
    "comune_nascita": "eds",
    "stato_residenza": "ALTRO",
    "comune_residenza": "",
    "indirizzo_residenza": null,
    "cittadinanza_scelta": null,
    "tipo_documento": "CIE",
    "numero_documento": "IRMADELTI",
    "scadenza_documento": "14/02/2022",
    "source": "OCR_HYBRID",
    "signature_base64": "data:image/png;base64,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",
    "signature_biometrics": "[{\"x\":130,\"y\":48,\"t\":0,\"type\":0},{\"x\":130,\"y\":49,\"t\":31,\"type\":1},{\"x\":130,\"y\":50,\"t\":34,\"type\":1},{\"x\":130,\"y\":51,\"t\":64,\"type\":1},{\"x\":149,\"y\":55,\"t\":80,\"type\":1},{\"x\":169,\"y\":58,\"t\":97,\"type\":1},{\"x\":194,\"y\":60,\"t\":114,\"type\":1},{\"x\":218,\"y\":61,\"t\":131,\"type\":1},{\"x\":233,\"y\":61,\"t\":147,\"type\":1},{\"x\":235,\"y\":61,\"t\":166,\"type\":1},{\"x\":234,\"y\":61,\"t\":230,\"type\":1},{\"x\":232,\"y\":61,\"t\":248,\"type\":1},{\"x\":229,\"y\":62,\"t\":263,\"type\":1},{\"x\":227,\"y\":63,\"t\":280,\"type\":1},{\"x\":236,\"y\":64,\"t\":347,\"type\":1},{\"x\":265,\"y\":67,\"t\":363,\"type\":1},{\"x\":318,\"y\":70,\"t\":380,\"type\":1},{\"x\":381,\"y\":71,\"t\":397,\"type\":1},{\"x\":420,\"y\":71,\"t\":414,\"type\":1},{\"x\":438,\"y\":71,\"t\":429,\"type\":1},{\"x\":439,\"y\":71,\"t\":447,\"type\":1},{\"x\":435,\"y\":71,\"t\":479,\"type\":1},{\"x\":425,\"y\":71,\"t\":496,\"type\":1},{\"x\":405,\"y\":71,\"t\":513,\"type\":1},{\"x\":385,\"y\":71,\"t\":530,\"type\":1},{\"x\":364,\"y\":69,\"t\":546,\"type\":1},{\"x\":351,\"y\":68,\"t\":563,\"type\":1},{\"x\":344,\"y\":68,\"t\":579,\"type\":1},{\"x\":342,\"y\":68,\"t\":596,\"type\":1},{\"x\":341,\"y\":68,\"t\":613,\"type\":1},{\"x\":341,\"y\":69,\"t\":631,\"type\":1},{\"x\":341,\"y\":71,\"t\":647,\"type\":1},{\"x\":341,\"y\":72,\"t\":664,\"type\":1},{\"x\":341,\"y\":76,\"t\":679,\"type\":1},{\"x\":341,\"y\":81,\"t\":696,\"type\":1},{\"x\":341,\"y\":84,\"t\":713,\"type\":1},{\"x\":341,\"y\":93,\"t\":730,\"type\":1},{\"x\":341,\"y\":97,\"t\":746,\"type\":1},{\"x\":341,\"y\":101,\"t\":763,\"type\":1},{\"x\":341,\"y\":102,\"t\":780,\"type\":1},{\"x\":340,\"y\":104,\"t\":796,\"type\":1},{\"x\":339,\"y\":104,\"t\":813,\"type\":1},{\"x\":338,\"y\":96,\"t\":830,\"type\":1},{\"x\":338,\"y\":84,\"t\":847,\"type\":1},{\"x\":338,\"y\":67,\"t\":863,\"type\":1},{\"x\":338,\"y\":60,\"t\":879,\"type\":1},{\"x\":338,\"y\":53,\"t\":896,\"type\":1},{\"x\":338,\"y\":48,\"t\":913,\"type\":1},{\"x\":338,\"y\":47,\"t\":930,\"type\":1},{\"x\":338,\"y\":51,\"t\":979,\"type\":1},{\"x\":338,\"y\":59,\"t\":995,\"type\":1},{\"x\":339,\"y\":73,\"t\":1012,\"type\":1},{\"x\":343,\"y\":87,\"t\":1029,\"type\":1},{\"x\":346,\"y\":93,\"t\":1045,\"type\":1},{\"x\":349,\"y\":96,\"t\":1062,\"type\":1},{\"x\":352,\"y\":97,\"t\":1079,\"type\":1},{\"x\":358,\"y\":98,\"t\":1096,\"type\":1},{\"x\":363,\"y\":98,\"t\":1112,\"type\":1},{\"x\":369,\"y\":98,\"t\":1129,\"type\":1},{\"x\":374,\"y\":96,\"t\":1146,\"type\":1},{\"x\":379,\"y\":93,\"t\":1163,\"type\":1},{\"x\":391,\"y\":84,\"t\":1175,\"type\":1},{\"t\":1175,\"type\":2}]",
    "legal_consents": {
      "privacy": true,
      "informed_consent": true,
      "responsibility": false,
      "tesseramento": false,
      "photo": true,
      "newsletter": true
    },
    "codice_fiscale": "BLLTHE99A22E801M",
    "debug": {
      "steps": [],
      "sources": {
        "stato_emittente": "MRZ",
        "numero_documento": "MRZ",
        "cittadinanza": "AI_FRONT",
        "cognome": "AI_FRONT",
        "scadenza_documento": "AI_FRONT",
        "comune_residenza": "AI_BACK",
        "codice_fiscale": "AI_BACK",
        "data_nascita": "MATH"
      },
      "FRONT_raw_ocr": "HNOSSHOIOH\nFIRMADELTITOLARE\n33058\n14.02.2022\n22.01.2033\nDNRSSI/ENOSSINE\nSCADENZA/EXPIRY\n175\nTAA\nX35\nNATIONALITY\n05535\nSTATURA\nCITTADINANZA\nMAGENTA(MI22.01.1999\nPLACEAWDDATEOFRIRTH\nLUDGOEDATADINASCITA\n",
      "BACK_raw_ocr": "BELLOTTI<<THEO<<<<<<<<<<<<<<<<\n9901225M3301225 ITA<<<<<<<<<<<6\nC<ITACA 21644LG2<<<<<<<<<<<<<<<\nVIA GRAVELLONA,N. 36 VIGEVANO(PV)\nBLLTHE 99A22E801M\n42plsAVIG.-1999\nESTREMIATTODINASCITA\nCODICEFISCALE\nCO"
    },
    "warning_mismatch": false
  },
  "guardian": null,
  "contact": {
    "email": "theo.bellotti@live.it",
    "telefono": "+39 36992655"
  },
  "legal": null,
  "signature_base64": "data:image/png;base64,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",
  "registration_id": "30899da0-a1a9-4590-820a-fe32a3e2ed79",
  "timestamp_iso": "2026-02-10T15:44:38.767807+01:00",
  "computed_age": 27,
  "locked": true
}
<FILE_END>

<FILE_START path="backend\test\check_libs.py">
# backend/check_libs.py
try:
    import gliner
    print("‚úÖ GLINER trovato! Versione:", gliner.__version__)
except ImportError as e:
    print("‚ùå GLINER NON trovato:", e)

try:
    import paddleocr
    print("‚úÖ PaddleOCR trovato!")
except ImportError as e:
    print("‚ùå PaddleOCR NON trovato:", e)
<FILE_END>

<FILE_START path="backend\test\check_models.py">
import google.generativeai as genai
import os
from dotenv import load_dotenv

# 1. Carica la chiave segreta
load_dotenv()
api_key = os.getenv("GEMINI_API_KEY")

if not api_key:
    print("ERRORE: Chiave non trovata nel file .env")
else:
    # 2. Configura Google
    genai.configure(api_key=api_key)

    print("\n--- LISTA DEI MODELLI CHE PUOI USARE ---")
    try:
        # 3. Chiede a Google la lista ufficiale
        found_any = False
        for m in genai.list_models():
            # Filtriamo solo quelli che generano testo/immagini
            if 'generateContent' in m.supported_generation_methods:
                print(f"‚úÖ {m.name}")
                found_any = True
        
        if not found_any:
            print("Nessun modello trovato. La chiave potrebbe non avere permessi.")
            
    except Exception as e:
        print(f"ERRORE DI CONNESSIONE: {e}")
<FILE_END>

<FILE_START path="backend\test\test_ocr_isolation.py">
import cv2
import numpy as np
import pytesseract
import os
import sys
import argparse
from pathlib import Path

# --- CONFIGURAZIONE TESSERACT (Simile al tuo backend) ---
# Tenta di trovare Tesseract automaticamente
DEFAULT_PATHS = [
    r"C:\Program Files\Tesseract-OCR\tesseract.exe",
    r"C:\Program Files (x86)\Tesseract-OCR\tesseract.exe",
    r"/usr/bin/tesseract",
    r"/usr/local/bin/tesseract"
]

TESS_CMD = os.getenv("TESSERACT_CMD")
if not TESS_CMD:
    for p in DEFAULT_PATHS:
        if os.path.exists(p):
            TESS_CMD = p
            break

if not TESS_CMD:
    print("‚ùå Tesseract non trovato. Imposta TESSERACT_CMD o installalo nei percorsi standard.")
    sys.exit(1)

pytesseract.pytesseract.tesseract_cmd = TESS_CMD

def get_tess_config(whitelist=True):
    """Restituisce la configurazione 'hardcore' per MRZ"""
    config = "--oem 3 --psm 6" # PSM 6 = Assume un singolo blocco di testo uniforme
    if whitelist:
        # Whitelist stretta per MRZ
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<"
        config += f" -c tessedit_char_whitelist={chars}"
    return config

def run_test_pipeline(image_path):
    print(f"\nüß™ AVVIO TEST ISOLATO SU: {image_path}")
    
    if not os.path.exists(image_path):
        print(f"‚ùå File non trovato: {image_path}")
        return

    # Carica immagine originale (in scala di grigi)
    original = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if original is None:
        print("‚ùå Impossibile leggere l'immagine.")
        return

    # Lista delle pipeline da testare
    pipelines = [
        ("1. RAW (Nessun filtro)", lambda img: img),
        
        ("2. OTSU (Binarizzazione Classica)", lambda img: 
         cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]),
        
        ("3. ADAPTIVE GAUSSIAN (Attuale in Prod)", lambda img: 
         cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)),
        
        ("4. EROSION (Ispessisce i caratteri)", lambda img: 
         cv2.erode(cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1], np.ones((2,2), np.uint8), iterations=1)),
        
        ("5. DENOISE + OTSU (Rimuove sfondo CIE)", lambda img: 
         cv2.threshold(cv2.fastNlMeansDenoising(img, None, 10, 7, 21), 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]),
        
        ("6. UPSCALE + CLAHE + OTSU (High Definition)", lambda img: _pipeline_hd(img))
    ]

    # Cartella output per vedere cosa "vede" Tesseract
    out_dir = Path("debug_isolation_results")
    out_dir.mkdir(exist_ok=True)

    print(f"üìÇ Le immagini processate verranno salvate in: {out_dir.absolute()}")
    print("-" * 60)

    # Verifica lingue disponibili
    langs = pytesseract.get_languages(config='')
    print(f"üìö Lingue disponibili: {langs}")
    best_score = 0
    best_method = ""

    for name, func in pipelines:
        print(f"\nüëâ Testing: {name}")
        
        # 1. Applica filtro
        try:
            processed = func(original.copy())
        except Exception as e:
            print(f"   ‚ö†Ô∏è Errore nel preprocessing: {e}")
            continue

        # 2. Salva anteprima
        safe_name = name.split(" ")[1].lower()
        out_path = out_dir / f"test_{safe_name}.jpg"
        cv2.imwrite(str(out_path), processed)

        # 3. Esegui OCR con entrambe le lingue se possibile
        test_langs = ['ocrb', 'eng'] if 'ocrb' in langs else ['eng']
        
        for lang in test_langs:
            try:
                # Usa config con whitelist
                cfg = get_tess_config(whitelist=True)
                text = pytesseract.image_to_string(processed, lang=lang, config=cfg).strip()
                
                # Pulizia output
                text_clean = text.replace(" ", "")
                
                # Valutazione base
                score = 0
                if "<<" in text_clean: score += 5
                if "ITA" in text_clean: score += 3
                if len(text_clean) > 20: score += 2
                
                # Feedback visuale
                marker = "‚úÖ" if score >= 5 else "‚ùå"
                print(f"   [{lang.upper()}] Score: {score}/10 -> {marker} Result: {text_clean[:50]}...")

                if score > best_score:
                    best_score = score
                    best_method = f"{name} ({lang})"

            except Exception as e:
                print(f"   ‚ö†Ô∏è Errore Tesseract: {e}")

    print("-" * 60)
    print(f"üèÜ VINCITORE: {best_method if best_method else 'Nessuno (Il documento √® illeggibile)'}")
    print("Consiglio: Apri la cartella 'debug_isolation_results' e guarda quale immagine ha il testo nero pi√π nitido senza rumore di fondo.")

def _pipeline_hd(img):
    # Scala 2x
    img = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)
    # Aumenta contrasto locale
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    img = clahe.apply(img)
    # Binarizzazione pulita
    return cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]

if __name__ == "__main__":
    # Esempio uso: python backend/test_ocr_isolation.py backend/storage/debug_captures/debug_mrz_....jpg
    if len(sys.argv) < 2:
        print("Uso: python test_ocr_isolation.py <path_to_debug_image_jpg>")
        # Cerca l'ultimo file di debug se non passato
        debug_dir = Path(__file__).parent / "debug_captures"
        if debug_dir.exists():
            files = sorted(list(debug_dir.glob("debug_mrz_*.jpg")), key=os.path.getmtime, reverse=True)
            if files:
                print(f"üí° Nessun file specificato. Uso l'ultimo trovato: {files[0].name}")
                run_test_pipeline(str(files[0]))
            else:
                print("‚ùå Nessun file di debug trovato in backend/debug_captures")
    else:
        run_test_pipeline(sys.argv[1])
<FILE_END>

<FILE_START path="backend\test\test_ocr_noise.py">
import cv2
import numpy as np
import pytesseract
import os
import sys
from pathlib import Path

# --- CONFIGURAZIONE BASE ---
DEFAULT_PATHS = [
    r"C:\Program Files\Tesseract-OCR\tesseract.exe",
    r"C:\Program Files (x86)\Tesseract-OCR\tesseract.exe",
    r"/usr/bin/tesseract",
    r"/usr/local/bin/tesseract"
]

TESS_CMD = os.getenv("TESSERACT_CMD")
if not TESS_CMD:
    for p in DEFAULT_PATHS:
        if os.path.exists(p):
            TESS_CMD = p
            break

if not TESS_CMD:
    print("‚ùå Tesseract non trovato. Verifica l'installazione.")
    sys.exit(1)

pytesseract.pytesseract.tesseract_cmd = TESS_CMD

def get_tess_config():
    # PSM 6 = Blocco di testo uniforme (perfetto per MRZ)
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<"
    return f"--oem 3 --psm 6 -c tessedit_char_whitelist={chars}"

# --- PIPELINE AVANZATE DI PULIZIA ---

def pipe_1_division_norm(img):
    """
    Tecnica 'Division Normalization':
    Divide l'immagine per la sua versione sfocata. 
    Questo appiattisce lo sfondo (rimuovendo ombre e pattern leggeri) lasciando il testo netto.
    """
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    
    # Sfocatura ampia per stimare lo sfondo
    bg = cv2.GaussianBlur(gray, (25, 25), 0)
    
    # Divisione: (img / bg) * 255
    # Evitiamo divisione per zero aggiungendo 1
    norm = cv2.divide(gray, bg, scale=255)
    
    # Binarizzazione finale su immagine normalizzata
    _, binary = cv2.threshold(norm, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    return binary

def pipe_2_morph_blackhat(img):
    """
    Tecnica 'Black Hat':
    Estrae elementi scuri (testo) su sfondo chiaro.
    Molto potente contro pattern e ologrammi.
    """
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    
    # Kernel rettangolare orizzontale (adatto ai caratteri MRZ)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (15, 5))
    
    # Blackhat: Differenza tra chiusura e immagine originale
    blackhat = cv2.morphologyEx(gray, cv2.MORPH_BLACKHAT, kernel)
    
    # Aumentiamo il contrasto del risultato
    # Tutto ci√≤ che era sfondo ora √® nero, il testo √® bianco/grigio
    _, binary = cv2.threshold(blackhat, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    
    # Invertiamo per avere testo nero su bianco (formato standard OCR)
    return cv2.bitwise_not(binary)

def pipe_3_gamma_contrast(img):
    """
    Aumento contrasto estremo + Gamma Correction
    """
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    
    # Gamma < 1 schiarisce i mezzitoni (lo sfondo)
    gamma = 0.5
    invGamma = 1.0 / gamma
    table = np.array([((i / 255.0) ** invGamma) * 255 for i in np.arange(0, 256)]).astype("uint8")
    adjusted = cv2.LUT(gray, table)
    
    # Binarizzazione
    _, binary = cv2.threshold(adjusted, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    return binary

def pipe_4_heavy_blur_threshold(img):
    """
    Sfocatura prima del threshold per 'fondere' il rumore di fondo
    """
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    
    # Gaussian Blur leggero per rimuovere il retino tipografico
    blur = cv2.GaussianBlur(gray, (5, 5), 0)
    
    # Adaptive Threshold con parametri pi√π laschi
    binary = cv2.adaptiveThreshold(blur, 255, cv2.ADAPTIVE_THRESH_MEAN_C, 
                                   cv2.THRESH_BINARY, 21, 10)
    return binary

def run_noise_test(image_path):
    print(f"\nüßπ TEST RIMOZIONE RUMORE SU: {os.path.basename(image_path)}")
    
    original = cv2.imread(image_path)
    if original is None:
        print("‚ùå File non trovato.")
        return

    pipelines = [
        ("Division Norm", pipe_1_division_norm),
        ("Morph BlackHat", pipe_2_morph_blackhat),
        ("Gamma Contrast", pipe_3_gamma_contrast),
        ("Blur+Adaptive", pipe_4_heavy_blur_threshold)
    ]

    out_dir = Path("debug_noise_results")
    out_dir.mkdir(exist_ok=True)

    winner_method = ""
    best_score = 0

    for name, func in pipelines:
        # Elabora
        processed = func(original.copy())
        
        # Salva debug
        safe_name = name.replace(" ", "_").lower()
        cv2.imwrite(str(out_dir / f"noise_{safe_name}.jpg"), processed)

        # OCR
        try:
            text = pytesseract.image_to_string(processed, lang='ocrb', config=get_tess_config())
        except:
            text = pytesseract.image_to_string(processed, lang='eng', config=get_tess_config())

        text_clean = text.strip().replace(" ", "")
        
        # Scoring
        score = 0
        if "<<" in text_clean: score += 5
        if "ITA" in text_clean: score += 3
        if len(text_clean) > 20: score += 2
        # Penalit√† per troppi caratteri strani (rumore letto come testo)
        if len(text_clean) > 90: score -= 3 

        marker = "‚úÖ" if score >= 5 else "‚ùå"
        print(f"   [{name}] Score: {score}/10 -> {marker}")
        if score > 0:
            print(f"      Lettura: {text_clean[:60]}...")
        
        if score > best_score:
            best_score = score
            winner_method = name

    print("-" * 50)
    if winner_method:
        print(f"üèÜ METODO VINCENTE: {winner_method}")
        print("Integra questo metodo in 'image_utils.py' > 'enhance_image_for_mrz'")
    else:
        print("üíÄ Nessun metodo ha funzionato perfettamente. Controlla la cartella 'debug_noise_results' per vedere quale immagine √® pi√π pulita all'occhio umano.")

if __name__ == "__main__":
    target = None
    if len(sys.argv) > 1:
        target = sys.argv[1]
    else:
        debug_dir = Path(__file__).parent / "debug_captures"
        if debug_dir.exists():
            files = sorted(list(debug_dir.glob("debug_mrz_*.jpg")), key=os.path.getmtime, reverse=True)
            if files: target = str(files[0])
    
    if target:
        run_noise_test(target)
    else:
        print("Nessuna immagine di debug trovata.")
<FILE_END>

<FILE_START path="backend\test\test_ocr_refinement.py">
import cv2
import numpy as np
import pytesseract
import os
import sys
from pathlib import Path

# --- CONFIGURAZIONE ---
DEFAULT_PATHS = [
    r"C:\Program Files\Tesseract-OCR\tesseract.exe",
    r"C:\Program Files (x86)\Tesseract-OCR\tesseract.exe",
    r"/usr/bin/tesseract",
    r"/usr/local/bin/tesseract"
]

TESS_CMD = os.getenv("TESSERACT_CMD")
if not TESS_CMD:
    for p in DEFAULT_PATHS:
        if os.path.exists(p):
            TESS_CMD = p
            break
if TESS_CMD:
    pytesseract.pytesseract.tesseract_cmd = TESS_CMD

def get_tess_config():
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<"
    return f"--oem 3 --psm 6 -c tessedit_char_whitelist={chars}"

def run_refinement(image_path):
    print(f"\nüßº REFINEMENT TEST SU: {os.path.basename(image_path)}")
    
    # Leggi in scala di grigi
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        print("‚ùå File non trovato.")
        return

    # Se l'immagine √® per lo pi√π nera (come il blackhat), invertila per avere testo nero su bianco
    if np.mean(img) < 127:
        print("üîÑ Rilevato sfondo scuro: Inverto i colori...")
        img = cv2.bitwise_not(img)

    # Assicuriamo una dimensione minima per far funzionare i kernel morfologici
    h, w = img.shape
    if h < 200:
        scale = 2.0
        img = cv2.resize(img, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)
        print(f"üîç Upscaling 2x attivo (nuova h: {img.shape[0]})")

    # Binarizzazione base di partenza (Otsu)
    _, binary = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

    # --- LE ARMI SEGRETE CONTRO LE LINEE SOTTILI ---
    strategies = []

    # 1. Median Blur (Ottimo per rumore "sale e pepe" e linee sottili)
    strategies.append(("Median Blur 3", cv2.medianBlur(binary, 3)))
    strategies.append(("Median Blur 5", cv2.medianBlur(binary, 5)))

    # 2. Morphological Opening (Erosione seguita da Dilatazione) -> Mangia le linee sottili
    kernel_small = np.ones((2,2), np.uint8)
    strategies.append(("Morph Open (2x2)", cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel_small)))

    kernel_med = np.ones((3,3), np.uint8)
    strategies.append(("Morph Open (3x3)", cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel_med)))

    # 3. Combo: Median + Open (Distruzione totale rumore)
    combo = cv2.medianBlur(binary, 3)
    combo = cv2.morphologyEx(combo, cv2.MORPH_OPEN, kernel_small)
    strategies.append(("COMBO (Median+Open)", combo))

    out_dir = Path("debug_refinement_results")
    out_dir.mkdir(exist_ok=True)

    for name, processed in strategies:
        # Salva
        fname = name.replace(" ", "_").replace("(", "").replace(")", "").lower()
        cv2.imwrite(str(out_dir / f"refine_{fname}.jpg"), processed)

        # OCR
        text = "N/A"
        try:
            text = pytesseract.image_to_string(processed, lang='ocrb', config=get_tess_config())
        except:
            text = pytesseract.image_to_string(processed, lang='eng', config=get_tess_config())
        
        text_clean = text.strip().replace(" ", "")
        
        # Score
        score = 0
        if "<<" in text_clean: score += 5
        if "ITA" in text_clean: score += 3
        if len(text_clean) > 20: score += 2

        marker = "‚úÖ" if score >= 5 else "‚ùå"
        print(f"   [{name}] Score: {score}/10 -> {marker}")
        print(f"      Lettura: {text_clean[:50]}...")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        run_refinement(sys.argv[1])
    else:
        # Cerca l'ultimo file debug
        debug_dir = Path(__file__).parent / "debug_captures"
        if debug_dir.exists():
            files = sorted(list(debug_dir.glob("debug_mrz_*.jpg")), key=os.path.getmtime, reverse=True)
            if files: run_refinement(str(files[0]))
<FILE_END>

<FILE_START path="backend\test\test_ocr_rotation.py">
import cv2
import numpy as np
import pytesseract
import os
import sys
from pathlib import Path

# --- CONFIGURAZIONE ---
DEFAULT_PATHS = [
    r"C:\Program Files\Tesseract-OCR\tesseract.exe",
    r"C:\Program Files (x86)\Tesseract-OCR\tesseract.exe",
    r"/usr/bin/tesseract",
    r"/usr/local/bin/tesseract"
]

TESS_CMD = os.getenv("TESSERACT_CMD")
if not TESS_CMD:
    for p in DEFAULT_PATHS:
        if os.path.exists(p):
            TESS_CMD = p
            break

if not TESS_CMD:
    print("‚ùå Tesseract non trovato.")
    sys.exit(1)

pytesseract.pytesseract.tesseract_cmd = TESS_CMD

def get_tess_config():
    # PSM 6 = Assume un singolo blocco di testo uniforme
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<"
    return f"--oem 3 --psm 6 -c tessedit_char_whitelist={chars}"

def apply_smart_preprocessing(img):
    """
    Applica una pulizia aggressiva per CIE:
    1. Upscale (per caratteri piccoli)
    2. Grayscale
    3. Contrasto locale (CLAHE)
    4. Otsu Threshold (Binarizzazione)
    """
    # 1. Upscale se l'immagine √® piccola
    h, w = img.shape[:2]
    if h < 100: # Se l'MRZ √® pi√π piccola di 100px in altezza, √® illeggibile
        scale = 2.0
        img = cv2.resize(img, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)
    
    # 2. Grayscale (se non lo √® gi√†)
    if len(img.shape) == 3:
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    else:
        gray = img

    # 3. CLAHE
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    contrast = clahe.apply(gray)

    # 4. Otsu Thresholding (pi√π pulito dell'Adaptive per le CIE)
    _, binary = cv2.threshold(contrast, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    
    return binary

def run_rotation_test(image_path):
    print(f"\nüîÑ TEST ROTAZIONE SU: {os.path.basename(image_path)}")
    
    original = cv2.imread(image_path)
    if original is None:
        print("‚ùå Impossibile leggere file.")
        return

    # Info base
    h, w = original.shape[:2]
    print(f"üìè Dimensioni originali: {w}x{h} px")
    if h < 50:
        print("‚ö†Ô∏è ATTENZIONE: L'immagine √® troppo bassa (<50px). Tesseract fallir√† quasi sicuramente.")

    # Prepariamo le varianti
    rotations = [
        ("0¬∞ (Originale)", original),
        ("90¬∞ Orario", cv2.rotate(original, cv2.ROTATE_90_CLOCKWISE)),
        ("180¬∞ Capovolto", cv2.rotate(original, cv2.ROTATE_180)),
        ("270¬∞ Antiorario", cv2.rotate(original, cv2.ROTATE_90_COUNTERCLOCKWISE))
    ]

    out_dir = Path("debug_rotation_results")
    out_dir.mkdir(exist_ok=True)

    winner_text = ""
    winner_rot = ""

    for label, img_rot in rotations:
        # Preprocess
        processed = apply_smart_preprocessing(img_rot)
        
        # Salva per debug
        safe_label = label.split(" ")[0].replace("¬∞", "deg")
        cv2.imwrite(str(out_dir / f"rot_{safe_label}.jpg"), processed)

        # OCR
        try:
            # Prova OCRB se c'√®, altrimenti ENG
            text = pytesseract.image_to_string(processed, lang='ocrb', config=get_tess_config())
        except:
            text = pytesseract.image_to_string(processed, lang='eng', config=get_tess_config())

        text_clean = text.strip().replace(" ", "")
        
        # Punteggio
        score = 0
        if "<<" in text_clean: score += 5
        if "ITA" in text_clean: score += 3
        if len(text_clean) > 20 and "<" in text_clean: score += 2

        marker = "‚úÖ" if score >= 5 else "‚ùå"
        print(f"   [{label}] Score: {score}/10 -> {marker}")
        if score > 0:
            print(f"      Lettura: {text_clean[:60]}...")
        else:
            print(f"      (Spazzatura): {text_clean[:20]}...")

        if score >= 5:
            winner_text = text_clean
            winner_rot = label
            break # Trovato!

    print("-" * 50)
    if winner_rot:
        print(f"üéâ SOLUZIONE TROVATA! L'immagine era ruotata di: {winner_rot}")
        print(f"üìÑ Testo: {winner_text}")
    else:
        print("üíÄ Ancora nessun risultato valido. Il problema potrebbe essere il ritaglio errato a monte.")

if __name__ == "__main__":
    # Cerca l'ultimo file debug se non passato
    target = None
    if len(sys.argv) > 1:
        target = sys.argv[1]
    else:
        debug_dir = Path(__file__).parent / "debug_captures"
        files = sorted(list(debug_dir.glob("debug_mrz_*.jpg")), key=os.path.getmtime, reverse=True)
        if files:
            target = str(files[0])
    
    if target:
        run_rotation_test(target)
    else:
        print("Nessun file trovato.")
<FILE_END>

<FILE_START path="backend\test\test_tesseract.py">
import os
from dotenv import load_dotenv
import pytesseract

# 1. Carica le variabili d'ambiente
load_dotenv()

# 2. Leggi il percorso dal .env
tess_path = os.getenv("TESSERACT_CMD")

print(f"\n--- DIAGNOSTICA TESSERACT ---")
print(f"1. Percorso letto dal .env: [{tess_path}]")

if not tess_path:
    print("‚ùå ERRORE: La variabile TESSERACT_CMD √® vuota o non esiste nel .env")
    exit()

# 3. Verifica se il file esiste fisicamente
if os.path.exists(tess_path):
    print("‚úÖ Il file esiste nel percorso specificato.")
else:
    print("‚ùå ERRORE: Il file NON esiste in questo percorso. Controlla il path.")
    # Tentativo di indovinare dove potrebbe essere
    common_path = r"C:\Program Files\Tesseract-OCR\tesseract.exe"
    if os.path.exists(common_path):
        print(f"üí° SUGGERIMENTO: L'ho trovato qui: {common_path}")
        print("   Copia questo percorso nel tuo .env!")
    exit()

# 4. Prova a configurare ed eseguire Tesseract
try:
    pytesseract.pytesseract.tesseract_cmd = tess_path
    version = pytesseract.get_tesseract_version()
    print(f"‚úÖ Tesseract risponde! Versione installata: {version}")
    print("üöÄ Il problema √® risolto in questo script. Se il backend fallisce, riavvialo completamente.")
except Exception as e:
    print(f"‚ùå ERRORE DI ESECUZIONE: {e}")
<FILE_END>

<FILE_START path="backend\tools\check_full_stack.py">
### backend/tools/check_full_stack.py
import os
import sys

# Disabilita check online e log
os.environ["DISABLE_MODEL_SOURCE_CHECK"] = "True"
os.environ["GLOG_minloglevel"] = "2"

print("‚è≥ [STEP 1] Verifica importazioni...")

try:
    # 1. Numpy Check
    import numpy as np
    print(f"‚úÖ Numpy: {np.__version__}")
    if int(np.__version__.split('.')[0]) >= 2:
        raise ImportError("Numpy 2.x rilevato!")

    # 2. Paddle Check
    import paddle
    from paddleocr import PaddleOCR
    paddle.set_device('cpu')
    print(f"‚úÖ Paddle Core: {paddle.__version__}")
    
    # Istanza Test (Parametri Aggiornati per v2.7+)
    # FIX: Rimossi parametri deprecati (show_log, use_angle_cls)
    ocr = PaddleOCR(
        use_textline_orientation=False, 
        lang='it', 
        enable_mkldnn=False
    )
    print("‚úÖ PaddleOCR: Istanziato OK")

    # 3. Torch CPU Check
    import torch
    print(f"‚úÖ PyTorch: {torch.__version__}")
    
    # 4. Ultralytics Check
    from ultralytics import YOLO
    print("‚úÖ Ultralytics: Importato OK")

    # 5. GLINER Check
    from gliner import GLiNER
    print("‚úÖ GLINER: Importato OK")

    print("\nüöÄ AMBIENTE STABILE. Nessun conflitto DLL rilevato.")

except Exception as e:
    print(f"\n‚ùå ERRORE CRITICO: {e}")
    sys.exit(1)
<FILE_END>

<FILE_START path="backend\tools\convert_labelstudio_to_yolo.py">
import json
import shutil
import os
import random
import cv2
import numpy as np
from pathlib import Path

# --- CONFIGURAZIONE ROBUSTA (FIX PERCORSI) ---
# 1. Ottieni la cartella dove si trova QUESTO file script (cio√® backend/tools)
SCRIPT_DIR = Path(__file__).resolve().parent

# 2. Il file JSON deve essere nella stessa cartella dello script
JSON_EXPORT_PATH = SCRIPT_DIR / "project_export.json"

# 3. Risaliamo alla cartella 'backend' (padre di 'tools')
BACKEND_DIR = SCRIPT_DIR.parent

# 4. Definiamo gli altri percorsi partendo da BACKEND_DIR
# Cartella immagini raw: backend/storage/dataset_raw
RAW_IMAGES_DIR = BACKEND_DIR / "storage" / "dataset_raw"

# Output Dataset YOLO: backend/datasets/id_cards
OUTPUT_DIR = BACKEND_DIR / "datasets" / "id_cards"

def convert():
    # Debug visivo dei percorsi
    print(f"üìÇ Script Dir: {SCRIPT_DIR}")
    print(f"üìÇ Cerco JSON qui: {JSON_EXPORT_PATH}")
    print(f"üìÇ Cerco Immagini qui: {RAW_IMAGES_DIR}")

    if not JSON_EXPORT_PATH.exists():
        print(f"‚ùå ERRORE: File non trovato: {JSON_EXPORT_PATH}")
        print("   Assicurati di aver salvato l'export di Label Studio come 'project_export.json'")
        print("   dentro la cartella: backend/tools/")
        return

    # Pulisci e crea cartelle output
    for split in ['train', 'val']:
        (OUTPUT_DIR / split / "images").mkdir(parents=True, exist_ok=True)
        (OUTPUT_DIR / split / "labels").mkdir(parents=True, exist_ok=True)

    try:
        with open(JSON_EXPORT_PATH, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except json.JSONDecodeError:
        print("‚ùå ERRORE: Il file JSON non √® valido o √® corrotto.")
        return

    print(f"üîÑ Elaborazione di {len(data)} task di annotazione...")
    
    success_count = 0

    for task in data:
        # 1. Trova il nome file originale
        # Label studio path es: "/data/upload/12/345-immagine.jpg"
        # Prendiamo l'ultima parte dopo eventuali separatori di percorso
        ls_path = task['data']['image']
        
        # In Label Studio locale, spesso il file viene rinominato con un hash prefisso (es. "8d7s6f-nomefile.jpg")
        # Tentiamo di recuperare il file originale.
        if '-' in ls_path:
            # Prende tutto dopo il primo trattino (rischiose se il file ha trattini, ma standard LS)
            # O meglio: controlliamo se esiste il file esatto in RAW, altrimenti cerchiamo il suffix
            filename_part = ls_path.split('/')[-1] # nomefile completo in LS
        else:
            filename_part = ls_path.split('/')[-1]

        # Cerchiamo il file nella cartella raw
        found_img_path = None
        
        # Tentativo 1: Cerca corrispondenza esatta nella cartella raw (se LS non ha rinominato)
        if (RAW_IMAGES_DIR / filename_part).exists():
            found_img_path = RAW_IMAGES_DIR / filename_part
        else:
            # Tentativo 2: Il nome in LS ha un hash davanti (es "34534-foto.jpg").
            # Cerchiamo nella cartella raw un file che "finisca" con la parte originale del nome.
            # Questo √® necessario perch√© non sappiamo l'hash esatto che LS ha generato se non usiamo il suo storage.
            original_name_candidate = filename_part
            if '-' in filename_part:
                 original_name_candidate = filename_part.split('-', 1)[-1] # Rimuove solo il primo pezzo (hash)
            
            if (RAW_IMAGES_DIR / original_name_candidate).exists():
                found_img_path = RAW_IMAGES_DIR / original_name_candidate
            else:
                # Tentativo 3: Ricerca brutale per suffisso (lento ma sicuro)
                for f in RAW_IMAGES_DIR.glob("*"):
                    if filename_part.endswith(f.name) or f.name in filename_part:
                        found_img_path = f
                        break
        
        if not found_img_path:
            print(f"‚ö†Ô∏è Immagine non trovata per: {filename_part}")
            continue

        # 2. Leggi dimensioni immagine (per normalizzare)
        img = cv2.imread(str(found_img_path))
        if img is None: 
            print(f"‚ö†Ô∏è Impossibile leggere immagine: {found_img_path}")
            continue
            
        h_img, w_img = img.shape[:2]

        # 3. Estrai annotazioni
        label_lines = []
        # Supporto sia per struttura export standard che snapshot
        annotations = task.get('annotations', [])
        
        for ann in annotations:
            for res in ann.get('result', []):
                # Gestiamo solo PolygonLabels
                if res['type'] != 'polygonlabels': continue
                
                points = res['value']['points'] # [[x,y], [x,y]...] in percentuale 0-100
                
                # YOLO OBB vuole: class x1 y1 x2 y2 x3 y3 x4 y4 (Normalizzati 0-1)
                
                flat_coords = []
                for p in points:
                    # Label studio usa coordinate relative 0-100
                    nx = p[0] / 100.0
                    ny = p[1] / 100.0
                    flat_coords.extend([f"{nx:.6f}", f"{ny:.6f}"])
                
                # Se abbiamo meno di 3 punti, non √® un poligono valido
                if len(points) < 3: continue
                
                # Class index 0 = id_card (unica classe)
                line = f"0 {' '.join(flat_coords)}"
                label_lines.append(line)

        if not label_lines:
            # Nessuna annotazione poligonale valida trovata
            continue

        # 4. Split Train/Val (80% Train, 20% Val)
        subset = "train" if random.random() < 0.8 else "val"
        
        # 5. Salva File
        # Usiamo un nome univoco basato sull'ID del task per evitare sovrascritture
        out_name = f"{task['id']}_{found_img_path.name}"
        
        # Copia immagine
        shutil.copy2(found_img_path, OUTPUT_DIR / subset / "images" / out_name)
        
        # Scrivi Label
        # Sostituisci estensione immagine con .txt
        txt_name = os.path.splitext(out_name)[0] + ".txt"
        with open(OUTPUT_DIR / subset / "labels" / txt_name, "w") as out_f:
            out_f.write("\n".join(label_lines))
            
        success_count += 1

    print("-" * 50)
    print(f"‚úÖ Conversione completata!")
    print(f"üìä Immagini processate con successo: {success_count}")
    print(f"üìÇ Cartella Output: {OUTPUT_DIR}")

if __name__ == "__main__":
    convert()
<FILE_END>

<FILE_START path="backend\tools\daily_freeze.py">
import os
import json
import hashlib
import shutil
from datetime import datetime, date
from pathlib import Path

# Configurazione
BASE_DIR = Path(__file__).resolve().parent.parent
STORAGE_DIR = BASE_DIR / "storage" / "registrations"
FREEZE_DIR = BASE_DIR / "storage" / "daily_freezes"

def calculate_file_hash(filepath):
    """Calcola SHA-256 di un file."""
    sha256_hash = hashlib.sha256()
    with open(filepath, "rb") as f:
        # Legge il file a blocchi per non saturare la RAM
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()

def freeze_day(target_date_str=None):
    """
    Scansiona tutte le registrazioni di una data specifica.
    Calcola gli hash e genera un report di integrit√†.
    """
    # Se non specificata, usa la data di oggi
    if not target_date_str:
        target_date_str = date.today().isoformat() # YYYY-MM-DD

    print(f"‚ùÑÔ∏è  AVVIO FREEZE GIORNALIERO: {target_date_str}")
    
    if not STORAGE_DIR.exists():
        print("‚ùå Nessuna cartella storage trovata.")
        return

    # 1. Cerca le registrazioni del giorno
    daily_manifest = {
        "freeze_date": target_date_str,
        "generated_at": datetime.now().isoformat(),
        "registrations": [],
        "total_files": 0,
        "cumulative_hash": ""
    }

    print("üîç Scansione cartelle...")
    
    all_hashes = []

    for entry in os.listdir(STORAGE_DIR):
        reg_dir = STORAGE_DIR / entry
        json_path = reg_dir / "payload.json"
        
        if not json_path.exists():
            continue

        try:
            with open(json_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Estrai la data dal timestamp ISO
            ts = data.get("timestamp_iso", "")
            if not ts.startswith(target_date_str):
                continue # Non √® di oggi

            # Trovata registrazione del giorno!
            print(f"   + Processo ID: {entry}")
            
            reg_entry = {
                "id": entry,
                "files": {}
            }

            # Hash dei file critici
            for filename in ["signed.pdf", "audit.json", "biometrics.json", "payload.json"]:
                fpath = reg_dir / filename
                if fpath.exists():
                    fhash = calculate_file_hash(fpath)
                    reg_entry["files"][filename] = fhash
                    all_hashes.append(fhash)
            
            daily_manifest["registrations"].append(reg_entry)
            daily_manifest["total_files"] += len(reg_entry["files"])

        except Exception as e:
            print(f"‚ö†Ô∏è Errore lettura {entry}: {e}")

    if daily_manifest["total_files"] == 0:
        print(f"‚ö†Ô∏è Nessuna registrazione trovata per il {target_date_str}")
        return

    # 2. Calcolo Super-Hash (Hash di tutti gli hash)
    # Ordiniamo per garantire riproducibilit√†
    all_hashes.sort()
    mega_string = "".join(all_hashes)
    super_hash = hashlib.sha256(mega_string.encode('utf-8')).hexdigest()
    
    daily_manifest["cumulative_hash"] = super_hash

    # 3. Salvataggio Report
    FREEZE_DIR.mkdir(parents=True, exist_ok=True)
    report_filename = f"freeze_report_{target_date_str}.json"
    report_path = FREEZE_DIR / report_filename

    with open(report_path, "w", encoding="utf-8") as f:
        json.dump(daily_manifest, f, indent=2)

    print("\n" + "="*60)
    print(f"‚úÖ GIORNATA CRISTALLIZZATA CORRETTAMENTE")
    print(f"üìÑ Report salvato in: {report_path}")
    print(f"üîê SUPER-HASH (Digital Fingerprint):")
    print(f"   {super_hash}")
    print("="*60)
    print("\nüí° CONSIGLIO LEGALE:")
    print("Invia questo file JSON (o il Super-Hash) via PEC all'indirizzo dell'azienda")
    print("per ottenere una Data Certa opponibile a terzi su tutto il lotto.")

if __name__ == "__main__":
    # Puoi passare una data specifica YYYY-MM-DD come argomento, o usa oggi
    import sys
    target = sys.argv[1] if len(sys.argv) > 1 else None
    freeze_day(target)
<FILE_END>

<FILE_START path="backend\tools\diagnose_env.py">
import os
import platform
import sys
import subprocess

def check_cpu_instructions():
    print("--- DIAGNOSTICA CPU E AMBIENTE ---")
    print(f"OS: {platform.system()} {platform.release()}")
    print(f"Architecture: {platform.machine()}")
    print(f"Python: {sys.version.split()[0]}")
    
    # Tentativo di rilevamento CPU
    try:
        if platform.system() == "Windows":
            command = "wmic cpu get name"
            output = subprocess.check_output(command, shell=True).decode().strip().split('\n')[1]
            print(f"CPU Model: {output}")
        else:
            # Linux/Mac fallback
            with open('/proc/cpuinfo') as f:
                for line in f:
                    if "model name" in line:
                        print(f"CPU Model: {line.split(':')[1].strip()}")
                        break
    except Exception as e:
        print(f"CPU Model detection failed: {e}")

    print("\n--- CONSIGLIO INSTALLAZIONE PADDLE ---")
    print("Se la tua CPU √® Intel Core (4a gen o superiore) o AMD Ryzen recente -> Supporta AVX.")
    print("Se sei su una VM Windows Server vecchia o CPU Celeron/Pentium vecchi -> Potrebbe NON supportare AVX.")
    print("\nREGOLA D'ORO:")
    print("1. Prova prima l'installazione STANDARD (MKL).")
    print("2. Esegui lo script 'verify_paddle.py' (che creeremo tra poco).")
    print("3. Se ottieni errore 'Illegal Instruction' o crash, passa alla versione NO-AVX.")

if __name__ == "__main__":
    check_cpu_instructions()
<FILE_END>

<FILE_START path="backend\tools\env_audit.py">
import os
import sys
import pkg_resources
import platform

def check_asset(path, description):
    if os.path.exists(path):
        size_mb = os.path.getsize(path) / (1024 * 1024)
        print(f"‚úÖ FILE TROVATO: {description}")
        print(f"   Percorso: {path}")
        print(f"   Dimensione: {size_mb:.2f} MB")
        return True
    else:
        print(f"‚ùå FILE MANCANTE: {description}")
        print(f"   Percorso atteso: {path}")
        print("   ‚ö†Ô∏è QUESTO FILE DEVE ESSERE INCLUSO IN GIT!")
        return False

def check_package(package_name, expected_version=None):
    try:
        version = pkg_resources.get_distribution(package_name).version
        status = "‚úÖ"
        note = ""
        if expected_version:
            if version == expected_version:
                note = "(Corretto)"
            else:
                status = "‚ö†Ô∏è"
                note = f"(Atteso: {expected_version} - RISCHIO!)"
        
        print(f"{status} {package_name.ljust(20)} : {version} {note}")
    except pkg_resources.DistributionNotFound:
        print(f"‚ùå {package_name.ljust(20)} : NON INSTALLATO")

print("="*60)
print(f"üîç AUDIT AMBIENTE - {platform.system()} - Python {sys.version.split()[0]}")
print("="*60)

# 1. VERIFICA LIBRERIE CRITICHE
print("\n--- 1. VERIFICA LIBRERIE CHIAVE ---")
check_package("numpy", "1.26.4")
check_package("paddleocr", "2.7.3")
check_package("paddlepaddle", "2.6.2")
check_package("torch", "2.4.1+cpu")  # O 2.4.1 standard
check_package("ultralytics", "8.3.20")
check_package("gliner", "0.2.7")
check_package("huggingface-hub", "0.22.2")
check_package("opencv-python-headless")

# 2. VERIFICA FILE FISICI (ASSETS)
print("\n--- 2. VERIFICA ASSETS (File Modelli) ---")
base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
yolo_path = os.path.join(base_dir, "assets", "models", "id_card_detector_v11n.pt")

yolo_ok = check_asset(yolo_path, "Modello YOLO v11")

# 3. VERIFICA CARTELLA DEBUG
debug_dir = os.path.join(base_dir, "debug_crops")
if not os.path.exists(debug_dir):
    print(f"\n‚ö†Ô∏è Cartella {debug_dir} non esiste. Verr√† creata al volo (OK).")

print("\n" + "="*60)
if yolo_ok:
    print("üöÄ AUDIT PASSATO: Tutti i componenti critici sono presenti.")
else:
    print("üõë AUDIT FALLITO: Mancano file essenziali per il deploy.")
print("="*60)
<FILE_END>

<FILE_START path="backend\tools\fix_dependencies.py">
import subprocess
import sys
import os

def install(package):
    print(f"üì¶ Installazione/Downgrade: {package}...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", package])

def check_and_fix():
    print("üîß AVVIO RIPARAZIONE AMBIENTE PER GLINER...")
    
    # 1. Downgrade huggingface_hub per compatibilit√† GLiNER
    # La versione 0.23+ ha rimosso 'is_offline_mode', rompendo gliner attuale.
    # Forziamo una versione stabile precedente.
    try:
        import huggingface_hub
        print(f"   Versione attuale huggingface_hub: {huggingface_hub.__version__}")
    except ImportError:
        print("   huggingface_hub non trovato.")

    print("   üëâ Eseguo downgrade a huggingface_hub==0.22.2 (Versione sicura)...")
    install("huggingface_hub==0.22.2")

    # 2. Reinstalliamo GLiNER per sicurezza
    print("   üëâ Aggiorno GLiNER...")
    install("gliner>=0.2.0")

    # 3. Pre-scaricamento del modello (evita timeout al primo avvio)
    print("   ‚¨áÔ∏è Pre-scaricamento modello 'urchade/gliner_medium-v2.1'...")
    try:
        from gliner import GLiNER
        model = GLiNER.from_pretrained("urchade/gliner_medium-v2.1")
        print("   ‚úÖ Modello scaricato e caricato correttamente in cache.")
    except Exception as e:
        print(f"   ‚ùå Errore download modello: {e}")
        print("   Assicurati di essere connesso a internet.")

    print("\n‚úÖ OPERAZIONE COMPLETATA.")
    print("   Ora riavvia il server backend con: uvicorn main:app --reload")

if __name__ == "__main__":
    check_and_fix()
<FILE_END>

<FILE_START path="backend\tools\fix_gliner.py">
import subprocess
import sys
import os

def install(package):
    print(f"üì¶ Installazione: {package}...")
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", package, "--no-cache-dir"])
        print(f"‚úÖ {package} installato.")
    except Exception as e:
        print(f"‚ùå Errore installazione {package}: {e}")

def fix_environment():
    print("\n‚ò¢Ô∏è  RAFTING REPUBLIC - AI STACK REPAIR (V5 - CLEAN ORDER)")
    print("=========================================================")
    print("Obiettivo: Risolvere RuntimeError: Numpy is not available")

    # 1. RIMOZIONE TOTALE
    print("\n1Ô∏è‚É£  Rimozione totale librerie AI...")
    pkgs = [
        "ultralytics", "gliner", "paddleocr", "paddlepaddle",
        "torch", "torchvision", "torchaudio", 
        "numpy", "scipy", "pandas", "huggingface-hub"
    ]
    subprocess.call([sys.executable, "-m", "pip", "uninstall", "-y"] + pkgs)

    # 2. INSTALLAZIONE NUMPY (Base Solida)
    print("\n2Ô∏è‚É£  Installazione NumPy 1.26.4...")
    # Versione gold standard per compatibilit√†
    install("numpy==1.26.4")

    # 3. INSTALLAZIONE PYTORCH CPU (Minimale)
    print("\n3Ô∏è‚É£  Installazione PyTorch 2.3.1 CPU...")
    try:
        subprocess.check_call([
            sys.executable, "-m", "pip", "install", 
            "torch==2.3.1", "torchvision==0.18.1", "torchaudio==2.3.1",
            "--index-url", "https://download.pytorch.org/whl/cpu"
        ])
        print("‚úÖ PyTorch installato.")
    except Exception as e:
        print(f"‚ùå Errore PyTorch: {e}")
        return

    # 4. INSTALLAZIONE PADDLE (Senza rompere NumPy)
    print("\n4Ô∏è‚É£  Installazione Paddle...")
    install("paddlepaddle==2.6.1")
    install("paddleocr>=2.7.0")
    # Forziamo protobuf compatibile per Paddle
    install("protobuf==3.20.3")

    # 5. INSTALLAZIONE ULTRALYTICS & GLINER
    print("\n5Ô∏è‚É£  Installazione YOLO & GLiNER...")
    install("ultralytics>=8.2.0")
    install("huggingface-hub>=0.23.0")
    install("gliner")

    # 6. VERIFICA FINALE
    print("\n6Ô∏è‚É£  Test Finale...")
    try:
        import numpy
        print(f"   ‚úÖ NumPy: {numpy.__version__}")
        
        import torch
        # Verifica se PyTorch vede NumPy
        t = torch.tensor([1, 2, 3])
        n = t.numpy()
        print(f"   ‚úÖ PyTorch -> NumPy bridge OK: {n}")
        
        from gliner import GLiNER
        print("   ‚úÖ GLiNER importato.")
        
        print("\nüöÄ RIPARAZIONE COMPLETATA. Riavvia il server.")
        
    except ImportError as e:
        print(f"‚ùå Errore Import: {e}")
    except RuntimeError as e:
        print(f"‚ùå Errore Runtime: {e}")
    except Exception as e:
        print(f"‚ùå Errore Generico: {e}")

if __name__ == "__main__":
    fix_environment()
<FILE_END>

<FILE_START path="backend\tools\generate_synthetic_data.py">
# backend/tools/generate_synthetic_data.py
import cv2
import numpy as np
import os
import random
from pathlib import Path

# Configurazione
NUM_IMAGES = 100  # Generiamo 100 immagini finte
BASE_DIR = Path(__file__).resolve().parent.parent
TEMPLATES_DIR = BASE_DIR / "assets" / "templates"
OUTPUT_DIR = BASE_DIR / "datasets" / "id_cards"

# Crea cartelle
(OUTPUT_DIR / "train" / "images").mkdir(parents=True, exist_ok=True)
(OUTPUT_DIR / "train" / "labels").mkdir(parents=True, exist_ok=True)
(OUTPUT_DIR / "val" / "images").mkdir(parents=True, exist_ok=True)
(OUTPUT_DIR / "val" / "labels").mkdir(parents=True, exist_ok=True)

def create_random_background(h, w):
    """Crea uno sfondo rumoroso casuale"""
    # Colore base casuale (grigio/legno/tavolo)
    color = np.random.randint(100, 200, size=(1, 1, 3), dtype=np.uint8)
    bg = np.ones((h, w, 3), dtype=np.uint8) * color
    # Aggiungi rumore
    noise = np.random.randint(-50, 50, size=(h, w, 3), dtype=np.int16)
    bg = np.clip(bg + noise, 0, 255).astype(np.uint8)
    return bg

def rotate_image(image, angle):
    """Ruota l'immagine e calcola i nuovi 4 angoli"""
    h, w = image.shape[:2]
    cx, cy = w // 2, h // 2
    
    # Matrice di rotazione
    M = cv2.getRotationMatrix2D((cx, cy), angle, 1.0)
    cos = np.abs(M[0, 0])
    sin = np.abs(M[0, 1])
    
    # Nuove dimensioni bounding box
    nW = int((h * sin) + (w * cos))
    nH = int((h * cos) + (w * sin))
    
    M[0, 2] += (nW / 2) - cx
    M[1, 2] += (nH / 2) - cy
    
    rotated = cv2.warpAffine(image, M, (nW, nH), borderValue=(0,0,0))
    
    # Calcola le coordinate dei 4 angoli originali trasformati
    # Ordine: TL, TR, BR, BL
    corners = np.array([
        [0, 0],
        [w, 0],
        [w, h],
        [0, h]
    ])
    
    ones = np.ones(shape=(len(corners), 1))
    corners_ones = np.hstack([corners, ones])
    transformed = M.dot(corners_ones.T).T
    
    # Maschera alpha per incollare
    mask = cv2.warpAffine(np.ones((h, w), dtype=np.uint8)*255, M, (nW, nH))
    
    return rotated, mask, transformed

def generate():
    # Cerca i template disponibili (CIE, Patente, ecc.)
    templates = list(TEMPLATES_DIR.glob("*.jpg")) + list(TEMPLATES_DIR.glob("*.png"))
    if not templates:
        print(f"‚ùå Nessun template trovato in {TEMPLATES_DIR}")
        return

    print(f"üé® Generazione {NUM_IMAGES} immagini sintetiche da {len(templates)} template...")

    for i in range(NUM_IMAGES):
        # 1. Scegli template e sfondo
        tpl_path = random.choice(templates)
        card = cv2.imread(str(tpl_path))
        
        # Ridimensiona template a una dimensione realistica (es. larghezza 400-600px)
        target_w = random.randint(400, 600)
        aspect = card.shape[0] / card.shape[1]
        card = cv2.resize(card, (target_w, int(target_w * aspect)))
        
        # Sfondo pi√π grande
        bg_h, bg_w = 1024, 1024
        bg = create_random_background(bg_h, bg_w)
        
        # 2. Ruota la carta
        angle = random.randint(-180, 180)
        rot_card, mask, corners = rotate_image(card, angle)
        
        # 3. Posiziona la carta sullo sfondo
        h_rot, w_rot = rot_card.shape[:2]
        # Assicuriamoci che stia dentro
        max_x = bg_w - w_rot
        max_y = bg_h - h_rot
        
        if max_x < 0 or max_y < 0: continue # Skip se troppo grande dopo rotazione
        
        x_off = random.randint(0, max_x)
        y_off = random.randint(0, max_y)
        
        # Incolla
        roi = bg[y_off:y_off+h_rot, x_off:x_off+w_rot]
        # Dove la maschera √® > 0, usa la carta, altrimenti tieni lo sfondo
        mask_bool = mask > 0
        roi[mask_bool] = rot_card[mask_bool]
        bg[y_off:y_off+h_rot, x_off:x_off+w_rot] = roi
        
        # 4. Aggiorna coordinate assolute globali
        final_corners = corners + [x_off, y_off]
        
        # 5. Prepara Label YOLO OBB
        # Formato: class_index x1 y1 x2 y2 x3 y3 x4 y4 (Normalizzati 0-1)
        # class_index √® sempre 0 ("id_card")
        norm_corners = final_corners / [bg_w, bg_h]
        flat_coords = " ".join([f"{c[0]:.6f} {c[1]:.6f}" for c in norm_corners])
        label_str = f"0 {flat_coords}"
        
        # 6. Salva (Split 80/20 train/val)
        subset = "train" if i < (NUM_IMAGES * 0.8) else "val"
        filename = f"syn_{i:04d}"
        
        cv2.imwrite(str(OUTPUT_DIR / subset / "images" / f"{filename}.jpg"), bg)
        with open(OUTPUT_DIR / subset / "labels" / f"{filename}.txt", "w") as f:
            f.write(label_str)

    print("‚úÖ Generazione completata. Dataset pronto in backend/datasets/id_cards")

if __name__ == "__main__":
    generate()
<FILE_END>

<FILE_START path="backend\tools\project_export.json">
[{"id":10,"annotations":[{"id":2,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[10.409929892610046,28.756961808301405],[95.08451427682981,28.153293193394894],[96.47965952016929,58.15562335424843],[6.3318130274638476,57.73305532381387]],"closed":true,"polygonlabels":["id_card"]},"id":"nPE-XKasmR","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:27:19.992614Z","updated_at":"2026-01-28T14:27:19.992614Z","draft_created_at":"2026-01-28T14:25:48.460542Z","lead_time":107.949,"prediction":{},"result_count":1,"unique_id":"c722c6b7-ff42-4aa9-80ce-62fe7643ddeb","import_id":null,"last_action":null,"bulk_created":false,"task":10,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"6c59f319-1769537173_6fa0afed_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/6c59f319-1769537173_6fa0afed_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.969495Z","updated_at":"2026-01-28T14:27:20.867436Z","allow_skip":true,"inner_id":1,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":11,"annotations":[{"id":3,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[9.493591892546817,30.908199927986967],[94.19294216866015,29.004321988666444],[98.73335568248686,59.856064970345436],[9.328485946589478,61.016966152857954]],"closed":true,"polygonlabels":["id_card"]},"id":"A8olBmLxa9","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:28:10.971315Z","updated_at":"2026-01-28T14:28:10.971315Z","draft_created_at":"2026-01-28T14:27:44.702799Z","lead_time":35.354,"prediction":{},"result_count":1,"unique_id":"2a37e449-9c27-4f29-ba1c-868d96ca3634","import_id":null,"last_action":null,"bulk_created":false,"task":11,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"16eefd4b-1769537227_7590b910_BACK.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/16eefd4b-1769537227_7590b910_BACK.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.969495Z","updated_at":"2026-01-28T14:28:11.577126Z","allow_skip":true,"inner_id":2,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":12,"annotations":[{"id":13,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[10.32407480071222,28.67703608368779],[95.42793464442103,27.735313044433635],[97.10210893642846,58.81217333982075],[5.720095497691906,58.105881060380135]],"closed":true,"polygonlabels":["id_card"]},"id":"K3p6XJ7-C5","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:37:51.297391Z","updated_at":"2026-01-28T14:37:51.297391Z","draft_created_at":"2026-01-28T14:37:36.677960Z","lead_time":27.409,"prediction":{},"result_count":1,"unique_id":"722edf38-0112-4e31-bd10-6ba8e3c16a7c","import_id":null,"last_action":null,"bulk_created":false,"task":12,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"0100ad90-1769537227_caf21a69_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/0100ad90-1769537227_caf21a69_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.969495Z","updated_at":"2026-01-28T14:37:51.357122Z","allow_skip":true,"inner_id":3,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":13,"annotations":[{"id":14,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[10.302611027737779,28.19814577148245],[5.9025375679747745,57.89864162488272],[96.58697838504158,58.50231023978923],[95.51378973631887,27.835944602538543]],"closed":true,"polygonlabels":["id_card"]},"id":"jmLSBn4_3I","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:38:28.858974Z","updated_at":"2026-01-28T14:38:28.858974Z","draft_created_at":"2026-01-28T14:38:04.295512Z","lead_time":33.717,"prediction":{},"result_count":1,"unique_id":"6484219d-4359-4fa3-8379-d4b319e182a5","import_id":null,"last_action":null,"bulk_created":false,"task":13,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"156e6307-1769537443_693984f2_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/156e6307-1769537443_693984f2_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.969495Z","updated_at":"2026-01-28T14:38:28.917244Z","allow_skip":true,"inner_id":4,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":14,"annotations":[{"id":15,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[9.460544784054575,30.908766178041315],[94.86464084832805,28.64892714143924],[98.7525359650628,59.849285453235666],[8.682965760707624,61.23434808857242]],"closed":true,"polygonlabels":["id_card"]},"id":"MhGGGKHCoY","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:39:03.227329Z","updated_at":"2026-01-28T14:39:03.227329Z","draft_created_at":"2026-01-28T14:38:45.302919Z","lead_time":29.598,"prediction":{},"result_count":1,"unique_id":"c66fde22-4f91-4282-a43d-04e306630f60","import_id":null,"last_action":null,"bulk_created":false,"task":14,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"889976f3-1769537492_01e00b83_BACK.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/889976f3-1769537492_01e00b83_BACK.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.971059Z","updated_at":"2026-01-28T14:39:03.299119Z","allow_skip":true,"inner_id":5,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":15,"annotations":[{"id":16,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[9.975288489877364,28.07590287696388],[95.21866285792017,27.565802897367885],[97.75782720079805,58.78392164864314],[5.259697567389895,58.17180167312793]],"closed":true,"polygonlabels":["id_card"]},"id":"AQ2UCPp7VM","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:40:22.029658Z","updated_at":"2026-01-28T14:40:22.031670Z","draft_created_at":"2026-01-28T14:39:51.499269Z","lead_time":39.455,"prediction":{},"result_count":1,"unique_id":"0e2710e2-124a-4e7e-9c0b-06e700696459","import_id":null,"last_action":null,"bulk_created":false,"task":15,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"9d2aad11-1769537492_fa926c97_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/9d2aad11-1769537492_fa926c97_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.971059Z","updated_at":"2026-01-28T14:40:22.090885Z","allow_skip":true,"inner_id":6,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":16,"annotations":[{"id":17,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[5.869516378783305,57.75244701716657],[10.071462703397492,28.385692342691797],[95.28971738109104,27.60291325962622],[96.82284402212343,58.50941959863093]],"closed":true,"polygonlabels":["id_card"]},"id":"ucWLsF3dIn","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:41:09.964991Z","updated_at":"2026-01-28T14:41:09.964991Z","draft_created_at":"2026-01-28T14:40:31.931393Z","lead_time":46.066,"prediction":{},"result_count":1,"unique_id":"8e6c490a-c79e-43e6-b364-993d1b955e58","import_id":null,"last_action":null,"bulk_created":false,"task":16,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"3dbf62ab-1769537842_5a2c0c8b_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/3dbf62ab-1769537842_5a2c0c8b_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.971059Z","updated_at":"2026-01-28T14:41:10.021036Z","allow_skip":true,"inner_id":7,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":29,"annotations":[{"id":4,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":270,"value":{"points":[[77.85145888594162,93.89920424403185],[9.946949602121986,93.79973474801061],[9.283819628647215,13.129973474801051],[78.3819628647215,13.42838196286472]],"closed":true,"polygonlabels":["id_card"]},"id":"9DTID0iO63","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:29:16.171855Z","updated_at":"2026-01-28T14:29:16.171855Z","draft_created_at":"2026-01-28T14:28:56.759364Z","lead_time":35.577,"prediction":{},"result_count":1,"unique_id":"58199c1f-0d5b-463e-9682-fe31e992c720","import_id":null,"last_action":null,"bulk_created":false,"task":29,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"8ad33a03-1769596492_99194ebe_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/8ad33a03-1769596492_99194ebe_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.980804Z","updated_at":"2026-01-28T14:29:17.480114Z","allow_skip":true,"inner_id":20,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":30,"annotations":[{"id":5,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":270,"value":{"points":[[78.57438920113,8.014028237017376],[82.09549071618035,73.40848806366049],[24.403183023872668,73.1100795755968],[26.525198938992045,9.946949602122007]],"closed":true,"polygonlabels":["id_card"]},"id":"HMrvMFJ_8a","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:31:38.001613Z","updated_at":"2026-01-28T14:31:38.001613Z","draft_created_at":"2026-01-28T14:31:11.739804Z","lead_time":47.47,"prediction":{},"result_count":1,"unique_id":"2229aa5b-db6a-4ae7-a562-744d296186b9","import_id":null,"last_action":null,"bulk_created":false,"task":30,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"605b30e9-1769596780_4d3a2d9d_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/605b30e9-1769596780_4d3a2d9d_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.980804Z","updated_at":"2026-01-28T14:31:38.461137Z","allow_skip":true,"inner_id":21,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":31,"annotations":[{"id":6,"completed_by":1,"result":[{"original_width":1080,"original_height":1920,"image_rotation":0,"value":{"points":[[10.236568649354828,28.302455064533564],[95.26613081738284,27.977402733430058],[97.24740216887088,58.64872774053242],[5.8612610814854245,57.95218703102491]],"closed":true,"polygonlabels":["id_card"]},"id":"QuF2fl2cOL","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:32:43.463166Z","updated_at":"2026-01-28T14:32:43.463166Z","draft_created_at":"2026-01-28T14:32:28.713075Z","lead_time":53.75,"prediction":{},"result_count":1,"unique_id":"7b2dbf69-8e19-47f9-9f37-fbaa16c07c2a","import_id":null,"last_action":null,"bulk_created":false,"task":31,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"eb3c0a61-1769605683_852bab5b_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/eb3c0a61-1769605683_852bab5b_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.981857Z","updated_at":"2026-01-28T14:32:43.953510Z","allow_skip":true,"inner_id":22,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":32,"annotations":[{"id":7,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":270,"value":{"points":[[78.91246684350133,8.057029177718832],[81.9628647214854,73.80636604774537],[24.403183023872668,73.30901856763926],[26.12732095490717,9.748010610079568]],"closed":true,"polygonlabels":["id_card"]},"id":"DhsZOqHnxI","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:33:37.651064Z","updated_at":"2026-01-28T14:33:37.651064Z","draft_created_at":"2026-01-28T14:33:07.886915Z","lead_time":40.32,"prediction":{},"result_count":1,"unique_id":"18e24fd3-0845-4596-9f09-6eeb6896e204","import_id":null,"last_action":null,"bulk_created":false,"task":32,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"5e7a382a-1769605932_e803dcdb_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/5e7a382a-1769605932_e803dcdb_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.981857Z","updated_at":"2026-01-28T14:33:38.279087Z","allow_skip":true,"inner_id":23,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":45,"annotations":[{"id":39,"completed_by":1,"result":[{"original_width":1014,"original_height":644,"image_rotation":0,"value":{"points":[[0,0.45375624250451974],[99.32756964457252,0.9075124850090395],[99.71181556195965,99.52386918932466],[0.48030739673390976,99.07011294682013]],"closed":true,"polygonlabels":["id_card"]},"id":"rY1i_WokOq","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:56:24.599750Z","updated_at":"2026-01-28T14:56:24.599750Z","draft_created_at":"2026-01-28T14:55:47.813581Z","lead_time":46.32,"prediction":{},"result_count":1,"unique_id":"2cd9b994-528f-4c74-995b-d41c29348cf5","import_id":null,"last_action":null,"bulk_created":false,"task":45,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"0146de63-1769608197_6c624c3e_FRONT.jpg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/0146de63-1769608197_6c624c3e_FRONT.jpg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:56:24.659289Z","allow_skip":true,"inner_id":36,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":46,"annotations":[{"id":38,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[9.372236958443855,13.262599469496022],[79.04509283819631,12.9973474801061],[76.9230769230769,94.16445623342176],[10.256410256410257,94.16445623342177]],"closed":true,"polygonlabels":["id_card"]},"id":"ExyDpPO3ht","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:55:36.175570Z","updated_at":"2026-01-28T14:55:36.175570Z","draft_created_at":"2026-01-28T14:55:08.649646Z","lead_time":35.287,"prediction":{},"result_count":1,"unique_id":"a0ec72a9-a601-41cc-8b00-3fd59040585f","import_id":null,"last_action":null,"bulk_created":false,"task":46,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"b78e933c-WhatsApp_Image_2026-01-28_at_11.05.58.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/b78e933c-WhatsApp_Image_2026-01-28_at_11.05.58.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:55:36.239673Z","allow_skip":true,"inner_id":37,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":47,"annotations":[{"id":37,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[24.93368700265252,23.47480106100796],[77.45358090185677,23.740053050397876],[74.97789566755084,81.43236074270557],[26.348364279398762,82.75862068965517]],"closed":true,"polygonlabels":["id_card"]},"id":"W2mjeiTr1j","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:54:56.000467Z","updated_at":"2026-01-28T14:54:56.000467Z","draft_created_at":"2026-01-28T14:54:49.423351Z","lead_time":16.072,"prediction":{},"result_count":1,"unique_id":"b051392e-5e11-4677-af9b-c6326e1d59f2","import_id":null,"last_action":null,"bulk_created":false,"task":47,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"958e4f9e-WhatsApp_Image_2026-01-28_at_11.06.00.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/958e4f9e-WhatsApp_Image_2026-01-28_at_11.06.00.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:54:56.060750Z","allow_skip":true,"inner_id":38,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":48,"annotations":[{"id":36,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[26.702033598585324,82.75862068965517],[73.03271441202475,82.89124668435014],[72.85587975243148,27.055702917771885],[24.933687002652515,27.18832891246684]],"closed":true,"polygonlabels":["id_card"]},"id":"RLayg_Xzcn","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:54:37.811138Z","updated_at":"2026-01-28T14:54:37.811138Z","draft_created_at":"2026-01-28T14:54:23.612032Z","lead_time":22.486,"prediction":{},"result_count":1,"unique_id":"89050832-f07d-4513-bf75-cfa6c6d755d7","import_id":null,"last_action":null,"bulk_created":false,"task":48,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"b6e88e21-WhatsApp_Image_2026-01-28_at_11.06.01.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/b6e88e21-WhatsApp_Image_2026-01-28_at_11.06.01.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:54:37.872278Z","allow_skip":true,"inner_id":39,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":49,"annotations":[{"id":35,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[24.892879004284836,86.10487655580495],[23.668639053254438,23.36257906549684],[78.35135686594572,23.464599061416042],[76.58301027001292,85.39073658437056]],"closed":true,"polygonlabels":["id_card"]},"id":"1NTk83VRU9","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:54:13.357656Z","updated_at":"2026-01-28T14:54:13.357656Z","draft_created_at":"2026-01-28T14:53:54.052229Z","lead_time":33.44,"prediction":{},"result_count":1,"unique_id":"e2ad20df-d339-4bfd-8245-4ec4f558200c","import_id":null,"last_action":null,"bulk_created":false,"task":49,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"53eb6a16-WhatsApp_Image_2026-01-28_at_11.06.04.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/53eb6a16-WhatsApp_Image_2026-01-28_at_11.06.04.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:54:13.417421Z","allow_skip":true,"inner_id":40,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":50,"annotations":[{"id":34,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[30.658316722385276,38.68912152935822],[78.68619172434718,37.11958313060128],[77.63983279184257,88.07150816944737],[35.05302423890467,89.95495424795568]],"closed":true,"polygonlabels":["id_card"]},"id":"0i67nOOXMr","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:53:36.995297Z","updated_at":"2026-01-28T14:53:36.995297Z","draft_created_at":"2026-01-28T14:53:17.322698Z","lead_time":29.291,"prediction":{},"result_count":1,"unique_id":"7f5db9ba-5911-48bf-b23c-96903d634fd9","import_id":null,"last_action":null,"bulk_created":false,"task":50,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"6f05cb34-WhatsApp_Image_2026-01-28_at_11.06.10.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/6f05cb34-WhatsApp_Image_2026-01-28_at_11.06.10.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:53:37.059149Z","allow_skip":true,"inner_id":41,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":51,"annotations":[{"id":33,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[44.51854812063874,31.886983576591653],[78.4044797040575,31.16258123870384],[78.79887653246307,70.5409715925623],[45.87881473289474,70.78243903852493]],"closed":true,"polygonlabels":["id_card"]},"id":"8v-h5Pxipx","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:52:52.731783Z","updated_at":"2026-01-28T14:52:52.731783Z","draft_created_at":"2026-01-28T14:52:21.143000Z","lead_time":41.349,"prediction":{},"result_count":1,"unique_id":"d873594d-3fca-4515-ad3f-5f2be9515969","import_id":null,"last_action":null,"bulk_created":false,"task":51,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"eb10cd35-WhatsApp_Image_2026-01-28_at_11.06.20.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/eb10cd35-WhatsApp_Image_2026-01-28_at_11.06.20.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:52:52.804395Z","allow_skip":true,"inner_id":42,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":52,"annotations":[{"id":32,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[16.672752221227416,18.594735354266362],[80.60413315227875,13.679148061456212],[80.60413315227873,94.39450571872526],[19.662349171240603,89.30644167879896]],"closed":true,"polygonlabels":["id_card"]},"id":"KX-TXJmtXd","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:52:06.567743Z","updated_at":"2026-01-28T14:52:06.567743Z","draft_created_at":"2026-01-28T14:51:40.991299Z","lead_time":38.365,"prediction":{},"result_count":1,"unique_id":"bfc75bbe-da27-4f62-b71b-f119eb7d1445","import_id":null,"last_action":null,"bulk_created":false,"task":52,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"01229e78-WhatsApp_Image_2026-01-28_at_11.06.33.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/01229e78-WhatsApp_Image_2026-01-28_at_11.06.33.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:52:06.633335Z","allow_skip":true,"inner_id":43,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":53,"annotations":[{"id":31,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[26.52922339642475,22.25557155948128],[78.60570257569299,22.315938420971936],[79.28181142438827,82.46113279622921],[28.41266947493306,83.78920374902354]],"closed":true,"polygonlabels":["id_card"]},"id":"dEnKC2Ml1u","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:51:11.224249Z","updated_at":"2026-01-28T14:51:11.224249Z","draft_created_at":"2026-01-28T14:50:40.595029Z","lead_time":41.364,"prediction":{},"result_count":1,"unique_id":"6bc11400-4ccf-4b78-8862-815c1931cc28","import_id":null,"last_action":null,"bulk_created":false,"task":53,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"a8d89f4f-WhatsApp_Image_2026-01-28_at_11.06.34_1.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/a8d89f4f-WhatsApp_Image_2026-01-28_at_11.06.34_1.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.986809Z","updated_at":"2026-01-28T14:51:11.277575Z","allow_skip":true,"inner_id":44,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":54,"annotations":[{"id":30,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[24.668544981254463,13.561165085205307],[79.0243094017577,11.878902775079688],[83.0663745133137,78.9541777552289],[23.925508410675413,79.4588564482666]],"closed":true,"polygonlabels":["id_card"]},"id":"OjcDkmFCZS","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:50:15.247373Z","updated_at":"2026-01-28T14:50:15.247373Z","draft_created_at":"2026-01-28T14:49:47.900058Z","lead_time":41.299,"prediction":{},"result_count":1,"unique_id":"2fa02e06-4503-43f6-b608-7ec052ac4c29","import_id":null,"last_action":null,"bulk_created":false,"task":54,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"e06a7198-WhatsApp_Image_2026-01-28_at_11.06.34_2.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/e06a7198-WhatsApp_Image_2026-01-28_at_11.06.34_2.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.991548Z","updated_at":"2026-01-28T14:50:15.305893Z","allow_skip":true,"inner_id":45,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":55,"annotations":[{"id":29,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[18.415917212081254,21.050649004127887],[75.86102260658473,19.951972124998036],[73.03585348882224,79.20361621647076],[26.57751688561727,80.06686233578706]],"closed":true,"polygonlabels":["id_card"]},"id":"UUMylbR5HW","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:49:30.926350Z","updated_at":"2026-01-28T14:49:30.926350Z","draft_created_at":"2026-01-28T14:49:13.567579Z","lead_time":28.487,"prediction":{},"result_count":1,"unique_id":"a7cc30c9-5ccd-4cf3-b009-4c71f65c6036","import_id":null,"last_action":null,"bulk_created":false,"task":55,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"9d8e669a-WhatsApp_Image_2026-01-28_at_11.06.34_3.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/9d8e669a-WhatsApp_Image_2026-01-28_at_11.06.34_3.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.991548Z","updated_at":"2026-01-28T14:49:30.984990Z","allow_skip":true,"inner_id":46,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":56,"annotations":[{"id":28,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[17.055650599825256,26.96702399824212],[66.44379221404316,25.78987019917442],[67.80405882629917,82.97050837348735],[21.345722223094185,83.44136989311446]],"closed":true,"polygonlabels":["id_card"]},"id":"e8AjZRbWur","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:48:59.733752Z","updated_at":"2026-01-28T14:48:59.733752Z","draft_created_at":"2026-01-28T14:48:38.300708Z","lead_time":31.451,"prediction":{},"result_count":1,"unique_id":"6c8cdb01-0983-4897-8de3-759b1625d6ce","import_id":null,"last_action":null,"bulk_created":false,"task":56,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"ed416253-WhatsApp_Image_2026-01-28_at_11.06.34.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/ed416253-WhatsApp_Image_2026-01-28_at_11.06.34.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.991548Z","updated_at":"2026-01-28T14:48:59.797437Z","allow_skip":true,"inner_id":47,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":57,"annotations":[{"id":27,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[26.41666666666666,9.562499999999996],[79.16666666666666,8.812499999999996],[81.83333333333331,73.125],[24.16666666666666,73.125]],"closed":true,"polygonlabels":["id_card"]},"id":"aM5WaoBJI0","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:48:11.187606Z","updated_at":"2026-01-28T14:48:11.187606Z","draft_created_at":"2026-01-28T14:47:51.725913Z","lead_time":35.679,"prediction":{},"result_count":1,"unique_id":"20a741ce-cdbf-4209-92b8-e6ad15a20668","import_id":null,"last_action":null,"bulk_created":false,"task":57,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"7f2fd10f-WhatsApp_Image_2026-01-28_at_11.06.35_1.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/7f2fd10f-WhatsApp_Image_2026-01-28_at_11.06.35_1.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.991548Z","updated_at":"2026-01-28T14:48:11.254836Z","allow_skip":true,"inner_id":48,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":58,"annotations":[{"id":26,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[14.323607427055704,12.864721485411138],[79.75243147656941,10.742705570291777],[79.22192749778957,90.05305039787798],[15.384615384615385,87.26790450928382]],"closed":true,"polygonlabels":["id_card"]},"id":"kO9XIErnKe","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:47:31.130877Z","updated_at":"2026-01-28T14:47:31.130877Z","draft_created_at":"2026-01-28T14:47:06.967177Z","lead_time":33.289,"prediction":{},"result_count":1,"unique_id":"d2ccbb7e-d251-4429-ae3b-fc0fd62611d4","import_id":null,"last_action":null,"bulk_created":false,"task":58,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"f0507490-WhatsApp_Image_2026-01-28_at_11.06.35_2.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/f0507490-WhatsApp_Image_2026-01-28_at_11.06.35_2.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.991548Z","updated_at":"2026-01-28T14:47:31.187134Z","allow_skip":true,"inner_id":49,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":59,"annotations":[{"id":25,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[38.31283475939981,15.816117710550554],[90.22833564135965,17.928957862723337],[90.38931393866805,78.0543519074117],[40.003106881138045,81.2537955664162]],"closed":true,"polygonlabels":["id_card"]},"id":"2nr4docsa8","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:46:55.132037Z","updated_at":"2026-01-28T14:46:55.132037Z","draft_created_at":"2026-01-28T14:46:45.618966Z","lead_time":22.225,"prediction":{},"result_count":1,"unique_id":"b86d0975-a0f7-471f-9d90-e3a09ed401c6","import_id":null,"last_action":null,"bulk_created":false,"task":59,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"5aa78e32-WhatsApp_Image_2026-01-28_at_11.06.35_3.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/5aa78e32-WhatsApp_Image_2026-01-28_at_11.06.35_3.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.991548Z","updated_at":"2026-01-28T14:46:55.229263Z","allow_skip":true,"inner_id":50,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":60,"annotations":[{"id":24,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[19.85667297299146,22.028652527137915],[22.13451587990536,87.8058939788885],[77.99398504592105,87.74552711739784],[76.30371292418282,21.00766779874654]],"closed":true,"polygonlabels":["id_card"]},"id":"LzCMVvjxnw","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:45:54.475304Z","updated_at":"2026-01-28T14:46:30.559419Z","draft_created_at":null,"lead_time":37.706,"prediction":{},"result_count":1,"unique_id":"09d90b82-2ffb-4578-bec5-743cf6ca9d8b","import_id":null,"last_action":null,"bulk_created":false,"task":60,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"f1054b66-WhatsApp_Image_2026-01-28_at_11.06.35_4.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/f1054b66-WhatsApp_Image_2026-01-28_at_11.06.35_4.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.992333Z","updated_at":"2026-01-28T14:46:30.661140Z","allow_skip":true,"inner_id":51,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":61,"annotations":[{"id":23,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[20.412048098705448,22.28026160583095],[76.59347385933796,20.710723207074025],[77.91349589726686,87.8058939788885],[22.05402673125116,87.6851602559072]],"closed":true,"polygonlabels":["id_card"]},"id":"neFILDCqEP","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:45:40.247595Z","updated_at":"2026-01-28T14:45:40.247595Z","draft_created_at":"2026-01-28T14:45:17.473078Z","lead_time":33.266,"prediction":{},"result_count":1,"unique_id":"b95ea83c-7114-4bba-afe6-11e21affa958","import_id":null,"last_action":null,"bulk_created":false,"task":61,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"27b78437-WhatsApp_Image_2026-01-28_at_11.06.35_5.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/27b78437-WhatsApp_Image_2026-01-28_at_11.06.35_5.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:39.992333Z","updated_at":"2026-01-28T14:45:40.305588Z","allow_skip":true,"inner_id":52,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":62,"annotations":[{"id":22,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[14.41932140775149,20.474377657128695],[65.37514397883429,16.062953163581124],[66.96397880624095,82.87220456788933],[16.90272121738227,79.6842571676593]],"closed":true,"polygonlabels":["id_card"]},"id":"dE-8JfPQMC","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:45:05.148496Z","updated_at":"2026-01-28T14:45:05.148496Z","draft_created_at":"2026-01-28T14:44:37.671944Z","lead_time":37.609,"prediction":{},"result_count":1,"unique_id":"f3fefe99-54aa-47cc-ab36-0479931d90ef","import_id":null,"last_action":null,"bulk_created":false,"task":62,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"a9458bd9-WhatsApp_Image_2026-01-28_at_11.06.35.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/a9458bd9-WhatsApp_Image_2026-01-28_at_11.06.35.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.013226Z","updated_at":"2026-01-28T14:45:05.204555Z","allow_skip":true,"inner_id":53,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":63,"annotations":[{"id":21,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[39.23633269790789,26.29930835344161],[40.244574327100636,71.8233607087881],[77.29204507958342,71.01354465095365],[77.06774343823334,26.743657237894414]],"closed":true,"polygonlabels":["id_card"]},"id":"Ahn0EYrr_r","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:44:25.317308Z","updated_at":"2026-01-28T14:44:25.317308Z","draft_created_at":"2026-01-28T14:43:50.334806Z","lead_time":46.328,"prediction":{},"result_count":1,"unique_id":"427061f5-f857-4182-85de-06cd92ff175e","import_id":null,"last_action":null,"bulk_created":false,"task":63,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"2a1bab9b-WhatsApp_Image_2026-01-28_at_11.06.36_1.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/2a1bab9b-WhatsApp_Image_2026-01-28_at_11.06.36_1.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.013226Z","updated_at":"2026-01-28T14:44:25.381550Z","allow_skip":true,"inner_id":54,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":64,"annotations":[{"id":20,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[8.253233473542332,21.40522537410505],[10.896992433184174,54.562355578088365],[80.38808476458934,52.660566546495645],[80.06050821758127,19.141565620353976]],"closed":true,"polygonlabels":["id_card"]},"id":"ddG80DdbUW","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:43:37.181188Z","updated_at":"2026-01-28T14:43:37.181188Z","draft_created_at":"2026-01-28T14:43:23.684205Z","lead_time":32.214,"prediction":{},"result_count":1,"unique_id":"05e0bf4e-764f-4e62-8c6f-835bff511fb5","import_id":null,"last_action":null,"bulk_created":false,"task":64,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"1cb2043a-WhatsApp_Image_2026-01-28_at_11.06.36_2.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/1cb2043a-WhatsApp_Image_2026-01-28_at_11.06.36_2.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.013226Z","updated_at":"2026-01-28T14:43:37.240750Z","allow_skip":true,"inner_id":55,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":65,"annotations":[{"id":19,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":270,"value":{"points":[[63.69354716896826,30.3492737713987],[32.23075593679226,30.988954014823967],[33.36796525843715,67.94825696828374],[64.92552393408359,67.66395463787254]],"closed":true,"polygonlabels":["id_card"]},"id":"b5cNvByM6x","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:43:02.060479Z","updated_at":"2026-01-28T14:43:02.060479Z","draft_created_at":"2026-01-28T14:42:41.290739Z","lead_time":35.94,"prediction":{},"result_count":1,"unique_id":"e414eefa-98ce-4089-bb09-68f48b48f3f2","import_id":null,"last_action":null,"bulk_created":false,"task":65,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"6d99fdb7-WhatsApp_Image_2026-01-28_at_11.06.36.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/6d99fdb7-WhatsApp_Image_2026-01-28_at_11.06.36.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.015475Z","updated_at":"2026-01-28T14:43:02.124016Z","allow_skip":true,"inner_id":56,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":66,"annotations":[{"id":18,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[29.37426210962503,71.26886398413683],[66.06493094999402,70.59554129827954],[66.24612131250205,26.01393993688118],[27.15536356420681,26.21873830798933]],"closed":true,"polygonlabels":["id_card"]},"id":"oaIsnBZAmx","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:42:22.248552Z","updated_at":"2026-01-28T14:42:22.248552Z","draft_created_at":"2026-01-28T14:41:48.010658Z","lead_time":47.363,"prediction":{},"result_count":1,"unique_id":"19760869-c82e-453e-b1ab-7ac85ea0a5ae","import_id":null,"last_action":null,"bulk_created":false,"task":66,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"dd45871f-WhatsApp_Image_2026-01-28_at_11.06.37_1.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/dd45871f-WhatsApp_Image_2026-01-28_at_11.06.37_1.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.015475Z","updated_at":"2026-01-28T14:42:22.309221Z","allow_skip":true,"inner_id":57,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":67,"annotations":[{"id":12,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":270,"value":{"points":[[67.77188328912467,18.79973474801061],[66.97612732095489,78.38196286472149],[18.965517241379292,78.87931034482757],[14.986737400530492,19.49602122015914]],"closed":true,"polygonlabels":["id_card"]},"id":"7iZ_Nw0gCQ","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:36:59.232899Z","updated_at":"2026-01-28T14:36:59.232899Z","draft_created_at":"2026-01-28T14:36:41.687041Z","lead_time":27.358,"prediction":{},"result_count":1,"unique_id":"f8869cbe-e18d-424a-b36b-2030e4d09dcb","import_id":null,"last_action":null,"bulk_created":false,"task":67,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"3df5a6ee-WhatsApp_Image_2026-01-28_at_11.06.37_2.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/3df5a6ee-WhatsApp_Image_2026-01-28_at_11.06.37_2.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.017980Z","updated_at":"2026-01-28T14:36:59.293155Z","allow_skip":true,"inner_id":58,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":68,"annotations":[{"id":11,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[24.348772359382437,34.36033462558662],[62.16418418009929,33.13609467455621],[63.66047745358089,78.0248928790043],[27.341358906345636,77.92287288308508]],"closed":true,"polygonlabels":["id_card"]},"id":"Be549WBxU_","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:36:19.683229Z","updated_at":"2026-01-28T14:36:19.683229Z","draft_created_at":"2026-01-28T14:36:07.563991Z","lead_time":21.541,"prediction":{},"result_count":1,"unique_id":"0f8fbbc7-af04-4aae-8760-4899caaae15f","import_id":null,"last_action":null,"bulk_created":false,"task":68,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"f8785ee4-WhatsApp_Image_2026-01-28_at_11.06.37.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/f8785ee4-WhatsApp_Image_2026-01-28_at_11.06.37.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.017980Z","updated_at":"2026-01-28T14:36:19.747315Z","allow_skip":true,"inner_id":59,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":69,"annotations":[{"id":8,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[14.323607427055704,40.58355437665783],[72.14854111405835,39.257294429708224],[72.6173099158204,66.49035518653963],[14.85829684156556,67.74598590554518]],"closed":true,"polygonlabels":["id_card"]},"id":"ZWkeq9T1ix","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:34:49.669072Z","updated_at":"2026-01-28T14:34:49.669072Z","draft_created_at":"2026-01-28T14:34:32.510551Z","lead_time":39.45,"prediction":{},"result_count":1,"unique_id":"89cacfdc-78dd-4ea9-a803-fb2ece4d552a","import_id":null,"last_action":null,"bulk_created":false,"task":69,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"4bc5117e-WhatsApp_Image_2026-01-28_at_11.06.38_1.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/4bc5117e-WhatsApp_Image_2026-01-28_at_11.06.38_1.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.017980Z","updated_at":"2026-01-28T14:34:49.733090Z","allow_skip":true,"inner_id":60,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":70,"annotations":[{"id":9,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":0,"value":{"points":[[4.597701149425287,34.48275862068966],[90.89301503094606,33.02387267904509],[92.13085764809902,74.13793103448276],[6.18921308576481,75.06631299734748]],"closed":true,"polygonlabels":["id_card"]},"id":"Hj_t85VU_L","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:35:16.554225Z","updated_at":"2026-01-28T14:35:16.554225Z","draft_created_at":"2026-01-28T14:35:01.999409Z","lead_time":23.256,"prediction":{},"result_count":1,"unique_id":"a6c88b82-9e49-4afe-befe-a97fab59cdb0","import_id":null,"last_action":null,"bulk_created":false,"task":70,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"d76b9b41-WhatsApp_Image_2026-01-28_at_11.06.38_2.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/d76b9b41-WhatsApp_Image_2026-01-28_at_11.06.38_2.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.017980Z","updated_at":"2026-01-28T14:35:16.613735Z","allow_skip":true,"inner_id":61,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]},{"id":71,"annotations":[{"id":10,"completed_by":1,"result":[{"original_width":1200,"original_height":1600,"image_rotation":270,"value":{"points":[[28.603006189213083,15.251989389920423],[71.35278514588857,14.953580901856762],[70.5128205128205,64.45623342175067],[29.48717948717949,64.45623342175067]],"closed":true,"polygonlabels":["id_card"]},"id":"pMocMAC2R7","from_name":"label","to_name":"image","type":"polygonlabels","origin":"manual"}],"was_cancelled":false,"ground_truth":false,"created_at":"2026-01-28T14:35:54.337038Z","updated_at":"2026-01-28T14:35:54.337038Z","draft_created_at":"2026-01-28T14:35:29.112629Z","lead_time":32.269,"prediction":{},"result_count":1,"unique_id":"a158b2b4-d6a6-43ae-bbe3-c0ebdaafdbcd","import_id":null,"last_action":null,"bulk_created":false,"task":71,"project":2,"updated_by":1,"parent_prediction":null,"parent_annotation":null,"last_created_by":null}],"file_upload":"ee9663f5-WhatsApp_Image_2026-01-28_at_11.06.38.jpeg","drafts":[],"predictions":[],"data":{"image":"\/data\/upload\/2\/ee9663f5-WhatsApp_Image_2026-01-28_at_11.06.38.jpeg"},"meta":{},"created_at":"2026-01-28T14:24:40.017980Z","updated_at":"2026-01-28T14:35:54.404470Z","allow_skip":true,"inner_id":62,"total_annotations":1,"cancelled_annotations":0,"total_predictions":0,"comment_count":0,"unresolved_comment_count":0,"last_comment_updated_at":null,"project":2,"updated_by":1,"comment_authors":[]}]
<FILE_END>

<FILE_START path="backend\tools\test_yolo_inference.py">
# backend/tools/test_yolo_inference.py
import sys
import os
import cv2
from pathlib import Path

# Aggiungiamo la root del backend al path per poter importare i moduli app.*
BASE_DIR = Path(__file__).resolve().parent.parent
sys.path.append(str(BASE_DIR))

from app.services.image_utils import isolate_document_yolo, cv2_to_pil, pil_to_cv2

def test_inference():
    print("üß† TEST INFERENZA YOLOv11...")
    
    # 1. Prendiamo un'immagine dal dataset di validazione generato prima
    val_dir = BASE_DIR / "datasets" / "id_cards" / "val" / "images"
    images = list(val_dir.glob("*.jpg"))
    
    if not images:
        print("‚ùå Nessuna immagine trovata in datasets/id_cards/val/images")
        return

    # Prendiamo la prima immagine
    target_img_path = images[0]
    print(f"üìÑ Test su immagine: {target_img_path.name}")
    
    # Carichiamo come PIL (come farebbe il backend)
    original_pil = cv2_to_pil(cv2.imread(str(target_img_path)))
    
    # 2. ESEGUIAMO LA MAGIA
    # Questa funzione ora usa il tuo modello id_card_detector_v11n.pt!
    try:
        cropped_pil = isolate_document_yolo(original_pil, debug_prefix="TEST_MANUALE")
    except Exception as e:
        print(f"‚ùå Errore durante l'inferenza: {e}")
        return

    if cropped_pil:
        print("‚úÖ SUCCESSO! Documento rilevato e raddrizzato.")
        
        # Salviamo il risultato per vederlo
        out_path = "test_result_cropped.jpg"
        pil_to_cv2(cropped_pil) # Riconvertiamo per salvare con cv2 se necessario, o usa save del PIL
        cropped_pil.save(out_path)
        print(f"üíæ Risultato salvato in: {os.path.abspath(out_path)}")
        print("   Aprilo e verifica che sia un rettangolo perfetto senza sfondo!")
    else:
        print("‚ùå FALLITO. Il modello non ha trovato nulla (o il file .pt non √® nel posto giusto).")

if __name__ == "__main__":
    test_inference()
<FILE_END>

<FILE_START path="backend\tools\train_yolo.py">
# backend/tools/train_yolo.py
from ultralytics import YOLO
import os

def train_document_detector():
    """
    Script per addestrare YOLOv11n-OBB sul dataset di documenti.
    Output: un modello .pt ottimizzato per il crop dei documenti.
    """
    # 1. Carica il modello pre-addestrato nano (pi√π veloce per CPU)
    # La versione -obb (Oriented Bounding Box) √® cruciale per documenti ruotati
    model = YOLO("yolo11n-obb.pt") 

    # 2. Configura i percorsi
    # Assicurati di avere un file dataset.yaml nel formato standard YOLO
    # che punta alle tue immagini annotate.
    dataset_yaml = "dataset.yaml" 
    
    if not os.path.exists(dataset_yaml):
        print("‚ùå ERRORE: File 'dataset.yaml' mancante.")
        print("   Crea un file YAML che punti alle cartelle 'train' e 'val' delle immagini annotate.")
        return

    print("üöÄ Avvio Training YOLOv11-OBB...")
    
    # 3. Avvia il training
    # epochs=100: un buon bilanciamento iniziale
    # imgsz=640: risoluzione standard
    # device='cpu' o '0' (se hai GPU Nvidia)
    results = model.train(
        data=dataset_yaml, 
        epochs=100, 
        imgsz=640, 
        patience=20,
        batch=16,
        project="rafting_republic_train",
        name="id_card_obb"
    )

    # 4. Export del modello migliore
    # Lo salviamo dove il backend se lo aspetta
    backend_model_dir = os.path.join("..", "assets", "models")
    os.makedirs(backend_model_dir, exist_ok=True)
    
    best_model_path = os.path.join("rafting_republic_train", "id_card_obb", "weights", "best.pt")
    dest_path = os.path.join(backend_model_dir, "id_card_detector_v11n.pt")
    
    if os.path.exists(best_model_path):
        import shutil
        shutil.copy2(best_model_path, dest_path)
        print(f"‚úÖ Modello salvato e pronto in: {dest_path}")
    else:
        print("‚ö†Ô∏è Training completato ma non trovo i pesi finali.")

if __name__ == "__main__":
    train_document_detector()
<FILE_END>

<FILE_START path="backend\tools\verify_paddle.py">
import os
import sys
import time
import numpy as np

# Disabilitiamo i log di debug e il check online
os.environ["GLOG_minloglevel"] = "2"
os.environ["DISABLE_MODEL_SOURCE_CHECK"] = "True"

print("‚è≥ [STEP 1] Avvio test di importazione librerie...")

try:
    # 1. Verifica Numpy
    print(f"‚úÖ Numpy importato. Versione: {np.__version__}")
    if int(np.__version__.split('.')[0]) >= 2:
        raise ImportError("‚ùå ERRORE FATALE: Numpy versione 2.x rilevata!")

    # 2. Import Core e Toolkit
    import paddle
    import paddleocr
    from paddleocr import PaddleOCR
    
    print(f"‚úÖ Paddle Core: {paddle.__version__}")
    print(f"‚úÖ Paddle OCR: {paddleocr.__version__}")

    # 3. Test Inferenza Dummy
    print("\n‚è≥ [STEP 2] Avvio Inferenza Dummy (Configurazione Sicura)...")

    # CONFIGURAZIONE SICURA PER PADDLEOCR v3.3.3
    ocr = PaddleOCR(
        use_textline_orientation=False, # Aggiornato da use_angle_cls
        lang='it', 
        use_gpu=False,
        enable_mkldnn=False             # Disabilitato per stabilit√† massima
    )
    
    img = np.zeros((100, 100, 3), dtype=np.uint8)
    
    start = time.time()
    result = ocr.ocr(img, cls=False)
    end = time.time()
    
    print(f"‚úÖ Inferenza completata in {end - start:.4f} secondi.")
    print("\nüéâ SISTEMA PRONTO E STABILE.")

except Exception as e:
    print(f"\n‚ùå ERRORE RUNTIME: {e}")
    sys.exit(1)
<FILE_END>

<FILE_START path="backend\tools\zone_calibrator.py">
import cv2
import json
import sys
import os

# --- CONFIGURAZIONE ROBUSTA DEI PERCORSI ---
# Ottiene la cartella dove si trova questo script (backend/tools)
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
# Risale alla cartella padre (backend)
BACKEND_DIR = os.path.dirname(CURRENT_DIR)
# Costruisce il percorso assoluto verso l'immagine
TEMPLATE_PATH = os.path.join(BACKEND_DIR, "assets", "templates", "Model_CIE_retro.jpg")

WINDOW_NAME = "Rafting Republic - Zone Calibrator"

def calibrate_template(image_path):
    print(f"Cercando immagine in: {image_path}")
    
    if not os.path.exists(image_path):
        print(f"‚ùå ERRORE: Immagine non trovata.")
        print(f"Assicurati di aver messo 'cie_front.jpg' in: {os.path.dirname(image_path)}")
        return

    # Carica immagine
    img = cv2.imread(image_path)
    if img is None:
        print("‚ùå ERRORE: OpenCV non riesce ad aprire l'immagine (formato non valido o file corrotto).")
        return

    h, w = img.shape[:2]
    print(f"\n--- CALIBRAZIONE AVVIATA ---")
    print(f"Immagine: {w}x{h}")
    print("\nISTRUZIONI:")
    print("1. Si aprir√† una finestra con l'immagine.")
    print("2. Usa il mouse per disegnare un rettangolo attorno al dato (es. Cognome).")
    print("3. Premi SPAZIO o INVIO per confermare la selezione.")
    print("4. Torna qui nella console e scrivi il nome del campo (es. 'cognome').")
    print("5. Premi 'c' per cancellare una selezione errata.")
    print("6. Premi 'q' (o Esc) sulla finestra immagine per terminare e generare il JSON.")
    print("----------------------------")

    zones = {}

    while True:
        # Usa la funzione nativa di OpenCV per selezionare ROI
        try:
            rect = cv2.selectROI(WINDOW_NAME, img, showCrosshair=True)
        except KeyboardInterrupt:
            break
        
        # rect √® una tupla (x, y, w, h)
        x, y, rw, rh = rect

        # Se l'utente preme 'q' o chiude, esce (w e h sono 0)
        if rw == 0 or rh == 0:
            print("\nFine selezione.")
            break

        print(f"\nSelezione rilevata: x={x}, y={y}, w={rw}, h={rh}")
        field_name = input("Nome campo (es. 'cognome') o 'skip' per annullare: ").strip()

        if field_name.lower() == 'skip' or not field_name:
            print("Selezione ignorata.")
            continue

        # Calcolo percentuali (4 decimali di precisione)
        p_x = round(x / w, 4)
        p_y = round(y / h, 4)
        p_w = round(rw / w, 4)
        p_h = round(rh / h, 4)

        zones[field_name] = (p_x, p_y, p_w, p_h)
        print(f"‚úÖ Campo '{field_name}' salvato in memoria.")

        # Disegna rettangolo di conferma sull'immagine (visuale)
        cv2.rectangle(img, (x, y), (x+rw, y+rh), (0, 255, 0), 2)
        cv2.putText(img, field_name, (x, y - 5), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)

    cv2.destroyAllWindows()

    if zones:
        print("\n\n=== COPIA QUESTO JSON IN local_vision_service.py ===")
        print(json.dumps(zones, indent=4))
        print("====================================================")
    else:
        print("\nNessuna zona selezionata.")

if __name__ == "__main__":
    # Se passi il file come argomento usa quello, altrimenti il default calcolato
    path = sys.argv[1] if len(sys.argv) > 1 else TEMPLATE_PATH
    calibrate_template(path)
<FILE_END>

<FILE_START path="web-app\.prettierrc.json">
{
  "$schema": "https://json.schemastore.org/prettierrc",
  "semi": false,
  "singleQuote": true,
  "printWidth": 100
}
<FILE_END>

<FILE_START path="web-app\eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import pluginVue from 'eslint-plugin-vue'
import pluginQuasar from '@quasar/app-vite/eslint'
import prettierSkipFormatting from '@vue/eslint-config-prettier/skip-formatting'

export default [
  {
    /**
     * Ignore the following files.
     * Please note that pluginQuasar.configs.recommended() already ignores
     * the "node_modules" folder for you (and all other Quasar project
     * relevant folders and files).
     *
     * ESLint requires "ignores" key to be the only one in this object
     */
    // ignores: []
  },

  ...pluginQuasar.configs.recommended(),
  js.configs.recommended,

  /**
   * https://eslint.vuejs.org
   *
   * pluginVue.configs.base
   *   -> Settings and rules to enable correct ESLint parsing.
   * pluginVue.configs[ 'flat/essential']
   *   -> base, plus rules to prevent errors or unintended behavior.
   * pluginVue.configs["flat/strongly-recommended"]
   *   -> Above, plus rules to considerably improve code readability and/or dev experience.
   * pluginVue.configs["flat/recommended"]
   *   -> Above, plus rules to enforce subjective community defaults to ensure consistency.
   */
  ...pluginVue.configs['flat/essential'],

  {
    languageOptions: {
      ecmaVersion: 'latest',
      sourceType: 'module',

      globals: {
        ...globals.browser,
        ...globals.node, // SSR, Electron, config files
        process: 'readonly', // process.env.*
        ga: 'readonly', // Google Analytics
        cordova: 'readonly',
        Capacitor: 'readonly',
        chrome: 'readonly', // BEX related
        browser: 'readonly', // BEX related
      },
    },

    // add your custom rules here
    rules: {
      'prefer-promise-reject-errors': 'off',

      // allow debugger during development only
      'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    },
  },

  {
    files: ['src-pwa/custom-service-worker.js'],
    languageOptions: {
      globals: {
        ...globals.serviceworker,
      },
    },
  },

  prettierSkipFormatting,
]
<FILE_END>

<FILE_START path="web-app\index.html">
<!doctype html>
<html>
  <head>
    <title><%= productName %></title>

    <meta charset="utf-8" />
    <meta name="description" content="<%= productDescription %>" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-tap-highlight" content="no" />
    <meta
      name="viewport"
      content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width<% if (ctx.mode.cordova || ctx.mode.capacitor) { %>, viewport-fit=cover<% } %>"
    />

    <link rel="icon" type="image/png" sizes="128x128" href="icons/favicon-128x128.png" />
    <link rel="icon" type="image/png" sizes="96x96" href="icons/favicon-96x96.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png" />
    <link rel="icon" type="image/ico" href="favicon.ico" />
  </head>
  <body>
    <!-- quasar:entry-point -->
  </body>
</html>
<FILE_END>

<FILE_START path="web-app\jsconfig.json">
{
  "extends": "./.quasar/tsconfig.json"
}
<FILE_END>

<FILE_START path="web-app\package.json">
{
  "name": "web-app",
  "version": "0.0.1",
  "description": "A Quasar Project",
  "productName": "Quasar App",
  "author": "Theollotti <bellottitheo1@gmail.com>",
  "type": "module",
  "private": true,
  "scripts": {
    "lint": "eslint -c ./eslint.config.js \"./src*/**/*.{js,cjs,mjs,vue}\"",
    "format": "prettier --write \"**/*.{js,vue,scss,html,md,json}\" --ignore-path .gitignore",
    "test": "echo \"No test specified\" && exit 0",
    "dev": "quasar dev",
    "build": "quasar build",
    "postinstall": "quasar prepare"
  },
  "dependencies": {
    "axios": "^1.2.1",
    "pinia": "^3.0.1",
    "@quasar/extras": "^1.16.4",
    "quasar": "^2.16.0",
    "vue": "^3.5.22",
    "vue-router": "^4.0.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.14.0",
    "eslint": "^9.14.0",
    "eslint-plugin-vue": "^10.4.0",
    "globals": "^16.4.0",
    "vite-plugin-checker": "^0.11.0",
    "vue-eslint-parser": "^10.2.0",
    "@vue/eslint-config-prettier": "^10.1.0",
    "prettier": "^3.3.3",
    "@quasar/app-vite": "^2.1.0",
    "autoprefixer": "^10.4.2",
    "postcss": "^8.4.14"
  },
  "engines": {
    "node": "^28 || ^26 || ^24 || ^22 || ^20",
    "npm": ">= 6.13.4",
    "yarn": ">= 1.21.1"
  }
}
<FILE_END>

<FILE_START path="web-app\postcss.config.js">
// https://github.com/michael-ciniawsky/postcss-load-config

import autoprefixer from 'autoprefixer'
// import rtlcss from 'postcss-rtlcss'

export default {
  plugins: [
    // https://github.com/postcss/autoprefixer
    autoprefixer({
      overrideBrowserslist: [
        'last 4 Chrome versions',
        'last 4 Firefox versions',
        'last 4 Edge versions',
        'last 4 Safari versions',
        'last 4 Android versions',
        'last 4 ChromeAndroid versions',
        'last 4 FirefoxAndroid versions',
        'last 4 iOS versions',
      ],
    }),

    // https://github.com/elchininet/postcss-rtlcss
    // If you want to support RTL css, then
    // 1. yarn/pnpm/bun/npm install postcss-rtlcss
    // 2. optionally set quasar.config.js > framework > lang to an RTL language
    // 3. uncomment the following line (and its import statement above):
    // rtlcss()
  ],
}
<FILE_END>

<FILE_START path="web-app\quasar.config.js">
// Configuration for your app
// https://v2.quasar.dev/quasar-cli-vite/quasar-config-file

import { defineConfig } from '#q-app/wrappers'

export default defineConfig((/* ctx */) => {
  return {
    // https://v2.quasar.dev/quasar-cli-vite/prefetch-feature
    // preFetch: true,

    // app boot file (/src/boot)
    // --> boot files are part of "main.js"
    // https://v2.quasar.dev/quasar-cli-vite/boot-files
    boot: ['axios'],

    // https://v2.quasar.dev/quasar-cli-vite/quasar-config-file#css
    css: ['app.scss'],

    // https://github.com/quasarframework/quasar/tree/dev/extras
    extras: [
      // 'ionicons-v4',
      // 'mdi-v7',
      // 'fontawesome-v6',
      // 'eva-icons',
      // 'themify',
      // 'line-awesome',
      // 'roboto-font-latin-ext', // this or either 'roboto-font', NEVER both!

      'roboto-font', // optional, you are not bound to it
      'material-icons', // optional, you are not bound to it
    ],

    // Full list of options: https://v2.quasar.dev/quasar-cli-vite/quasar-config-file#build
    build: {
      target: {
        browser: ['es2022', 'firefox115', 'chrome115', 'safari14'],
        node: 'node20',
      },

      vueRouterMode: 'hash', // available values: 'hash', 'history'
      // vueRouterBase,
      // vueDevtools,
      // vueOptionsAPI: false,

      // rebuildCache: true, // rebuilds Vite/linter/etc cache on startup

      // publicPath: '/',
      // analyze: true,
      // env: {},
      // rawDefine: {}
      // ignorePublicFolder: true,
      // minify: false,
      // polyfillModulePreload: true,
      // distDir

      // extendViteConf (viteConf) {},
      // viteVuePluginOptions: {},

      vitePlugins: [
        [
          'vite-plugin-checker',
          {
            eslint: {
              lintCommand: 'eslint -c ./eslint.config.js "./src*/**/*.{js,mjs,cjs,vue}"',
              useFlatConfig: true,
            },
          },
          { server: false },
        ],
      ],
    },

    // Full list of options: https://v2.quasar.dev/quasar-cli-vite/quasar-config-file#devserver
    devServer: {
      open: true, // apre il browser in automatico
      proxy: {
        '/api': {
        target: 'http://127.0.0.1:8000', // Indirizzo del tuo Backend Python
        changeOrigin: true,
        secure: false
        }
      } 
    },

    // https://v2.quasar.dev/quasar-cli-vite/quasar-config-file#framework
    framework: {
      config: {},

      // iconSet: 'material-icons', // Quasar icon set
      // lang: 'en-US', // Quasar language pack

      // For special cases outside of where the auto-import strategy can have an impact
      // (like functional components as one of the examples),
      // you can manually specify Quasar components/directives to be available everywhere:
      //
      // components: [],
      // directives: [],

      // Quasar plugins
      plugins: [
        'Notify'
      ]
    },

    // animations: 'all', // --- includes all animations
    // https://v2.quasar.dev/options/animations
    animations: [],

    // https://v2.quasar.dev/quasar-cli-vite/quasar-config-file#sourcefiles
    // sourceFiles: {
    //   rootComponent: 'src/App.vue',
    //   router: 'src/router/index',
    //   store: 'src/store/index',
    //   pwaRegisterServiceWorker: 'src-pwa/register-service-worker',
    //   pwaServiceWorker: 'src-pwa/custom-service-worker',
    //   pwaManifestFile: 'src-pwa/manifest.json',
    //   electronMain: 'src-electron/electron-main',
    //   electronPreload: 'src-electron/electron-preload'
    //   bexManifestFile: 'src-bex/manifest.json
    // },

    // https://v2.quasar.dev/quasar-cli-vite/developing-ssr/configuring-ssr
    ssr: {
      prodPort: 3000, // The default port that the production server should use
      // (gets superseded if process.env.PORT is specified at runtime)

      middlewares: [
        'render', // keep this as last one
      ],

      // extendPackageJson (json) {},
      // extendSSRWebserverConf (esbuildConf) {},

      // manualStoreSerialization: true,
      // manualStoreSsrContextInjection: true,
      // manualStoreHydration: true,
      // manualPostHydrationTrigger: true,

      pwa: false,
      // pwaOfflineHtmlFilename: 'offline.html', // do NOT use index.html as name!

      // pwaExtendGenerateSWOptions (cfg) {},
      // pwaExtendInjectManifestOptions (cfg) {}
    },

    // https://v2.quasar.dev/quasar-cli-vite/developing-pwa/configuring-pwa
    pwa: {
      workboxMode: 'GenerateSW', // 'GenerateSW' or 'InjectManifest'
      // swFilename: 'sw.js',
      // manifestFilename: 'manifest.json',
      // extendManifestJson (json) {},
      // useCredentialsForManifestTag: true,
      // injectPwaMetaTags: false,
      // extendPWACustomSWConf (esbuildConf) {},
      // extendGenerateSWOptions (cfg) {},
      // extendInjectManifestOptions (cfg) {}
    },

    // Full list of options: https://v2.quasar.dev/quasar-cli-vite/developing-cordova-apps/configuring-cordova
    cordova: {
      // noIosLegacyBuildFlag: true, // uncomment only if you know what you are doing
    },

    // Full list of options: https://v2.quasar.dev/quasar-cli-vite/developing-capacitor-apps/configuring-capacitor
    capacitor: {
      hideSplashscreen: true,
    },

    // Full list of options: https://v2.quasar.dev/quasar-cli-vite/developing-electron-apps/configuring-electron
    electron: {
      // extendElectronMainConf (esbuildConf) {},
      // extendElectronPreloadConf (esbuildConf) {},

      // extendPackageJson (json) {},

      // Electron preload scripts (if any) from /src-electron, WITHOUT file extension
      preloadScripts: ['electron-preload'],

      // specify the debugging port to use for the Electron app when running in development mode
      inspectPort: 5858,

      bundler: 'packager', // 'packager' or 'builder'

      packager: {
        // https://github.com/electron-userland/electron-packager/blob/master/docs/api.md#options
        // OS X / Mac App Store
        // appBundleId: '',
        // appCategoryType: '',
        // osxSign: '',
        // protocol: 'myapp://path',
        // Windows only
        // win32metadata: { ... }
      },

      builder: {
        // https://www.electron.build/configuration/configuration

        appId: 'web-app',
      },
    },

    // Full list of options: https://v2.quasar.dev/quasar-cli-vite/developing-browser-extensions/configuring-bex
    bex: {
      // extendBexScriptsConf (esbuildConf) {},
      // extendBexManifestJson (json) {},

      /**
       * The list of extra scripts (js/ts) not in your bex manifest that you want to
       * compile and use in your browser extension. Maybe dynamic use them?
       *
       * Each entry in the list should be a relative filename to /src-bex/
       *
       * @example [ 'my-script.ts', 'sub-folder/my-other-script.js' ]
       */
      extraScripts: [],
    },
  }
})
<FILE_END>

<FILE_START path="web-app\README.md">
# Quasar App (web-app)

A Quasar Project

## Install the dependencies

```bash
yarn
# or
npm install
```

### Start the app in development mode (hot-code reloading, error reporting, etc.)

```bash
quasar dev
```

### Lint the files

```bash
yarn lint
# or
npm run lint
```

### Format the files

```bash
yarn format
# or
npm run format
```

### Build the app for production

```bash
quasar build
```

### Customize the configuration

See [Configuring quasar.config.js](https://v2.quasar.dev/quasar-cli-vite/quasar-config-js).
<FILE_END>

<FILE_START path="web-app\src\App.vue">
<template>
  <router-view />
</template>

<script>
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'App',
})
</script>
<FILE_END>

<FILE_START path="web-app\src\boot\axios.js">
import { boot } from 'quasar/wrappers'
import axios from 'axios'

// Creiamo un'istanza di axios con l'URL base del tuo backend Python
// Se il backend gira su una porta diversa da 8000, cambiala qui!
const api = axios.create({ baseURL: 'http://127.0.0.1:8000/api/v1' })

export default boot(({ app }) => {
  // Rende l'api disponibile globalmente nell'app (es. this.$api)
  app.config.globalProperties.$axios = axios
  app.config.globalProperties.$api = api
})

export { api }
<FILE_END>

<FILE_START path="web-app\src\components\CameraCapture.vue">
<template>
  <div class="camera-wrapper">
    <video 
      ref="video" 
      autoplay 
      playsinline 
      class="video-feed" 
      :class="{'mirrored': !isBackCamera, 'flash-effect': isFlashing}"
    ></video>
    
    <canvas ref="analysisCanvas" style="display: none;"></canvas>

    <div class="overlay-guide" :class="[docType, stateClass]">
      <div class="guide-border">
        <div class="guide-feedback transition-generic" v-if="feedbackMessage">
          <q-icon :name="feedbackIcon" size="sm" class="q-mr-xs" />
          {{ feedbackMessage }}
        </div>
      </div>
    </div>

    <div class="controls row justify-center items-center q-gutter-md">
      <q-btn round color="negative" icon="close" @click="stopCameraAndClose" />
      
      <q-btn round color="white" text-color="dark" icon="cameraswitch" @click="switchCamera" />
      
      <div class="relative-position">
        <q-circular-progress
          v-show="cameraState === 'ACQUIRING'"
          :value="acquireProgress"
          size="74px"
          thickness="0.15"
          color="green-5"
          track-color="transparent"
          class="absolute-center"
          show-value
        />
        
        <q-btn 
          round 
          :color="cameraState === 'ACQUIRING' ? 'yellow-9' : 'primary'" 
          icon="camera" 
          size="lg" 
          @click="forceCapture" 
        >
          <q-tooltip>Scatto Manuale</q-tooltip>
        </q-btn>
      </div>
    </div>

    <div v-if="showDebug" class="debug-overlay">
      <div>Blur: {{ debugMetrics.blur }} (Min: {{ THRESHOLDS.BLUR }})</div>
      <div>Bright: {{ debugMetrics.brightness }}</div>
      <div>Stable: {{ debugMetrics.stability }}</div>
      <div>State: {{ cameraState }}</div>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, computed } from 'vue'
import ImageQualityService from 'src/services/ImageQualityService'

const props = defineProps({
  docType: { type: String, default: 'CIE' }
})
const emit = defineEmits(['capture', 'close'])

// --- Configurazione Soglie (Tuning Empirico) ---
// Riferimento Strategia Sez 3.1, 3.2, 3.3
const THRESHOLDS = {
  BLUR: 250,          // Sotto questo valore √® sfocata (Varianza Laplaciano)
  BRIGHT_MIN: 60,     // Troppo scura
  BRIGHT_MAX: 230,    // Troppo chiara/sovraesposta
  STABILITY: 15,      // Differenza pixel tra frame (basso = stabile)
  DWELL_TIME: 1200    // Millisecondi di stabilit√† per scattare
}

// --- Stati ---
const video = ref(null)
const analysisCanvas = ref(null)
const stream = ref(null)
const isBackCamera = ref(true)
const isFlashing = ref(false)
const showDebug = ref(false) // Mettere true per debuggare i valori

// FSM: 'SEARCHING' | 'ACQUIRING' | 'LOCKED' | 'ERROR'
const cameraState = ref('SEARCHING') 
const acquireProgress = ref(0)
const feedbackMessage = ref('Inquadra il documento')
const feedbackIcon = ref('center_focus_strong')

// Variabili Loop Analisi
let analysisInterval = null
let lastFrameGray = null
let acquiringStartTime = 0

// Metriche reattive per debug
const debugMetrics = ref({ blur: 0, brightness: 0, stability: 0 })

// --- Computed UI ---
const stateClass = computed(() => {
  if (cameraState.value === 'ACQUIRING') return 'state-acquiring'
  if (cameraState.value === 'LOCKED') return 'state-locked'
  return 'state-searching'
})

// --- Gestione Fotocamera ---

async function startCamera() {
  stopCamera()
  
  // Richiesta FullHD per OCR ottimale
  const constraints = {
    video: {
      facingMode: isBackCamera.value ? 'environment' : 'user',
      width: { ideal: 1920 },
      height: { ideal: 1080 },
      focusMode: 'continuous' // Tentativo di forzare autofocus
    }
  }
  
  try {
    stream.value = await navigator.mediaDevices.getUserMedia(constraints)
    if (video.value) {
      video.value.srcObject = stream.value
      // Attendiamo che il video sia pronto prima di partire con l'analisi
      video.value.onloadedmetadata = () => {
        video.value.play()
        startAnalysisLoop()
      }
    }
  } catch (err) {
    console.error("Errore Camera:", err)
    feedbackMessage.value = "Errore accesso fotocamera"
    cameraState.value = 'ERROR'
  }
}

function stopCamera() {
  stopAnalysisLoop()
  if (stream.value) {
    stream.value.getTracks().forEach(track => track.stop())
    stream.value = null
  }
}

function stopCameraAndClose() {
  stopCamera()
  emit('close')
}

function switchCamera() {
  isBackCamera.value = !isBackCamera.value
  startCamera()
}

// --- Core Intelligence: Il Loop di Analisi ---

function startAnalysisLoop() {
  if (analysisInterval) clearInterval(analysisInterval)
  
  // Eseguiamo l'analisi ogni 150ms (~6-7 FPS) per non uccidere la CPU
  analysisInterval = setInterval(() => {
    if (!video.value || !analysisCanvas.value || cameraState.value === 'LOCKED') return
    
    processFrame()
  }, 150)
}

function stopAnalysisLoop() {
  if (analysisInterval) clearInterval(analysisInterval)
  analysisInterval = null
}

function processFrame() {
  const vid = video.value
  const can = analysisCanvas.value
  
  // Sincronizza dimensioni (fondamentale per i calcoli)
  // Usiamo una risoluzione ridotta per l'analisi per velocit√† (downsampling)
  const analysisWidth = 480 
  const scale = analysisWidth / vid.videoWidth
  const analysisHeight = vid.videoHeight * scale
  
  can.width = analysisWidth
  can.height = analysisHeight
  
  const ctx = can.getContext('2d', { willReadFrequently: true })
  ctx.drawImage(vid, 0, 0, can.width, can.height)
  
  try {
    const imageData = ctx.getImageData(0, 0, can.width, can.height)
    
    // Invocazione Service "Pure JS"
    const result = ImageQualityService.analyzeFrame(imageData, lastFrameGray)
    
    // Aggiorna buffer per il prossimo frame (Motion Detection)
    lastFrameGray = result.grayBuffer
    
    // Aggiorna metriche per logica
    const m = result.metrics
    debugMetrics.value = m // Per UI debug
    
    evaluateQuality(m)
    
  } catch (e) {
    console.warn("Frame analysis error:", e)
  }
}

// --- Macchina a Stati Decisionale (Logic Gatekeeper) ---

function evaluateQuality(metrics) {
  const isStable = metrics.stability < THRESHOLDS.STABILITY
  const isSharp = metrics.blurScore > THRESHOLDS.BLUR
  const isBrightEnough = metrics.brightness > THRESHOLDS.BRIGHT_MIN
  const isNotTooBright = metrics.brightness < THRESHOLDS.BRIGHT_MAX
  
  // 1. Check Errori Bloccanti
  if (!isBrightEnough) {
    resetAcquisition('Troppo buio üåë', 'brightness_low')
    return
  }
  if (!isNotTooBright) {
    resetAcquisition('Troppo chiaro / Riflessi ‚òÄÔ∏è', 'brightness_high')
    return
  }
  
  // 2. Check Movimento
  if (!isStable) {
    resetAcquisition('Tieni fermo il telefono ‚úã', 'vibration')
    return
  }
  
  // 3. Check Fuoco (Solo se stabile)
  if (!isSharp) {
    resetAcquisition('Metti a fuoco (Tocca schermo) üéØ', 'blur_on')
    return
  }
  
  // 4. Tutto OK -> Transizione ACQUIRING -> LOCKED
  if (cameraState.value !== 'ACQUIRING') {
    // Entra in stato acquisizione
    cameraState.value = 'ACQUIRING'
    acquiringStartTime = Date.now()
    feedbackMessage.value = 'Non muoverti...'
    feedbackIcon.value = 'timer'
  } else {
    // Siamo gi√† in acquisizione, aggiorna progresso
    const elapsed = Date.now() - acquiringStartTime
    const progress = Math.min(100, (elapsed / THRESHOLDS.DWELL_TIME) * 100)
    acquireProgress.value = progress
    
    if (elapsed >= THRESHOLDS.DWELL_TIME) {
      // Successo! Scatto automatico
      captureImage(true)
    }
  }
}

function resetAcquisition(msg, icon) {
  if (cameraState.value === 'ACQUIRING') {
    // Interruzione durante il caricamento
    acquireProgress.value = 0
  }
  cameraState.value = 'SEARCHING'
  feedbackMessage.value = msg
  feedbackIcon.value = icon
}

// --- Cattura ---

function forceCapture() {
  // Scatto manuale (Escape Hatch)
  captureImage(false)
}

function captureImage(isAuto) {
  if (cameraState.value === 'LOCKED') return // Gi√† preso
  
  stopAnalysisLoop()
  cameraState.value = 'LOCKED'
  feedbackMessage.value = isAuto ? 'Preso! ‚úÖ' : 'Scatto Manuale üì∏'
  acquireProgress.value = 100
  
  // Effetto Flash Visivo
  isFlashing.value = true
  setTimeout(() => isFlashing.value = false, 300)
  
  // Cattura alla MASSIMA risoluzione (dal video source, non dal canvas di analisi)
  const vid = video.value
  const fullCanvas = document.createElement('canvas')
  fullCanvas.width = vid.videoWidth
  fullCanvas.height = vid.videoHeight
  
  const ctx = fullCanvas.getContext('2d')
  
  // Gestione mirroring fronte/retro
  if (!isBackCamera.value) {
    ctx.translate(fullCanvas.width, 0)
    ctx.scale(-1, 1)
  }
  
  ctx.drawImage(vid, 0, 0, fullCanvas.width, fullCanvas.height)
  
  fullCanvas.toBlob((blob) => {
    // Crea file e invia al genitore
    const file = new File([blob], `scan_${props.docType}_${Date.now()}.jpg`, { type: "image/jpeg" })
    
    // Piccolo delay per far vedere l'animazione di successo
    setTimeout(() => {
      emit('capture', file)
      stopCamera() // Importante: rilascia risorse
    }, 500)
    
  }, 'image/jpeg', 0.95) // Max qualit√† per backend OCR
}

onMounted(() => {
  startCamera()
})

onUnmounted(() => {
  stopCamera()
})
</script>

<style scoped>
.camera-wrapper {
  position: relative;
  width: 100%;
  height: 60vh; /* Responsive height */
  min-height: 400px;
  background: #000;
  overflow: hidden;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
}

.video-feed {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: opacity 0.1s;
}

.mirrored {
  transform: scaleX(-1);
}

.flash-effect {
  opacity: 0.2;
  filter: brightness(10);
}

/* OVERLAY GUIDE & STATES */
.overlay-guide {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none; /* Lascia passare i click */
  transition: all 0.3s ease;
}

.guide-border {
  border: 3px solid rgba(255, 255, 255, 0.6); /* Default Searching */
  box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6); /* Darken outside */
  border-radius: 16px;
  position: relative;
  transition: border-color 0.3s ease, transform 0.2s ease;
}

/* State Colors */
.state-searching .guide-border { border-color: rgba(255, 255, 255, 0.8); }
.state-acquiring .guide-border { border-color: #fdd835; /* Yellow */ transform: scale(1.02); }
.state-locked .guide-border { border-color: #21ba45; /* Green */ box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.8); }

/* Feedback Text pill */
.guide-feedback {
  position: absolute;
  bottom: -50px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 6px 12px;
  border-radius: 20px;
  white-space: nowrap;
  font-weight: 500;
  font-size: 0.95rem;
  display: flex;
  align-items: center;
}

/* Aspect Ratios per Doc Type */
.CIE .guide-border, .PATENTE_IT .guide-border, .CI_CARTACEA .guide-border, .PERMESSO_SOGGIORNO .guide-border {
  width: 85%;
  aspect-ratio: 85.6 / 53.98; 
  max-width: 500px;
}
.PASSAPORTO .guide-border {
  width: 80%;
  aspect-ratio: 125 / 88; /* Passaporto aperto */
  max-width: 500px;
}

.controls {
  position: absolute;
  bottom: 30px;
  width: 100%;
  z-index: 10;
  pointer-events: auto;
}

.debug-overlay {
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0,0,0,0.5);
  color: lime;
  font-family: monospace;
  font-size: 10px;
  padding: 4px;
  pointer-events: none;
}

/* Transition Utility */
.transition-generic { transition: all 0.3s ease; }
</style>
<FILE_END>

<FILE_START path="web-app\src\components\ModuleCard.vue">
<template>
  <q-card class="cursor-pointer q-hoverable transition-generic" v-ripple @click="$emit('click')">
    <q-card-section class="flex flex-center column q-py-lg">
      <div
        class="flex flex-center q-mb-md"
        :style="`background-color: ${hexToRgba(color, 0.1)}; width: 60px; height: 60px; border-radius: 50%;`"
      >
        <q-icon :name="icon" size="30px" :style="`color: ${color}`" />
      </div>

      <div class="text-subtitle1 text-weight-bold">{{ title }}</div>
      <div v-if="caption" class="text-caption text-grey-7 q-mt-xs text-center">
        {{ caption }}
      </div>
    </q-card-section>
  </q-card>
</template>

<script setup>
defineProps({
  title: { type: String, required: true },
  icon: { type: String, required: true },
  color: { type: String, default: '#1976D2' },
  caption: { type: String, default: '' }
})

defineEmits(['click'])

function hexToRgba (hex, alpha) {
  if (!hex || typeof hex !== 'string' || !hex.startsWith('#') || hex.length !== 7) {
    return `rgba(0, 0, 0, ${alpha})`
  }
  const r = parseInt(hex.slice(1, 3), 16)
  const g = parseInt(hex.slice(3, 5), 16)
  const b = parseInt(hex.slice(5, 7), 16)
  return `rgba(${r}, ${g}, ${b}, ${alpha})`
}
</script>

<style scoped>
.transition-generic { transition: transform 0.2s; }
.transition-generic:hover { transform: translateY(-5px); }
</style>
<FILE_END>

<FILE_START path="web-app\src\components\scanner\PersonForm.vue">
<template>
  <div class="row q-col-gutter-sm">
    <div class="col-12 col-md-6">
      <q-input 
        :model-value="modelValue.nome" 
        v-on:update:model-value="v => update('nome', v)" 
        :label="t.person.name" 
        outlined dense :readonly="readonly" 
        :rules="[val => !!val || t.errors.required]" 
      />
    </div>
    <div class="col-12 col-md-6">
      <q-input 
        :model-value="modelValue.cognome" 
        v-on:update:model-value="v => update('cognome', v)" 
        :label="t.person.surname" 
        outlined dense :readonly="readonly" 
        :rules="[val => !!val || t.errors.required]" 
      />
    </div>
    
    <div class="col-12 col-md-4">
      <q-input 
        :model-value="modelValue.data_nascita" 
        v-on:update:model-value="v => update('data_nascita', v)"
        :label="t.person.birth_date" 
        outlined dense :readonly="readonly"
        mask="##/##/####"
        :rules="[val => /^\d{2}\/\d{2}\/\d{4}$/.test(val) || t.errors.format_date]"
      >
        <template v-slot:append v-if="!readonly">
          <q-icon name="event" class="cursor-pointer">
            <q-popup-proxy cover transition-show="scale" transition-hide="scale">
              <q-date :model-value="modelValue.data_nascita" v-on:update:model-value="v => update('data_nascita', v)" mask="DD/MM/YYYY" />
            </q-popup-proxy>
          </q-icon>
        </template>
      </q-input>
    </div>
    
    <div class="col-12 col-md-2">
      <q-input :model-value="age" :label="t.person.age" outlined dense readonly bg-color="grey-2" />
    </div>

    <div class="col-12 col-md-6">
      <q-select 
        :model-value="modelValue.stato_nascita" 
        v-on:update:model-value="v => update('stato_nascita', v)"
        :options="countries" 
        :label="t.person.birth_country" 
        outlined dense :readonly="readonly"
      />
    </div>
    
    <div v-if="modelValue.stato_nascita === 'ITALIA'" class="col-12 col-md-6">
      <q-input :model-value="modelValue.comune_nascita" v-on:update:model-value="v => update('comune_nascita', v)" :label="t.person.birth_city" outlined dense :readonly="readonly" />
    </div>

    <div class="col-12 col-md-6">
      <q-select :model-value="modelValue.stato_residenza" v-on:update:model-value="v => update('stato_residenza', v)" :options="countries" :label="t.person.residence_country" outlined dense :readonly="readonly" />
    </div>
    
    <div v-if="modelValue.stato_residenza === 'ITALIA'" class="col-12 col-md-6">
      <q-input :model-value="modelValue.comune_residenza" v-on:update:model-value="v => update('comune_residenza', v)" :label="t.person.residence_city" outlined dense :readonly="readonly" />
    </div>

    <div v-if="modelValue.stato_residenza === 'ITALIA'" class="col-12">
      <q-input 
        :model-value="modelValue.codice_fiscale" 
        v-on:update:model-value="v => update('codice_fiscale', v.toUpperCase())"
        :label="t.person.fiscal_code" 
        outlined dense :readonly="readonly"
        mask="AAAAAA##A##A###A"
        :rules="[val => val.length === 16 || t.errors.format_cf]"
      />
    </div>

    <div class="col-12 col-md-6">
      <q-input 
        :model-value="modelValue.numero_documento" 
        v-on:update:model-value="v => update('numero_documento', v)"
        :label="t.person.doc_number" 
        outlined dense :readonly="readonly" 
        :rules="[val => !!val && val.length >= 2 || t.errors.min_chars]"
      />
    </div>
    <div class="col-12 col-md-6">
      <q-input 
        :model-value="modelValue.scadenza_documento" 
        v-on:update:model-value="v => update('scadenza_documento', v)"
        :label="t.person.doc_expiry" 
        outlined dense :readonly="readonly"
        mask="##/##/####"
        :rules="[val => /^\d{2}\/\d{2}\/\d{4}$/.test(val) || t.errors.format_date]"
      >
        <template v-slot:append v-if="!readonly">
          <q-icon name="event" class="cursor-pointer">
            <q-popup-proxy cover transition-show="scale" transition-hide="scale">
              <q-date :model-value="modelValue.scadenza_documento" v-on:update:model-value="v => update('scadenza_documento', v)" mask="DD/MM/YYYY" />
            </q-popup-proxy>
          </q-icon>
        </template>
      </q-input>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useRegistrationStore } from 'stores/registration-store'
import { translations } from 'src/constants/translations'

const props = defineProps(['modelValue', 'isAdult', 'readonly'])
const emit = defineEmits(['update:modelValue'])

const store = useRegistrationStore()
const t = computed(() => translations[store.language] || translations.it)

const countries = ['ITALIA', 'FRANCIA', 'GERMANIA', 'SVIZZERA', 'REGNO UNITO', 'SPAGNA', 'USA', 'ALTRO']

const age = computed(() => {
  const d = props.modelValue
  if (!d.data_nascita || d.data_nascita.length !== 10) return '-'
  const parts = d.data_nascita.split('/')
  if(parts.length !== 3) return '-'
  const birth = new Date(parts[2], parts[1]-1, parts[0])
  const now = new Date()
  let a = now.getFullYear() - birth.getFullYear()
  const m = now.getMonth() - birth.getMonth()
  if (m < 0 || (m === 0 && now.getDate() < birth.getDate())) a--
  return a
})

function update(field, value) {
  emit('update:modelValue', { ...props.modelValue, [field]: value })
}
</script>
<FILE_END>

<FILE_START path="web-app\src\components\scanner\SignaturePad.vue">
<template>
  <div class="signature-wrapper">
    <canvas ref="canvasRef" class="sig-canvas"></canvas>
    <div class="row justify-end q-pa-xs">
      <q-btn icon="refresh" size="sm" flat label="Pulisci" @click="clear" />
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, defineExpose, defineEmits } from 'vue'

// Definiamo un nuovo evento 'update:biometrics' per passare i dati grezzi
const emit = defineEmits(['update:modelValue', 'update:biometrics'])
const canvasRef = ref(null)
let ctx = null
let drawing = false

// Variabili per Grafometria (Compliance Legale FEA)
let points = []
let startTime = 0

onMounted(() => {
  const c = canvasRef.value
  if(!c) return
  
  // Setup Canvas
  c.width = c.parentElement.clientWidth
  c.height = 150
  ctx = c.getContext('2d')
  ctx.lineWidth = 2
  ctx.strokeStyle = '#000'
  
  const getPos = (e) => {
    const r = c.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: clientX - r.left, y: clientY - r.top }
  }

  const start = (e) => { 
    drawing = true;
    points = []; // Reset dati biometrici all'inizio di una nuova firma
    startTime = Date.now();
    
    ctx.beginPath(); 
    const {x,y} = getPos(e); 
    ctx.moveTo(x,y); 
    
    // Salva punto iniziale (type 0)
    points.push({ x: Math.round(x), y: Math.round(y), t: 0, type: 0 });
  }
  
  const move = (e) => { 
    if(!drawing) return;
    const {x,y} = getPos(e); 
    
    ctx.lineTo(x,y); 
    ctx.stroke(); 
    
    // Salva punto movimento con delta temporale (type 1)
    // Questo permette di calcolare velocit√† e accelerazione (Ductus)
    points.push({ x: Math.round(x), y: Math.round(y), t: Date.now() - startTime, type: 1 });
  }
  
  const end = () => { 
    drawing = false;
    // Salva punto fine (type 2)
    points.push({ t: Date.now() - startTime, type: 2 });
    
    // 1. Emette l'immagine base (per visualizzazione nel PDF)
    emit('update:modelValue', getImage()) 
    
    // 2. Emette i dati biometrici (per hashing e validit√† legale)
    // Questo JSON verr√† usato per creare l'hash univoco della firma
    emit('update:biometrics', JSON.stringify(points))
  }
  
  c.addEventListener('mousedown', start);
  c.addEventListener('mousemove', move); 
  c.addEventListener('mouseup', end);
  // Touch events (passive: false per prevenire lo scroll)
  c.addEventListener('touchstart', start, {passive: false});
  c.addEventListener('touchmove', move, {passive: false}); 
  c.addEventListener('touchend', end);
})

const clear = () => {
  if (!ctx || !canvasRef.value) return
  ctx.clearRect(0,0, canvasRef.value.width, canvasRef.value.height)
  points = []
  emit('update:modelValue', null)
  emit('update:biometrics', null)
}

const getImage = () => canvasRef.value.toDataURL('image/png')
const isEmpty = () => points.length === 0

defineExpose({ clear, getImage, isEmpty })
</script>

<style scoped>
.signature-wrapper {
  border: 1px dashed #ccc;
  background: white;
  border-radius: 4px;
}
.sig-canvas {
  width: 100%; 
  height: 150px; 
  touch-action: none; /* Fondamentale per mobile */
  cursor: crosshair;
}
</style>
<FILE_END>

<FILE_START path="web-app\src\components\scanner\steps\StepDocuments.vue">
<template>
  <div class="col-12 col-md-8">
    
    <div v-if="!store.isEditMode" class="q-mb-lg">
      <div class="text-subtitle1 text-center q-mb-sm text-grey-8">Come vuoi inserire i dati?</div>
      <div class="row q-col-gutter-sm justify-center">
        <div class="col-12 col-sm-6">
          <div 
            class="selection-card cursor-pointer q-pa-sm transition-generic"
            :class="!store.isManualMode ? 'active-mode shadow-2' : 'inactive-mode'"
            v-on:click="store.setInputMode('SCAN')"
            v-ripple
          >
            <div class="row items-center no-wrap">
              <div class="col-auto q-mr-md">
                <q-avatar color="blue-1" text-color="primary" icon="document_scanner" size="md" font-size="20px"/>
              </div>
              <div class="col">
                <div class="text-weight-bold text-primary">{{ t.docs.mode_scan_title }}</div>
                <div class="text-caption text-grey-7">{{ t.docs.mode_scan_desc }}</div>
              </div>
              <div class="col-auto">
                <q-radio :model-value="store.inputMode" v-on:update:model-value="val => store.inputMode = val" val="SCAN" dense color="primary" class="no-pointer-events" />
              </div>
            </div>
            <div v-if="!store.isManualMode" class="floating-badge bg-green text-white">Consigliato</div>
          </div>
        </div>

        <div class="col-12 col-sm-6">
          <div 
            class="selection-card cursor-pointer q-pa-sm transition-generic"
            :class="store.isManualMode ? 'active-mode-manual shadow-2' : 'inactive-mode'"
            v-on:click="store.setInputMode('MANUAL')"
            v-ripple
          >
            <div class="row items-center no-wrap">
              <div class="col-auto q-mr-md">
                <q-avatar :color="store.isManualMode ? 'orange-1' : 'grey-2'" :text-color="store.isManualMode ? 'orange-9' : 'grey-6'" icon="edit_note" size="md" font-size="20px"/>
              </div>
              <div class="col">
                <div class="text-weight-bold" :class="store.isManualMode ? 'text-orange-9' : 'text-grey-8'">{{ t.docs.mode_manual_title }}</div>
                <div class="text-caption text-grey-7">{{ t.docs.mode_manual_desc }}</div>
              </div>
              <div class="col-auto">
                <q-radio :model-value="store.inputMode" v-on:update:model-value="val => store.inputMode = val" val="MANUAL" dense color="orange" class="no-pointer-events" />
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <q-card bordered class="q-mb-md">
      <q-card-section class="bg-grey-2">
        <div class="text-weight-bold text-subtitle1">{{ adultCardTitle }}</div>
        <div class="text-caption text-grey-7">{{ t.docs.guardian_card_desc }}</div>
      </q-card-section>
      <q-card-section>
        <div v-if="!store.isManualMode">
          <q-select
            v-model="store.guardian.ocrData.tipo_documento"
            :options="docTypes"
            :label="t.docs.type_doc"
            outlined dense class="q-mb-md" emit-value map-options
            :readonly="store.isEditMode"
          />
          
          <div v-if="!store.isEditMode">
            <div class="row q-col-gutter-sm items-center q-mb-sm">
              <div class="col">
                <q-file outlined dense v-model="store.guardian.frontFile" :label="t.docs.scan_front" accept="image/*" @update:model-value="store.startGuardianScan()">
                  <template v-slot:prepend><q-icon name="image" /></template>
                </q-file>
              </div>
              <div class="col-auto">
                <q-btn round color="primary" icon="photo_camera" v-on:click="$emit('open-camera', { target: 'guardian', side: 'FRONT' })">
                  <q-tooltip>Fotocamera</q-tooltip>
                </q-btn>
              </div>
            </div>
            <div class="row q-col-gutter-sm items-center transition-generic" :style="{ opacity: isBackRequired(store.guardian.ocrData.tipo_documento) ? 1 : 0.5 }">
              <div class="col">
                <q-file 
                  outlined dense 
                  v-model="store.guardian.backFile" 
                  :label="isBackRequired(store.guardian.ocrData.tipo_documento) ? 'Retro (Obbligatorio)' : 'Retro (Non richiesto)'" 
                  accept="image/*" 
                  @update:model-value="store.startGuardianScan()"
                  :disable="!isBackRequired(store.guardian.ocrData.tipo_documento)"
                >
                  <template v-slot:prepend><q-icon name="flip" /></template>
                </q-file>
              </div>
              <div class="col-auto">
                <q-btn 
                  round color="primary" icon="photo_camera" 
                  v-on:click="$emit('open-camera', { target: 'guardian', side: 'BACK' })"
                  :disable="!isBackRequired(store.guardian.ocrData.tipo_documento)"
                >
                  <q-tooltip>Fotocamera</q-tooltip>
                </q-btn>
              </div>
            </div>
          </div>
          <div v-else class="text-caption text-grey-6">* Scansioni non modificabili</div>

          <div v-if="store.guardian.ocrData.debug" class="q-mt-md">
            <q-expansion-item dense icon="bug_report" :label="t.docs.debug_ai" header-class="text-white bg-grey-8">
              <q-card class="bg-grey-2">
                <q-card-section>
                  <div class="q-mt-sm text-caption">Source: <q-badge color="purple">{{ store.guardian.ocrData.source }}</q-badge></div>
                  <div v-if="store.guardian.ocrData.warning_mismatch" class="q-mt-sm text-red text-weight-bold">
                     ‚ö†Ô∏è MISMATCH: Tipo documento rilevato diverso da quello dichiarato!
                  </div>
                </q-card-section>
              </q-card>
            </q-expansion-item>
          </div>
        </div>
        <div v-else class="text-center text-grey-6 q-pa-md bg-grey-1 rounded-borders">
          <q-icon name="edit_note" size="md" color="grey-5" />
          <div class="text-caption q-mt-xs">Inserimento manuale attivo.</div>
        </div>
      </q-card-section>
    </q-card>

    <div class="q-my-lg">
      <q-toggle 
        v-if="!store.isEditMode" 
        v-model="store.hasMinors" 
        :label="t.docs.minor_toggle" 
        size="lg"
        class="text-weight-medium"
      />

      <q-slide-transition>
        <div v-if="store.hasMinors" class="bg-orange-1 q-pa-md rounded-borders q-mt-sm border-orange">
          <div class="row items-center justify-between q-mb-md">
            <div class="text-h6 text-orange-9"><q-icon name="child_care" /> {{ t.docs.minor_area }}</div>
            <q-toggle 
              v-if="!store.isEditMode" 
              v-model="store.tutorParticipates" 
              :label="t.docs.tutor_participates" 
              color="green" dense
            />
          </div>

          <div v-for="(minor, index) in store.minors" :key="minor.id" class="q-mb-md">
            <q-card bordered class="bg-white">
              <q-card-section class="row justify-between bg-grey-1 items-center q-py-sm">
                <div class="text-weight-bold text-primary">Minore #{{ index + 1 }}</div>
                <q-btn v-if="!store.isEditMode" flat round color="negative" icon="delete" size="sm" v-on:click="store.removeMinor(index)" />
              </q-card-section>
              <q-separator />
              <q-card-section>
                <div v-if="!store.isManualMode">
                  <q-select
                    v-model="minor.ocrData.tipo_documento"
                    :options="docTypes"
                    :label="t.docs.type_doc"
                    outlined dense class="q-mb-md" emit-value map-options
                    :readonly="store.isEditMode"
                  />
                  <div v-if="!store.isEditMode">
                    <div class="row q-col-gutter-sm items-center q-mb-sm">
                      <div class="col">
                        <q-file outlined dense v-model="minor.frontFile" :label="t.docs.scan_front" accept="image/*" @update:model-value="store.startMinorScan(index)">
                          <template v-slot:prepend><q-icon name="image" /></template>
                        </q-file>
                      </div>
                      <div class="col-auto">
                        <q-btn round color="primary" icon="photo_camera" v-on:click="$emit('open-camera', { target: 'minor', side: 'FRONT', index })">
                          <q-tooltip>Fotocamera</q-tooltip>
                        </q-btn>
                      </div>
                    </div>
                    <div class="row q-col-gutter-sm items-center transition-generic" :style="{ opacity: isBackRequired(minor.ocrData.tipo_documento) ? 1 : 0.5 }">
                      <div class="col">
                        <q-file outlined dense 
                          v-model="minor.backFile" 
                          :label="isBackRequired(minor.ocrData.tipo_documento) ? 'Retro (Obbligatorio)' : 'Retro (Non richiesto)'" 
                          accept="image/*" 
                          @update:model-value="store.startMinorScan(index)"
                          :disable="!isBackRequired(minor.ocrData.tipo_documento)"
                        >
                          <template v-slot:prepend><q-icon name="flip" /></template>
                        </q-file>
                      </div>
                      <div class="col-auto">
                        <q-btn 
                          round color="primary" icon="photo_camera" 
                          v-on:click="$emit('open-camera', { target: 'minor', side: 'BACK', index })"
                          :disable="!isBackRequired(minor.ocrData.tipo_documento)"
                        >
                          <q-tooltip>Fotocamera</q-tooltip>
                        </q-btn>
                      </div>
                    </div>
                  </div>
                </div>
                <div v-else class="text-center text-grey-6 q-pa-sm">Manuale attivo</div>
              </q-card-section>
            </q-card>
          </div>
          
          <q-btn 
            v-if="!store.isEditMode" 
            outline color="primary" icon="add" :label="t.docs.add_minor" 
            class="full-width bg-white"
            v-on:click="store.addMinor()" :disable="store.minors.length >= 5"
          />
        </div>
      </q-slide-transition>
    </div>

    <div class="row justify-end q-mt-xl q-gutter-sm">
      <q-btn flat :label="t.nav.back" v-on:click="$emit('prev')" />
      <q-btn color="primary" :label="t.nav.continue" v-on:click="checkAndProceed" />
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useRegistrationStore } from 'stores/registration-store'
import { translations } from 'src/constants/translations' // Named Import Corretto
import { useQuasar } from 'quasar'

const emit = defineEmits(['next', 'prev', 'open-camera'])
const store = useRegistrationStore()
const $q = useQuasar()

// Localization helper
const t = computed(() => translations[store.language] || translations.it)

const adultCardTitle = computed(() => 
  store.hasMinors ? 
  (store.tutorParticipates ? 'Tutore (Partecipante)' : 'Tutore (Non partecipante)') : 
  'Partecipante'
)

const docTypes = [
  {label: 'CIE Italiana', value: 'CIE'},
  {label: 'Patente di guida', value: 'PATENTE_IT'},
  {label: 'ID straniera', value: 'CIE_EU'},
  {label: 'Passaporto', value: 'PASSAPORTO'},
  {label: 'Altro', value: 'ALTRO'}
]

// Logica per determinare se il retro √® richiesto
function isBackRequired(docType) {
  return docType !== 'PASSAPORTO'
}

function checkAndProceed() {
  if(store.isManualMode || store.isEditMode) {
    emit('next')
    return
  }

  // Validazione Adulto/Tutore
  if(!store.guardian.frontFile) { 
    $q.notify({type:'warning', message: 'Fronte documento tutore obbligatorio'})
    return 
  }
  if(isBackRequired(store.guardian.ocrData.tipo_documento) && !store.guardian.backFile) {
    $q.notify({type:'warning', message: `Per ${store.guardian.ocrData.tipo_documento} √® richiesto anche il Retro`})
    return
  }

  // Validazione Minori
  if(store.hasMinors) {
    for(let i = 0; i < store.minors.length; i++) {
      const m = store.minors[i]
      if(!m.frontFile) {
        $q.notify({type:'warning', message: `Fronte documento Minore #${i+1} mancante`})
        return
      }
      if(isBackRequired(m.ocrData.tipo_documento) && !m.backFile) {
        $q.notify({type:'warning', message: `Retro documento Minore #${i+1} mancante`})
        return
      }
    }
  }

  emit('next')
}
</script>

<style scoped>
.selection-card {
  border-radius: 8px;
  border: 1px solid #ddd;
  position: relative;
  background: white;
}
.selection-card:hover { border-color: #bbb; }
.active-mode { border: 2px solid var(--q-primary); background: #e3f2fd; }
.active-mode-manual { border: 2px solid var(--q-warning); background: #fff3e0; }
.inactive-mode { opacity: 0.8; }
.floating-badge {
  position: absolute; top: -8px; right: -8px;
  font-size: 10px; padding: 2px 6px; border-radius: 4px; font-weight: bold;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
.border-orange { border: 1px solid var(--q-warning); }
.transition-generic { transition: all 0.2s ease-in-out; }
</style>
<FILE_END>

<FILE_START path="web-app\src\components\scanner\steps\StepReview.vue">
<template>
  <div class="row q-col-gutter-lg">
    <div class="col-12" v-if="store.isEditMode">
      <q-banner class="bg-warning text-dark q-mb-md">
        <q-icon name="lock" /> <strong>{{ t.review.edit_warning }}</strong>
      </q-banner>
    </div>

    <div class="col-12" v-if="store.tutorParticipates || !store.hasMinors">
      <q-card bordered class="shadow-1">
        <q-card-section class="bg-primary text-white">
          <div class="text-h6">{{ store.hasMinors ? 'Tutore' : 'Partecipante' }}</div>
        </q-card-section>
        <q-card-section>
          <PersonForm 
            v-model="store.guardian.ocrData" 
            :is-adult="true"
            :readonly="store.isEditMode"
          />
        </q-card-section>
      </q-card>
    </div>

    <div v-if="store.hasMinors" class="col-12">
      <div v-for="(minor, idx) in store.minors" :key="minor.id" class="q-mb-md">
        <q-card bordered class="shadow-1">
          <q-card-section class="bg-secondary text-white">
            <div class="text-h6">Minore #{{ idx + 1 }}</div>
          </q-card-section>
          <q-card-section>
             <PersonForm 
              v-model="minor.ocrData" 
              :is-adult="false"
              :readonly="store.isEditMode"
            />
            <div class="q-mt-md">
              <div class="text-subtitle2 q-mb-sm">{{ t.review.minor_sig_title }} #{{ idx + 1 }}</div>
              <SignaturePad 
                v-model="minor.ocrData.signature" 
                @update:biometrics="(val) => minor.ocrData.signatureBiometrics = val"
              />
            </div>
          </q-card-section>
        </q-card>
      </div>
    </div>

    <div class="col-12" v-if="store.tutorParticipates || !store.hasMinors">
      <q-card bordered class="bg-grey-1">
        <q-card-section>
          <div class="text-subtitle1 text-weight-bold">{{ t.review.main_sig_title }}</div>
          <div class="text-caption text-grey-7 q-mb-sm">{{ t.review.main_sig_desc }}</div>
          <SignaturePad 
            v-model="store.guardian.ocrData.signature"
            @update:biometrics="(val) => store.guardian.ocrData.signatureBiometrics = val"
          />
        </q-card-section>
      </q-card>
    </div>

    <div class="col-12 row justify-between q-mt-lg">
      <q-btn flat :label="t.nav.back" v-on:click="$emit('prev')" />
      <q-btn color="primary" label="Vai al Riepilogo" v-on:click="$emit('next')" />
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useRegistrationStore } from 'stores/registration-store'
import { translations } from 'src/constants/translations' 
import PersonForm from '../PersonForm.vue'
import SignaturePad from '../SignaturePad.vue'

defineEmits(['next', 'prev'])

const store = useRegistrationStore()
const t = computed(() => translations[store.language] || translations.it)
</script>
<FILE_END>

<FILE_START path="web-app\src\constants\legal.js">
export const LEGAL_TEXTS = {
  it: {
    privacy: `INFORMATIVA SUL TRATTAMENTO DEI DATI PERSONALI (Art. 13 GDPR 679/2016)

1. Finalit√† del trattamento:
I dati raccolti (anagrafici, documenti d'identit√†) saranno utilizzati esclusivamente per:
- L'iscrizione all'attivit√† sportiva e la relativa copertura assicurativa (Tesseramento).
- Adempimenti amministrativi, fiscali e contabili obbligatori per legge.
- Gestione delle emergenze e della sicurezza durante l'attivit√†.

2. Modalit√† di trattamento:
Il trattamento sar√† svolto in forma automatizzata e/o manuale, nel rispetto di quanto previsto dall‚Äôart. 32 del GDPR 2016/679 in materia di misure di sicurezza.

3. Comunicazione dei dati:
I dati potranno essere comunicati a enti assicurativi e federazioni sportive nazionali per il tesseramento obbligatorio. Non saranno diffusi a terzi per scopi di marketing senza esplicito consenso separato.

4. Diritti dell'interessato:
In ogni momento, Lei potr√† esercitare, ai sensi degli articoli dal 15 al 22 del Regolamento UE n. 2016/679, il diritto di accesso, rettifica, cancellazione dei dati.`,

    informed: `CONSENSO INFORMATO E DICHIARAZIONE DI RESPONSABILIT√Ä

Il sottoscritto, consapevole che l'attivit√† di rafting/sport fluviale comporta rischi intrinseci legati all'ambiente naturale, DICHIARA:

1. Idoneit√† Fisica:
Di essere in buono stato di salute, di non essere affetto da patologie che possano pregiudicare la sicurezza propria o altrui durante l'attivit√†, e di Saper Nuotare.

2. Stato Psicofisico:
Di non aver assunto sostanze stupefacenti, alcol o farmaci che possano alterare i riflessi o la percezione del rischio prima dell'attivit√†.

3. Rispetto delle Regole:
Di impegnarsi a seguire scrupolosamente tutte le indicazioni fornite dalle guide e dal personale tecnico, e di indossare correttamente l'attrezzatura di sicurezza (casco, salvagente) per tutta la durata dell'attivit√†.

4. Esonero di Responsabilit√†:
Di sollevare l'organizzazione da ogni responsabilit√† per danni a persone o cose causati dalla propria negligenza, imprudenza o mancato rispetto delle istruzioni impartite.`
  },
  
  en: {
    privacy: `PRIVACY POLICY (Art. 13 GDPR 679/2016)

1. Purpose of processing:
Collected data (personal details, ID documents) will be used exclusively for:
- Registration for sports activity and related insurance coverage.
- Mandatory administrative, fiscal, and accounting obligations.
- Management of emergencies and safety during the activity.

2. Processing methods:
Processing will be carried out automatically and/or manually, in compliance with art. 32 of GDPR 2016/679 regarding security measures.

3. Data communication:
Data may be communicated to insurance entities and national sports federations for mandatory registration. Data will not be shared with third parties for marketing without explicit consent.

4. Rights of the interested party:
At any time, you may exercise your rights under articles 15 to 22 of EU Regulation n. 2016/679 (access, rectification, deletion).`,

    informed: `INFORMED CONSENT AND LIABILITY WAIVER

The undersigned, aware that rafting/river sports involve intrinsic risks related to the natural environment, DECLARES:

1. Physical Suitability:
To be in good health, not suffering from pathologies that could jeopardize personal or others' safety, and TO KNOW HOW TO SWIM.

2. Psychophysical State:
Not to be under the influence of drugs, alcohol, or medications that may alter reflexes or risk perception.

3. Rule Compliance:
To rigorously follow all instructions provided by guides and technical staff, and to correctly wear safety equipment (helmet, life jacket) for the duration of the activity.

4. Liability Waiver:
To release the organization from any liability for damage to persons or property caused by own negligence, imprudence, or failure to follow instructions.`
  },

  fr: {
    privacy: `POLITIQUE DE CONFIDENTIALIT√â (Art. 13 GDPR 679/2016)

1. Finalit√© du traitement:
Les donn√©es collect√©es seront utilis√©es exclusivement pour:
- L'inscription √† l'activit√© sportive et la couverture d'assurance correspondante.
- Les obligations administratives et fiscales.
- La gestion des urgences et de la s√©curit√©.

2. Modalit√©s de traitement:
Le traitement sera effectu√© de mani√®re automatis√©e et/ou manuelle, conform√©ment √† l'art. 32 du GDPR 2016/679.

3. Communication des donn√©es:
Les donn√©es peuvent √™tre communiqu√©es aux organismes d'assurance et aux f√©d√©rations sportives. Elles ne seront pas diffus√©es √† des tiers √† des fins de marketing sans consentement.

4. Droits de l'int√©ress√©:
√Ä tout moment, vous pouvez exercer vos droits pr√©vus par les articles 15 √† 22 du R√®glement UE n. 2016/679 (acc√®s, rectification, suppression).`,

    informed: `CONSENTEMENT √âCLAIR√â ET D√âCHARGE DE RESPONSABILIT√â

Le soussign√©, conscient que l'activit√© de rafting/sports fluviaux comporte des risques intrins√®ques li√©s √† l'environnement naturel, D√âCLARE :

1. Aptitude Physique:
√ätre en bonne sant√©, ne pas souffrir de pathologies pouvant compromettre la s√©curit√©, et SAVOIR NAGER.

2. √âtat Psychophysique:
Ne pas avoir consomm√© de drogues, d'alcool ou de m√©dicaments pouvant alt√©rer les r√©flexes.

3. Respect des R√®gles:
S'engager √† suivre scrupuleusement toutes les instructions des guides et √† porter correctement l'√©quipement de s√©curit√©.

4. D√©charge de Responsabilit√©:
D√©gager l'organisation de toute responsabilit√© pour les dommages caus√©s aux personnes ou aux biens par sa propre n√©gligence ou imprudence.`
  }
}
<FILE_END>

<FILE_START path="web-app\src\constants\translations.js">
export const translations = {
  it: {
    nav: {
      back: 'Indietro',
      continue: 'Continua',
      confirm: 'Conferma e Invia',
      confirm_edit: 'Conferma Modifiche',
      close: 'Chiudi',
      cancel: 'Annulla',
      ignore: 'Ignora',
      correct: 'Correggi'
    },
    steps: {
      lang: 'Lingua',
      docs: 'Documenti',
      contact: 'Contatti',
      privacy: 'Privacy',
      review: 'Verifica & Firma',
      summary: 'Riepilogo'
    },
    person: {
      name: 'Nome *',
      surname: 'Cognome *',
      birth_date: 'Data di Nascita *',
      age: 'Et√†',
      birth_country: 'Stato di Nascita *',
      birth_city: 'Comune di Nascita *',
      residence_country: 'Stato Residenza *',
      residence_city: 'Comune Residenza *',
      fiscal_code: 'Codice Fiscale *',
      doc_number: 'Numero Documento *',
      doc_expiry: 'Scadenza *',
      doc_type: 'Tipo Documento *',
      email: 'Email *',
      phone: 'Telefono *',
      prefix: 'Prefisso'
    },
    errors: {
      required: 'Obbligatorio',
      format_date: 'Formato errato (GG/MM/AAAA)',
      format_cf: 'CF deve essere 16 caratteri',
      min_chars: 'Minimo 2 caratteri',
      email_required: 'Email obbligatoria',
      email_invalid: 'Email non valida',
      doc_front_missing: 'Fronte documento mancante',
      doc_back_missing: 'Retro documento mancante',
      scan_error: 'Errore durante la scansione',
      data_missing: 'Dati mancanti',
      signature_missing: 'Firma mancante'
    },
    docs: {
      title: 'Documenti',
      mode_choice: 'Come vuoi inserire i dati?',
      mode_scan_title: 'Scanner Smart',
      mode_scan_desc: 'Compilazione automatica',
      mode_manual_title: 'Manuale',
      mode_manual_desc: 'Scrivi i dati a mano',
      guardian_card_title: 'Partecipante / Tutore',
      guardian_card_desc: 'Dati del maggiorenne responsabile',
      minor_toggle: 'Ci sono minori da registrare?',
      minor_area: 'Area Minori',
      tutor_participates: 'Il tutore partecipa all\'attivit√†?',
      add_minor: 'Aggiungi un altro minore',
      scan_front: 'Fronte (Obbligatorio)',
      scan_back: 'Retro (Opzionale)',
      scan_back_req: 'Retro (Obbligatorio)',
      debug_ai: 'Debug AI & OCR',
      manual_active: 'Inserimento manuale attivo.',
      scans_locked: '* Scansioni non modificabili',
      mismatch_warning: '‚ö†Ô∏è MISMATCH: Tipo documento rilevato diverso da quello dichiarato!'
    },
    privacy: {
      already_accepted: 'Consensi gi√† accettati.',
      accept_for_all: 'Accettare i termini per ogni partecipante.',
      sync_tutor: 'Applica le scelte del Tutore a tutti i minori',
      read_and_accept: 'Ho letto, capito e acconsento',
      photo_consent_text: 'Autorizzi Rafting Republic a scattare e utilizzare foto/video durante l\'attivit√† per scopi promozionali?',
      newsletter_text: 'Vuoi ricevere aggiornamenti, sconti e novit√† via email?',
      warn_photo: 'ATTENZIONE: Negando il consenso, Rafting Republic non utilizzer√† la tua immagine per scopi promozionali.',
      adult_label: 'Partecipante / Tutore',
      minor_label: 'Minore',
      consents_synced: 'Consensi sincronizzati.'
    },
    review: {
      edit_warning: 'Modalit√† Modifica: I dati anagrafici sono bloccati. √à richiesta una nuova firma.',
      main_sig_title: 'Firma Principale',
      main_sig_desc: 'Firma qui sotto per confermare i dati.',
      minor_sig_title: 'Firma per il minore',
      clear: 'Pulisci',
      processing: 'Elaborazione dati documenti...'
    },
    summary: {
      title: 'Riepilogo Finale',
      subtitle: 'Verifica attentamente i dati prima di confermare.',
      contacts_title: 'Contatti di riferimento',
      tutor_title: 'Tutore / Responsabile',
      participant_title: 'Partecipante',
      minors_title: 'Minori',
      born_on: 'Nato il',
      born_at: 'a',
      residing_at: 'Residente a',
      doc_n: 'n.',
      expiry: 'Scadenza',
      consents_ok: 'Consensi OK',
      photo: 'Foto',
      news: 'News',
      yes: 'S√å',
      no: 'NO',
      signature: 'Firma',
      missing: 'Mancante',
      success: 'Fatto!',
      error_submit: 'Errore durante l\'invio'
    },
    dialogs: {
      camera_analysis: 'Analisi in corso...',
      doc_check: 'Verifica Documento',
      tutor_check: 'Tutore: Tipo documento errato?',
      minor_check: 'Minore' 
    }
  },
  en: {
    nav: {
      back: 'Back',
      continue: 'Continue',
      confirm: 'Confirm & Submit',
      confirm_edit: 'Confirm Changes',
      close: 'Close',
      cancel: 'Cancel',
      ignore: 'Ignore',
      correct: 'Correct'
    },
    steps: {
      lang: 'Language',
      docs: 'Documents',
      contact: 'Contact',
      privacy: 'Privacy',
      review: 'Check & Sign',
      summary: 'Summary'
    },
    person: {
      name: 'Name *',
      surname: 'Surname *',
      birth_date: 'Date of Birth *',
      age: 'Age',
      birth_country: 'Country of Birth *',
      birth_city: 'City of Birth *',
      residence_country: 'Country of Residence *',
      residence_city: 'City of Residence *',
      fiscal_code: 'Tax Code *',
      doc_number: 'Document Number *',
      doc_expiry: 'Expiry Date *',
      doc_type: 'Document Type *',
      email: 'Email *',
      phone: 'Phone *',
      prefix: 'Prefix'
    },
    errors: {
      required: 'Required',
      format_date: 'Invalid format (DD/MM/YYYY)',
      format_cf: 'Tax Code must be 16 chars',
      min_chars: 'Min 2 chars',
      email_required: 'Email required',
      email_invalid: 'Invalid email',
      doc_front_missing: 'Front document missing',
      doc_back_missing: 'Back document missing',
      scan_error: 'Error during scan',
      data_missing: 'Missing data',
      signature_missing: 'Missing signature'
    },
    docs: {
      title: 'Documents',
      mode_choice: 'How do you want to enter data?',
      mode_scan_title: 'Smart Scanner',
      mode_scan_desc: 'Automatic fill',
      mode_manual_title: 'Manual',
      mode_manual_desc: 'Type data manually',
      guardian_card_title: 'Participant / Guardian',
      guardian_card_desc: 'Responsible adult data',
      minor_toggle: 'Are there minors to register?',
      minor_area: 'Minors Area',
      tutor_participates: 'Does the guardian participate?',
      add_minor: 'Add another minor',
      scan_front: 'Front (Required)',
      scan_back: 'Back (Optional)',
      scan_back_req: 'Back (Required)',
      debug_ai: 'AI & OCR Debug',
      manual_active: 'Manual entry active.',
      scans_locked: '* Scans cannot be edited',
      mismatch_warning: '‚ö†Ô∏è MISMATCH: Detected document type differs from declared!'
    },
    privacy: {
      already_accepted: 'Consents already accepted.',
      accept_for_all: 'Accept terms for each participant.',
      sync_tutor: 'Apply Guardian choices to all minors',
      read_and_accept: 'I have read, understood and agree',
      photo_consent_text: 'Do you authorize Rafting Republic to take and use photos/videos during the activity for promotional purposes?',
      newsletter_text: 'Do you want to receive updates, discounts, and news via email?',
      warn_photo: 'WARNING: By denying consent, Rafting Republic will not use your image for promotional purposes.',
      adult_label: 'Participant / Guardian',
      minor_label: 'Minor',
      consents_synced: 'Consents synced.'
    },
    review: {
      edit_warning: 'Edit Mode: Personal data is locked. A new signature is required.',
      main_sig_title: 'Main Signature',
      main_sig_desc: 'Sign below to confirm data.',
      minor_sig_title: 'Signature for minor',
      clear: 'Clear',
      processing: 'Processing document data...'
    },
    summary: {
      title: 'Final Summary',
      subtitle: 'Please verify data carefully before confirming.',
      contacts_title: 'Contact Information',
      tutor_title: 'Guardian / Responsible',
      participant_title: 'Participant',
      minors_title: 'Minors',
      born_on: 'Born on',
      born_at: 'in',
      residing_at: 'Residing in',
      doc_n: 'n.',
      expiry: 'Expires',
      consents_ok: 'Consents OK',
      photo: 'Photo',
      news: 'News',
      yes: 'YES',
      no: 'NO',
      signature: 'Signature',
      missing: 'Missing',
      success: 'Done!',
      error_submit: 'Error sending data'
    },
    dialogs: {
      camera_analysis: 'Analyzing...',
      doc_check: 'Document Check',
      tutor_check: 'Guardian: Wrong document type?',
      minor_check: 'Minor'
    }
  },
  fr: {
    nav: {
      back: 'Retour',
      continue: 'Continuer',
      confirm: 'Confirmer et Envoyer',
      confirm_edit: 'Confirmer les modifications',
      close: 'Fermer',
      cancel: 'Annuler',
      ignore: 'Ignorer',
      correct: 'Corriger'
    },
    steps: {
      lang: 'Langue',
      docs: 'Documents',
      contact: 'Contacts',
      privacy: 'Confidentialit√©',
      review: 'V√©rifier et Signer',
      summary: 'R√©capitulatif'
    },
    person: {
      name: 'Pr√©nom *',
      surname: 'Nom *',
      birth_date: 'Date de naissance *',
      age: '√Çge',
      birth_country: 'Pays de naissance *',
      birth_city: 'Ville de naissance *',
      residence_country: 'Pays de r√©sidence *',
      residence_city: 'Ville de r√©sidence *',
      fiscal_code: 'Code Fiscal *',
      doc_number: 'Num√©ro de document *',
      doc_expiry: 'Expiration *',
      doc_type: 'Type de document *',
      email: 'Email *',
      phone: 'T√©l√©phone *',
      prefix: 'Pr√©fixe'
    },
    errors: {
      required: 'Obligatoire',
      format_date: 'Format invalide (JJ/MM/AAAA)',
      format_cf: 'Le Code Fiscal doit comporter 16 caract√®res',
      min_chars: 'Min 2 caract√®res',
      email_required: 'Email obligatoire',
      email_invalid: 'Email invalide',
      doc_front_missing: 'Recto du document manquant',
      doc_back_missing: 'Verso du document manquant',
      scan_error: 'Erreur lors du scan',
      data_missing: 'Donn√©es manquantes',
      signature_missing: 'Signature manquante'
    },
    docs: {
      title: 'Documents',
      mode_choice: 'Comment voulez-vous saisir les donn√©es ?',
      mode_scan_title: 'Scanner Intelligent',
      mode_scan_desc: 'Remplissage automatique',
      mode_manual_title: 'Manuel',
      mode_manual_desc: 'Saisir les donn√©es manuellement',
      guardian_card_title: 'Participant / Tuteur',
      guardian_card_desc: 'Donn√©es de l\'adulte responsable',
      minor_toggle: 'Y a-t-il des mineurs √† inscrire ?',
      minor_area: 'Espace Mineurs',
      tutor_participates: 'Le tuteur participe-t-il ?',
      add_minor: 'Ajouter un autre mineur',
      scan_front: 'Recto (Obligatoire)',
      scan_back: 'Verso (Optionnel)',
      scan_back_req: 'Verso (Obligatoire)',
      debug_ai: 'Debug IA & OCR',
      manual_active: 'Saisie manuelle active.',
      scans_locked: '* Scans non modifiables',
      mismatch_warning: '‚ö†Ô∏è INCOH√âRENCE: Type de document d√©tect√© diff√©rent de celui d√©clar√© !'
    },
    privacy: {
      already_accepted: 'Consentements d√©j√† accept√©s.',
      accept_for_all: 'Accepter les termes pour chaque participant.',
      sync_tutor: 'Appliquer les choix du Tuteur √† tous les mineurs',
      read_and_accept: 'J\'ai lu, compris et j\'accepte',
      photo_consent_text: 'Autorisez-vous Rafting Republic √† prendre et utiliser des photos/vid√©os pendant l\'activit√© √† des fins promotionnelles ?',
      newsletter_text: 'Voulez-vous recevoir des mises √† jour, des r√©ductions et des nouvelles par email ?',
      warn_photo: 'ATTENTION : En refusant le consentement, Rafting Republic n\'utilisera pas votre image √† des fins promotionnelles.',
      adult_label: 'Participant / Tuteur',
      minor_label: 'Mineur',
      consents_synced: 'Consentements synchronis√©s.'
    },
    review: {
      edit_warning: 'Mode √âdition : Les donn√©es personnelles sont verrouill√©es. Une nouvelle signature est requise.',
      main_sig_title: 'Signature Principale',
      main_sig_desc: 'Signez ci-dessous pour confirmer.',
      minor_sig_title: 'Signature pour le mineur',
      clear: 'Effacer',
      processing: 'Traitement des documents...'
    },
    summary: {
      title: 'R√©capitulatif Final',
      subtitle: 'Veuillez v√©rifier attentivement les donn√©es avant de confirmer.',
      contacts_title: 'Contacts de r√©f√©rence',
      tutor_title: 'Tuteur / Responsable',
      participant_title: 'Participant',
      minors_title: 'Mineurs',
      born_on: 'N√©(e) le',
      born_at: '√†',
      residing_at: 'R√©sidant √†',
      doc_n: 'n¬∞',
      expiry: 'Expire le',
      consents_ok: 'Consentements OK',
      photo: 'Photo',
      news: 'News',
      yes: 'OUI',
      no: 'NON',
      signature: 'Signature',
      missing: 'Manquante',
      success: 'Termin√© !',
      error_submit: 'Erreur lors de l\'envoi'
    },
    dialogs: {
      camera_analysis: 'Analyse en cours...',
      doc_check: 'V√©rification Document',
      tutor_check: 'Tuteur : Type de document erron√© ?',
      minor_check: 'Mineur'
    }
  }
}
<FILE_END>

<FILE_START path="web-app\src\css\app.scss">
// app global css in SCSS form
<FILE_END>

<FILE_START path="web-app\src\css\quasar.variables.scss">
// Quasar SCSS (& Sass) Variables
// --------------------------------------------------
// To customize the look and feel of this app, you can override
// the Sass/SCSS variables found in Quasar's source Sass/SCSS files.

// Check documentation for full list of Quasar variables

// Your own variables (that are declared here) and Quasar's own
// ones will be available out of the box in your .vue/.scss/.sass files

// It's highly recommended to change the default colors
// to match your app's branding.
// Tip: Use the "Theme Builder" on Quasar's documentation website.

$primary: #1976d2;
$secondary: #26a69a;
$accent: #9c27b0;

$dark: #1d1d1d;
$dark-page: #121212;

$positive: #21ba45;
$negative: #c10015;
$info: #31ccec;
$warning: #f2c037;
<FILE_END>

<FILE_START path="web-app\src\layouts\MainLayout.vue">
<template>
  <q-layout view="lHh Lpr lFf">
    <q-header elevated>
      <q-toolbar>
        <q-btn flat dense round icon="menu" aria-label="Menu" @click="toggleLeftDrawer" />
        <q-toolbar-title>Rafting Republic ‚Ä¢ Gestionale</q-toolbar-title>
        <div class="text-caption">Quasar v{{ $q.version }}</div>
      </q-toolbar>
    </q-header>

    <q-drawer v-model="leftDrawerOpen" show-if-above bordered>
      <q-list padding>
        <q-item-label header>Menu</q-item-label>

        <q-item clickable v-ripple to="/">
          <q-item-section avatar><q-icon name="dashboard" /></q-item-section>
          <q-item-section>Dashboard</q-item-section>
        </q-item>

        <q-item clickable v-ripple to="/scanner">
          <q-item-section avatar><q-icon name="document_scanner" /></q-item-section>
          <q-item-section>Nuova registrazione</q-item-section>
        </q-item>

        <q-item clickable v-ripple to="/registrazioni">
          <q-item-section avatar><q-icon name="assignment" /></q-item-section>
          <q-item-section>Registrazioni</q-item-section>
        </q-item>
      </q-list>
    </q-drawer>

    <q-page-container>
      <router-view />
    </q-page-container>
  </q-layout>
</template>

<script>
import { defineComponent, ref } from 'vue'

export default defineComponent({
  name: 'MainLayout',
  setup () {
    const leftDrawerOpen = ref(false)
    const toggleLeftDrawer = () => { leftDrawerOpen.value = !leftDrawerOpen.value }
    return { leftDrawerOpen, toggleLeftDrawer }
  }
})
</script>
<FILE_END>

<FILE_START path="web-app\src\pages\DashboardPage.vue">
<template>
  <q-page class="q-pa-md bg-grey-1">
    <div class="q-mb-xl q-mt-md">
      <div class="text-h4 text-weight-bold text-dark">Ciao! üëã</div>
      <div class="text-subtitle1 text-grey-7 q-mt-sm">
        Scegli cosa vuoi fare.
      </div>
    </div>

    <div class="row q-col-gutter-md">
      <div class="col-12 col-sm-6 col-md-4">
        <ModuleCard
          title="Nuova registrazione"
          caption="Scanner documenti + firma"
          icon="document_scanner"
          color="#1976D2"
          @click="go('/scanner')"
        />
      </div>

      <div class="col-12 col-sm-6 col-md-4">
        <ModuleCard
          title="Registrazioni"
          caption="Archivio PDF + lock"
          icon="assignment"
          color="#2E7D32"
          @click="go('/registrazioni')"
        />
      </div>
    </div>
  </q-page>
</template>

<script setup>
import ModuleCard from 'components/ModuleCard.vue'
import { useRouter } from 'vue-router'

const router = useRouter()
function go (path) { router.push(path) }
</script>
<FILE_END>

<FILE_START path="web-app\src\pages\ErrorNotFound.vue">
<template>
  <div class="fullscreen bg-blue text-white text-center q-pa-md flex flex-center">
    <div>
      <div style="font-size: 30vh">404</div>

      <div class="text-h2" style="opacity: 0.4">Oops. Nothing here...</div>

      <q-btn
        class="q-mt-xl"
        color="white"
        text-color="blue"
        unelevated
        to="/"
        label="Go Home"
        no-caps
      />
    </div>
  </div>
</template>

<script>
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'ErrorNotFound',
})
</script>
<FILE_END>

<FILE_START path="web-app\src\pages\IndexPage.vue">
<template>
  <q-page class="flex flex-center">
    <img
      alt="Quasar logo"
      src="~assets/quasar-logo-vertical.svg"
      style="width: 200px; height: 200px"
    />
  </q-page>
</template>

<script>
import { defineComponent } from 'vue'

export default defineComponent({
  name: 'IndexPage',
})
</script>
<FILE_END>

<FILE_START path="web-app\src\pages\RegistrationPage.vue">
<template>
  <q-page class="q-pa-md">
    <div class="row items-center q-col-gutter-sm q-mb-md">
      <div class="col">
        <div class="text-h5 text-weight-bold">Registrazioni</div>
        <div class="text-caption text-grey-7">
          Elenco registrazioni inviate (payload + PDF). In futuro verranno collegate alle prenotazioni.
        </div>
      </div>

      <div class="col-12 col-sm-auto">
        <q-input v-model="filter" dense outlined debounce="250" placeholder="Cerca nome, email, ID..." clearable>
          <template #prepend><q-icon name="search" /></template>
        </q-input>
      </div>

      <div class="col-12 col-sm-auto">
        <q-btn outline icon="refresh" label="Aggiorna" :loading="loading" @click="load" />
      </div>
    </div>

    <q-table
      :rows="filteredRows"
      :columns="columns"
      row-key="registration_id"
      :loading="loading"
      :pagination="pagination"
      flat
      bordered
    >
      <template #body-cell-is_minor="props">
        <q-td :props="props" class="text-center">
          <q-badge :color="props.value ? 'orange' : 'green'" rounded>
            {{ props.value ? 'S√¨' : 'No' }}
          </q-badge>
        </q-td>
      </template>

      <template #body-cell-locked="props">
        <q-td :props="props" class="text-center">
          <q-toggle
            v-model="props.row.locked"
            @update:model-value="val => onToggleLock(props.row, val)"
          />
        </q-td>
      </template>

      <template #body-cell-actions="props">
        <q-td :props="props" class="text-right">
          <q-btn dense flat icon="edit" color="primary" @click="editRegistration(props.row.registration_id)">
            <q-tooltip>Modifica Dati</q-tooltip>
          </q-btn>
          <q-btn dense flat icon="picture_as_pdf" @click="openPdf(props.row.registration_id)">
             <q-tooltip>Apri PDF</q-tooltip>
          </q-btn>
          <q-btn dense flat icon="info" @click="openDetails(props.row)">
             <q-tooltip>Dettagli & Storico</q-tooltip>
          </q-btn>
        </q-td>
      </template>
    </q-table>

    <q-dialog v-model="detailsOpen">
      <q-card style="min-width: 500px; max-width: 95vw;">
        <q-card-section class="row items-center bg-grey-2">
          <div class="text-h6">Dettagli Registrazione</div>
          <q-space />
          <q-btn flat round dense icon="close" v-close-popup />
        </q-card-section>

        <q-separator />

        <q-card-section v-if="loadingDetails" class="flex flex-center" style="min-height: 200px">
           <q-spinner-dots size="3em" color="primary" />
        </q-card-section>

        <q-card-section v-else-if="detailsFull">
          <div class="row q-col-gutter-md q-mb-lg">
            <div class="col-12 col-sm-6">
               <div class="text-caption text-grey-7">ID Registrazione</div>
               <div class="text-body2 text-weight-bold text-primary text-break">{{ detailsFull.registration_id }}</div>
            </div>
            <div class="col-12 col-sm-6">
               <div class="text-caption text-grey-7">Ultima Modifica</div>
               <div class="text-body2">{{ fmtDate(detailsFull.timestamp_iso) }}</div>
            </div>
            
            <div class="col-12">
               <div class="text-caption text-grey-7">Partecipante</div>
               <div class="text-body1">
                 {{ getPersonName(detailsFull.participant) }}
                 <span v-if="detailsFull.contact?.email" class="text-grey-7 text-caption">({{ detailsFull.contact.email }})</span>
               </div>
            </div>
          </div>

          <div class="row q-gutter-sm q-mb-lg">
            <q-btn outline icon="edit" label="Modifica" color="primary" @click="editRegistration(detailsFull.registration_id)" />
            <q-btn outline icon="picture_as_pdf" label="Apri PDF" @click="openPdf(detailsFull.registration_id)" />
          </div>

          <q-separator class="q-my-md" />

          <div class="text-h6 q-mb-md text-grey-8">
            <q-icon name="history" /> Storico Modifiche
          </div>

          <div v-if="!detailsFull.audit_log || detailsFull.audit_log.length === 0" class="text-grey-6 text-center q-pa-md">
            Nessuna modifica registrata.
          </div>

          <q-timeline v-else color="secondary">
            <q-timeline-entry
              v-for="(log, idx) in detailsFull.audit_log"
              :key="idx"
              :title="translateAction(log.action)"
              :subtitle="fmtDate(log.iso_date)"
              :icon="getActionIcon(log.action)"
              :color="getActionColor(log.action)"
            >
              <div class="text-grey-8">
                {{ log.details || 'Nessun dettaglio' }}
              </div>
            </q-timeline-entry>
          </q-timeline>

        </q-card-section>
      </q-card>
    </q-dialog>
  </q-page>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { api } from 'src/boot/axios'
import { useQuasar } from 'quasar'
import { useRouter } from 'vue-router'

const $q = useQuasar()
const router = useRouter()

const loading = ref(false)
const rows = ref([])
const filter = ref('')

const detailsOpen = ref(false)
const loadingDetails = ref(false)
const detailsFull = ref(null) // Contiene i dati completi dall'API (incluso audit_log)

const pagination = ref({
  sortBy: 'timestamp_iso',
  descending: true,
  rowsPerPage: 20
})

const columns = [
  { name: 'timestamp_iso', label: 'Data/Ora', field: 'timestamp_iso', sortable: true, format: v => fmtDate(v) },
  { name: 'participant', label: 'Partecipante', field: row => `${row.participant_nome || ''} ${row.participant_cognome || ''}`.trim(), sortable: true },
  { name: 'email', label: 'Email', field: 'email', sortable: true },
  { name: 'is_minor', label: 'Minore', field: 'is_minor', sortable: true, align: 'center' },
  { name: 'locked', label: 'Bloccata', field: 'locked', align: 'center' },
  { name: 'actions', label: '', field: 'actions', align: 'right' }
]

function fmtDate (iso) {
  if (!iso) return ''
  const d = new Date(iso)
  if (Number.isNaN(d.getTime())) return iso
  return d.toLocaleString('it-IT')
}

const filteredRows = computed(() => {
  const q = filter.value.trim().toLowerCase()
  if (!q) return rows.value
  return rows.value.filter(r => {
    const hay = [r.registration_id, r.participant_nome, r.participant_cognome, r.email]
      .map(x => (x || '').toString().toLowerCase()).join(' ')
    return hay.includes(q)
  })
})

async function load () {
  loading.value = true
  try {
    const res = await api.get('/registration/list', { params: { limit: 1000 } })
    rows.value = res.data?.items || []
  } catch (e) {
    console.error(e)
    $q.notify({ type: 'negative', message: 'Impossibile caricare le registrazioni' })
  } finally {
    loading.value = false
  }
}

function openPdf (registrationId) {
  const url = api.getUri({ url: `/registration/${registrationId}/pdf` })
  window.open(url, '_blank')
}

// Nuova logica: Carica dettagli completi dall'API
async function openDetails (row) {
  detailsOpen.value = true
  loadingDetails.value = true
  detailsFull.value = null
  
  try {
    const res = await api.get(`/registration/details/${row.registration_id}`)
    detailsFull.value = res.data
  } catch (e) {
    console.error("Err caricamento dettagli:", e)
    $q.notify({ type: 'negative', message: 'Errore caricamento dettagli' })
    detailsOpen.value = false
  } finally {
    loadingDetails.value = false
  }
}

function editRegistration (registrationId) {
  router.push(`/scanner/${registrationId}`)
}

async function onToggleLock (row, locked) {
  const prev = !locked
  try {
    await api.post(`/registration/${row.registration_id}/lock`, { locked })
    $q.notify({ type: 'positive', message: locked ? 'Registrazione bloccata' : 'Registrazione sbloccata' })
  } catch (e) {
    console.error(e)
    row.locked = prev
    $q.notify({ type: 'negative', message: 'Errore aggiornando il blocco' })
  }
}

// Helpers per il template
function getPersonName(p) {
  if (!p) return 'Sconosciuto'
  return `${p.nome || ''} ${p.cognome || ''}`.trim()
}

// Helpers per Audit Log
function translateAction(action) {
  const map = {
    'CREATE': 'Registrazione Creata',
    'UPDATE': 'Modifica Dati',
    'EMAIL_SENT': 'Email Inviata',
    'EMAIL_ERROR': 'Errore Email',
    'LOCK_CHANGE': 'Stato Blocco Modificato'
  }
  return map[action] || action
}

function getActionIcon(action) {
  if (action === 'CREATE') return 'add_circle'
  if (action === 'UPDATE') return 'edit'
  if (action === 'EMAIL_SENT') return 'mail'
  if (action === 'EMAIL_ERROR') return 'error'
  if (action === 'LOCK_CHANGE') return 'lock'
  return 'info'
}

function getActionColor(action) {
  if (action === 'CREATE') return 'green'
  if (action === 'UPDATE') return 'orange'
  if (action === 'EMAIL_SENT') return 'blue'
  if (action === 'EMAIL_ERROR') return 'red'
  if (action === 'LOCK_CHANGE') return 'grey-8'
  return 'grey'
}

onMounted(load)
</script>

<style scoped>
.text-break {
  word-break: break-all;
}
</style>
<FILE_END>

<FILE_START path="web-app\src\pages\ScannerPage.vue">
<template>
  <q-page class="q-pa-md bg-grey-1">
    <div class="text-h4 q-mb-md text-primary text-weight-bold text-center">
      {{ store.isEditMode ? t.nav.confirm_edit : 'Rafting Republic' }} üöÄ
    </div>

    <div v-if="loadingData" class="flex flex-center q-pa-xl">
      <q-spinner-dots size="3em" color="primary" />
      <div class="q-mt-md text-grey-7">Caricamento dati...</div>
    </div>

    <q-stepper
      v-else
      v-model="step"
      ref="stepper"
      color="primary"
      animated
      alternative-labels
      header-nav
      class="shadow-2 rounded-borders"
    >
      <!-- STEP 1: LINGUA -->
      <q-step :name="1" :title="t.steps.lang" icon="translate" :done="step > 1">
        <div class="row justify-center text-center">
          <div class="col-12 col-md-8">
            <div class="text-h6 q-mb-lg">Scegli la lingua / Choose language</div>
            
            <div class="row q-gutter-md justify-center">
              <!-- ITALIANO -->
              <q-btn 
                size="lg" 
                :unelevated="store.language === 'it'"
                :outline="store.language !== 'it'"
                color="primary"
                label="Italiano üáÆüáπ" 
                class="transition-generic q-px-lg"
                v-on:click="store.setLanguage('it')" 
              />

              <!-- INGLESE -->
              <q-btn 
                size="lg" 
                :unelevated="store.language === 'en'"
                :outline="store.language !== 'en'"
                color="primary"
                label="English üá¨üáß" 
                class="transition-generic q-px-lg"
                v-on:click="store.setLanguage('en')" 
              />

              <!-- FRANCESE -->
              <q-btn 
                size="lg" 
                :unelevated="store.language === 'fr'"
                :outline="store.language !== 'fr'"
                color="primary"
                label="Fran√ßais üá´üá∑" 
                class="transition-generic q-px-lg"
                v-on:click="store.setLanguage('fr')" 
              />
            </div>

            <div class="q-mt-xl">
              <q-btn 
                size="lg"
                color="primary" 
                :label="t.nav.continue" 
                class="full-width"
                style="max-width: 300px"
                v-on:click="step = 2" 
              />
            </div>
          </div>
        </div>
      </q-step>

      <!-- STEP 2: DOCUMENTI -->
      <q-step :name="2" :title="t.steps.docs" icon="badge" :done="step > 2">
        <div class="row justify-center">
          <StepDocuments 
            v-on:next="step = 3"
            v-on:prev="step = 1"
            v-on:open-camera="openCamera"
          />
        </div>
      </q-step>

      <!-- STEP 3: CONTATTI -->
      <q-step :name="3" :title="t.steps.contact" icon="contact_phone" :done="step > 3">
        <div class="row justify-center">
          <div class="col-12 col-md-6">
            <q-form v-on:submit="step = 4">
              <div class="text-subtitle1 q-mb-md">{{ t.summary.contacts_title }}</div>
              <q-input 
                v-model="store.contact.email" 
                :label="t.person.email" 
                type="email" 
                outlined class="q-mb-md" 
                :readonly="store.isEditMode" 
                :rules="[val => !!val || t.errors.email_required, val => /.+@.+\..+/.test(val) || t.errors.email_invalid]" 
              />
              <div class="row q-col-gutter-sm">
                <div class="col-4">
                  <q-select v-model="store.contact.prefix" :options="['+39', '+33', '+49', '+41', '+44', '+1']" :label="t.person.prefix" outlined :readonly="store.isEditMode" />
                </div>
                <div class="col-8">
                  <q-input v-model="store.contact.telefono" :label="t.person.phone" type="tel" outlined :readonly="store.isEditMode" :rules="[val => !!val || t.errors.required]" />
                </div>
              </div>
              <div class="row justify-end q-mt-lg q-gutter-sm">
                <q-btn flat :label="t.nav.back" v-on:click="step = 2" />
                <q-btn color="primary" :label="t.nav.continue" type="submit" />
              </div>
            </q-form>
          </div>
        </div>
      </q-step>

      <!-- STEP 4: PRIVACY -->
      <q-step :name="4" :title="t.steps.privacy" icon="gavel" :done="step > 4">
        <div class="row justify-center">
          <div class="col-12 col-md-8">
            <q-banner v-if="store.isEditMode" class="bg-green-1 q-mb-md rounded-borders">
              <q-icon name="check_circle" color="green" /> {{ t.privacy.already_accepted }}
            </q-banner>
            <q-banner v-else class="bg-indigo-1 q-mb-md rounded-borders text-body1">
              <q-icon name="info" color="primary" size="sm" class="q-mr-sm"/> <strong>{{ t.privacy.accept_for_all }}</strong>
            </q-banner>

            <q-card v-if="store.tutorParticipates || !store.hasMinors" bordered class="q-mb-lg" :class="store.guardian.ocrData.legal.isComplete ? 'bg-green-1' : 'bg-white'">
              <q-card-section class="row items-center justify-between">
                <div class="text-subtitle1 text-weight-bold">
                  <q-icon name="person" class="q-mr-xs"/> {{ store.hasMinors ? t.docs.guardian_card_title : t.summary.participant_title }}
                </div>
                <q-btn :color="store.guardian.ocrData.legal.isComplete ? 'positive' : 'primary'" :icon="store.guardian.ocrData.legal.isComplete ? 'check' : 'edit'" :label="t.steps.privacy" v-on:click="openLegalDialog(store.guardian.ocrData, t.privacy.adult_label, true)" />
              </q-card-section>
            </q-card>

            <div v-if="store.hasMinors">
              <div class="q-pa-md q-mb-lg rounded-borders shadow-1 transition-all" :class="canSync ? 'bg-white border-primary' : 'bg-grey-2 text-grey-6'">
                <q-checkbox v-model="syncWithTutor" @update:model-value="onSyncToggle" :disable="!canSync" :label="t.privacy.sync_tutor" color="green" />
              </div>
              <div v-for="(minor, idx) in store.minors" :key="minor.id" class="q-mb-md">
                  <q-card bordered :class="minor.ocrData.legal.isComplete ? 'bg-green-1' : 'bg-white'">
                  <q-card-section class="row items-center justify-between">
                    <div class="text-subtitle1 text-weight-bold"><q-icon name="child_care" class="q-mr-xs"/> {{ t.privacy.minor_label }} #{{ idx + 1 }}</div>
                    <q-btn :disable="syncWithTutor" :color="minor.ocrData.legal.isComplete ? 'positive' : 'primary'" icon="edit" :label="t.steps.privacy" v-on:click="openLegalDialog(minor.ocrData, `${t.privacy.minor_label} #${idx + 1}`, false)" />
                  </q-card-section>
                </q-card>
              </div>
            </div>

            <div class="row justify-end q-mt-lg q-gutter-sm">
              <q-btn flat :label="t.nav.back" v-on:click="step = 3" />
              <q-btn color="primary" :label="t.nav.continue" :disable="!allLegalCompleted" v-on:click="finalizeLegalStep" />
            </div>
          </div>
        </div>
      </q-step>

      <!-- STEP 5: REVIEW -->
      <q-step :name="5" :title="t.steps.review" icon="edit_note" :done="step > 5">
        <div v-if="loadingOcr" class="flex flex-center q-pa-xl">
          <q-spinner-dots size="3em" color="primary" />
          <div class="q-mt-md">{{ t.review.processing }}</div>
        </div>
        <StepReview v-else v-on:prev="step = 4" v-on:next="step = 6" />
      </q-step>

      <!-- STEP 6: SUMMARY -->
      <q-step :name="6" :title="t.steps.summary" icon="summarize">
        <div class="row justify-center">
          <div class="col-12 col-md-10">
            <div class="text-h5 q-mb-md text-center">{{ t.summary.title }}</div>
            <p class="text-grey-7 text-center q-mb-lg">{{ t.summary.subtitle }}</p>

            <q-card class="bg-blue-1 q-mb-md shadow-1">
              <q-item>
                <q-item-section avatar>
                  <q-avatar color="primary" text-color="white" icon="contact_mail" />
                </q-item-section>
                <q-item-section>
                  <q-item-label class="text-weight-bold">{{ t.summary.contacts_title }}</q-item-label>
                  <q-item-label caption class="text-black">
                    {{ store.contact.email }} <br>
                    {{ store.contact.prefix }} {{ store.contact.telefono }}
                  </q-item-label>
                </q-item-section>
              </q-item>
            </q-card>

            <div v-if="store.tutorParticipates || !store.hasMinors">
              <div class="text-subtitle2 text-grey-8 q-mb-sm q-mt-md">{{ store.hasMinors ? t.summary.tutor_title : t.summary.participant_title }}</div>
              <q-card bordered class="q-mb-md bg-white">
                <q-card-section class="q-pa-sm">
                  <q-list dense>
                    <q-item>
                      <q-item-section>
                        <q-item-label class="text-weight-bold">{{ store.guardian.ocrData.nome }} {{ store.guardian.ocrData.cognome }}</q-item-label>
                        <q-item-label caption>
                          {{ t.summary.born_on }} {{ store.guardian.ocrData.data_nascita }} {{ t.summary.born_at }} {{ store.guardian.ocrData.comune_nascita }} ({{ store.guardian.ocrData.stato_nascita }})
                        </q-item-label>
                        <q-item-label caption>
                          {{ t.summary.residing_at }} {{ store.guardian.ocrData.comune_residenza }} ({{ store.guardian.ocrData.stato_residenza }})
                        </q-item-label>
                      </q-item-section>
                    </q-item>
                    <q-separator spaced />
                    <q-item>
                      <q-item-section>
                        <q-item-label caption>{{ t.person.doc_type }}</q-item-label>
                        <q-item-label>{{ store.guardian.ocrData.tipo_documento }} {{ t.summary.doc_n }} {{ store.guardian.ocrData.numero_documento }}</q-item-label>
                        <q-item-label caption>{{ t.summary.expiry }}: {{ store.guardian.ocrData.scadenza_documento }}</q-item-label>
                      </q-item-section>
                      <q-item-section side>
                         <q-badge :color="store.guardian.ocrData.legal.isComplete ? 'green' : 'red'">{{ t.summary.consents_ok }}</q-badge>
                      </q-item-section>
                    </q-item>
                    <q-separator spaced />
                     <q-item>
                      <q-item-section>
                        <q-item-label caption>{{ t.summary.signature }}</q-item-label>
                        <img v-if="store.guardian.ocrData.signature" :src="store.guardian.ocrData.signature" style="max-height: 40px; max-width: 100px; object-fit: contain; border: 1px solid #eee;" />
                        <div v-else class="text-negative text-caption">{{ t.summary.missing }}</div>
                      </q-item-section>
                    </q-item>
                  </q-list>
                </q-card-section>
              </q-card>
            </div>

            <div v-if="store.hasMinors">
              <div class="text-subtitle2 text-grey-8 q-mb-sm q-mt-md">{{ t.summary.minors_title }}</div>
              <div v-for="(minor, idx) in store.minors" :key="idx">
                 <q-card bordered class="q-mb-sm bg-white">
                  <q-card-section class="q-pa-sm">
                    <q-list dense>
                      <q-item>
                        <q-item-section>
                          <q-item-label class="text-weight-bold">{{ minor.ocrData.nome }} {{ minor.ocrData.cognome }}</q-item-label>
                           <q-item-label caption>
                            {{ t.summary.born_on }} {{ minor.ocrData.data_nascita }}
                          </q-item-label>
                        </q-item-section>
                         <q-item-section side>
                           <q-chip size="sm" color="orange" text-color="white">{{ t.privacy.minor_label }} #{{ idx+1 }}</q-chip>
                        </q-item-section>
                      </q-item>
                       <q-item>
                        <q-item-section>
                          <q-item-label caption>{{ t.person.doc_type }}</q-item-label>
                          <q-item-label>{{ minor.ocrData.tipo_documento }} {{ t.summary.doc_n }} {{ minor.ocrData.numero_documento }}</q-item-label>
                        </q-item-section>
                      </q-item>
                      <q-separator spaced />
                       <q-item>
                        <q-item-section>
                          <q-item-label caption>{{ t.steps.privacy }}</q-item-label>
                          <div class="text-caption text-grey-8">
                            {{ t.summary.photo }}: <b>{{ minor.ocrData.legal.photoConsent ? t.summary.yes : t.summary.no }}</b> | 
                            {{ t.summary.news }}: <b>{{ minor.ocrData.legal.newsletterConsent ? t.summary.yes : t.summary.no }}</b>
                          </div>
                        </q-item-section>
                      </q-item>
                    </q-list>
                  </q-card-section>
                 </q-card>
              </div>
            </div>

            <div class="row justify-between q-mt-xl">
              <q-btn flat :label="t.nav.back" v-on:click="step = 5" />
              <q-btn color="positive" size="lg" icon="check" :label="store.isEditMode ? t.nav.confirm_edit : t.nav.confirm" v-on:click="submitAll" :loading="submitting" />
            </div>
          </div>
        </div>
      </q-step>
    </q-stepper>

    <q-dialog v-model="cameraDialog.open" maximized transition-show="slide-up" transition-hide="slide-down">
      <q-card class="bg-black">
        <CameraCapture 
          v-if="cameraDialog.open"
          :doc-type="cameraDialog.currentDocType"
          v-on:capture="onCameraCapture"
          v-on:close="cameraDialog.open = false"
        />
      </q-card>
    </q-dialog>

    <!-- LEGAL DIALOG -->
    <q-dialog v-model="legalDialog.open" persistent maximized transition-show="slide-up" transition-hide="slide-down">
      <q-card class="bg-grey-1">
        <q-toolbar class="bg-primary text-white">
          <q-toolbar-title>{{ t.steps.privacy }}: {{ legalDialog.title }}</q-toolbar-title>
          <q-btn flat round dense icon="close" v-close-popup />
        </q-toolbar>
        <q-card-section class="q-pa-md">
          <div class="row justify-center">
            <div class="col-12 col-md-8">
              <q-stepper v-model="legalDialog.step" vertical animated class="bg-white rounded-borders">
                <q-step :name="1" title="Privacy Policy" icon="policy" :done="currentLegalData.privacy">
                  <div class="legal-scroll" v-on:scroll="onDialogScroll('privacy', $event)">
                    <div class="text-body2">{{ currentLegalText.privacy }}</div>
                  </div>
                  <div class="row justify-end q-mt-md">
                    <q-btn color="primary" :label="t.privacy.read_and_accept" :disable="!legalDialog.unlocked.privacy && !store.isEditMode" v-on:click="currentLegalData.privacy = true; legalDialog.step = 2" />
                  </div>
                </q-step>
                <q-step :name="2" title="Consenso Informato / Informed Consent" icon="assignment" :done="currentLegalData.informedConsent">
                  <div class="legal-scroll" v-on:scroll="onDialogScroll('informed', $event)">
                    <div class="text-body2">{{ currentLegalText.informed }}</div>
                  </div>
                  <div class="row justify-end q-mt-md">
                    <q-btn color="primary" :label="t.privacy.read_and_accept" :disable="!legalDialog.unlocked.informed && !store.isEditMode" v-on:click="currentLegalData.informedConsent = true; legalDialog.step = 3" />
                  </div>
                </q-step>
                <q-step :name="3" :title="t.summary.photo" icon="photo_camera" :done="currentLegalData.photoConsent !== null">
                  <div class="q-pa-sm bg-grey-2 rounded-borders q-mb-md text-body2">{{ t.privacy.photo_consent_text }}</div>
                  <q-option-group v-model="currentLegalData.photoConsent" :options="yesNoOptions" type="radio" inline @update:model-value="v => { if(!v) $q.notify({type:'warning', message: t.privacy.warn_photo}) }" />
                  <div class="row justify-end q-mt-md"><q-btn color="primary" :label="t.nav.confirm" :disable="currentLegalData.photoConsent === null" v-on:click="legalDialog.step = 4" /></div>
                </q-step>
                <q-step :name="4" :title="t.summary.news" icon="mail" :done="currentLegalData.newsletterConsent !== null">
                  <div class="q-pa-sm bg-grey-2 rounded-borders q-mb-md text-body2">{{ t.privacy.newsletter_text }}</div>
                  <q-option-group v-model="currentLegalData.newsletterConsent" :options="yesNoOptions" type="radio" inline />
                  <div class="row justify-end q-mt-md"><q-btn color="primary" :label="t.nav.close" :disable="currentLegalData.newsletterConsent === null" v-on:click="closeLegalDialog(true)" /></div>
                </q-step>
              </q-stepper>
            </div>
          </div>
        </q-card-section>
      </q-card>
    </q-dialog>

    <q-dialog v-model="warningMismatchDialog.open">
      <q-card style="min-width: 350px">
        <q-card-section class="bg-orange-1 text-orange-9"><div class="text-h6"><q-icon name="warning" /> {{ t.dialogs.doc_check }}</div></q-card-section>
        <q-card-section>
          <ul class="q-pl-md"><li v-for="(warn, i) in warningMismatchDialog.messages" :key="i">{{ warn }}</li></ul>
        </q-card-section>
        <q-card-actions align="right">
          <q-btn flat :label="t.nav.correct" color="primary" v-close-popup v-on:click="step = 2" />
          <q-btn unelevated :label="t.nav.ignore" color="orange" text-color="white" v-close-popup v-on:click="step = 5" />
        </q-card-actions>
      </q-card>
    </q-dialog>

  </q-page>
</template>

<script setup>
import { ref, reactive, computed, onMounted, watch } from 'vue'
import { useRegistrationStore } from 'stores/registration-store'
import { useQuasar } from 'quasar'
import { useRoute, useRouter } from 'vue-router'
import { api } from 'src/boot/axios'
import { translations } from 'src/constants/translations'
import { LEGAL_TEXTS } from 'src/constants/legal'
import CameraCapture from 'components/CameraCapture.vue'
import StepDocuments from 'components/scanner/steps/StepDocuments.vue'
import StepReview from 'components/scanner/steps/StepReview.vue'

// Init
const store = useRegistrationStore()
const $q = useQuasar()
const route = useRoute()
const router = useRouter()

// State
const step = ref(1)
const loadingData = ref(false)
const loadingOcr = ref(false)
const submitting = ref(false)
const syncWithTutor = ref(false)

const t = computed(() => translations[store.language] || translations.it)
const currentLegalText = computed(() => LEGAL_TEXTS[store.language] || LEGAL_TEXTS.it)

const yesNoOptions = computed(() => [
  {label: t.value.summary.yes, value: true}, 
  {label: t.value.summary.no, value: false}
])

// Dialogs
const warningMismatchDialog = reactive({ open: false, messages: [] })
const cameraDialog = reactive({ open: false, target: null, side: null, index: null, currentDocType: 'CIE' })
const legalDialog = reactive({ open: false, step: 1, title: '', targetRef: null, isGuardian: false, unlocked: { privacy: false, informed: false } })

const currentLegalData = computed(() => legalDialog.targetRef ? legalDialog.targetRef.legal : {})
const canSync = computed(() => store.guardian.ocrData.legal.isComplete)
const allLegalCompleted = computed(() => {
  if ((store.tutorParticipates || !store.hasMinors) && !store.guardian.ocrData.legal.isComplete) return false
  if (store.hasMinors && store.minors.some(m => !m.ocrData.legal.isComplete)) return false
  return true
})

// Lifecycle
onMounted(async () => {
  if (route.params.id) {
    loadingData.value = true
    try {
      await store.fetchRegistration(route.params.id)
      step.value = 4
    } catch (e) {
      console.error(e)
      $q.notify({ type: 'negative', message: t.value.errors.data_missing })
    } finally { loadingData.value = false }
  } else {
    store.resetStore()
  }
})

watch(() => store.hasMinors, (val) => { if (val && store.minors.length === 0) store.addMinor() })

// Camera Logic
function openCamera({ target, side, index }) {
  cameraDialog.target = target
  cameraDialog.side = side
  cameraDialog.index = index
  cameraDialog.currentDocType = (target === 'guardian') ? store.guardian.ocrData.tipo_documento : store.minors[index].ocrData.tipo_documento
  cameraDialog.open = true
}

function onCameraCapture(file) {
  cameraDialog.open = false
  if (cameraDialog.target === 'guardian') {
    if (cameraDialog.side === 'FRONT') store.guardian.frontFile = file
    if (cameraDialog.side === 'BACK') store.guardian.backFile = file
    store.startGuardianScan()
  } else {
    const idx = cameraDialog.index
    if (cameraDialog.side === 'FRONT') store.minors[idx].frontFile = file
    if (cameraDialog.side === 'BACK') store.minors[idx].backFile = file
    store.startMinorScan(idx)
  }
  $q.notify({ type: 'positive', message: t.value.dialogs.camera_analysis })
}

// Legal Logic
function openLegalDialog(personData, title, isGuardian) {
  legalDialog.targetRef = personData
  legalDialog.title = title
  legalDialog.isGuardian = isGuardian
  legalDialog.step = 1
  legalDialog.unlocked = { privacy: store.isEditMode, informed: store.isEditMode }
  legalDialog.open = true
}

function onDialogScroll(type, e) {
  const el = e.target
  if(el.scrollTop + el.clientHeight >= el.scrollHeight - 50) {
    if(type === 'privacy') legalDialog.unlocked.privacy = true
    if(type === 'informed') legalDialog.unlocked.informed = true
  }
}

function closeLegalDialog(complete) {
  if (complete && legalDialog.targetRef) {
    legalDialog.targetRef.legal.isComplete = true
    if (legalDialog.isGuardian && syncWithTutor.value) onSyncToggle(true)
  }
  legalDialog.open = false
}

function onSyncToggle(val) {
  if (val && store.guardian.ocrData.legal.isComplete) {
    store.minors.forEach(m => m.ocrData.legal = { ...store.guardian.ocrData.legal })
    $q.notify({ type: 'positive', message: t.value.privacy.consents_synced })
  }
}

async function finalizeLegalStep() {
  if (!store.isEditMode && !store.isManualMode) {
    loadingOcr.value = true
    try {
      await store.resolveAllOcr()
      const warnings = []
      if (store.guardian.ocrData.warning_mismatch) warnings.push(t.value.dialogs.tutor_check)
      store.minors.forEach((m, i) => { if (m.ocrData.warning_mismatch) warnings.push(`${t.value.dialogs.minor_check} ${i+1}: ${t.value.docs.mismatch_warning}`) })
      
      if (warnings.length > 0) {
        warningMismatchDialog.messages = warnings
        warningMismatchDialog.open = true
        return
      }
    } finally { loadingOcr.value = false }
  }
  step.value = 5
}

// Submission
function validatePerson(p, label) {
  if (!p.nome || !p.cognome || !p.data_nascita || !p.tipo_documento || !p.numero_documento) return `${label}: ${t.value.errors.data_missing}`
  if (!p.signature) return `${label}: ${t.value.errors.signature_missing}`
  return null
}

async function submitAll() {
  const errors = []
  if (store.tutorParticipates || !store.hasMinors) {
    const err = validatePerson(store.guardian.ocrData, store.hasMinors ? t.value.summary.tutor_title : t.value.summary.participant_title)
    if(err) errors.push(err)
  }
  store.minors.forEach((m, i) => {
    const err = validatePerson(m.ocrData, `${t.value.summary.minors_title} ${i+1}`)
    if(err) errors.push(err)
  })

  if (errors.length > 0) {
    $q.notify({ type: 'negative', message: errors[0] })
    return
  }

  submitting.value = true
  const finalContact = { email: store.contact.email, telefono: `${store.contact.prefix} ${store.contact.telefono}`.trim() }
  
  try {
    // 1. Gestione Adulto/Tutore
    if (store.tutorParticipates || !store.hasMinors) {
      const payload = {
        participant: {
          ...store.guardian.ocrData,
          legal: store.guardian.ocrData.legal
        },
        contact: finalContact,
        signatureBase64: store.guardian.ocrData.signature,
        is_minor: false,
        language: store.language,
        tutorParticipates: store.tutorParticipates,
        hasMinors: store.hasMinors
      }
      await api.post('/registration/submit', payload, { 
        params: store.isEditMode ? { update_id: store.editRegistrationId } : {} 
      })
    }

    // 2. Gestione Minori
    if (store.hasMinors) {
      for (const minor of store.minors) {
        const payload = {
          participant: {
            ...minor.ocrData,
            legal: minor.ocrData.legal
          },
          guardian: store.guardian.ocrData,
          contact: finalContact,
          // Se il minore non ha firmato, usa la firma del tutore
          signatureBase64: minor.ocrData.signature || store.guardian.ocrData.signature,
          is_minor: true,
          language: store.language,
          tutorParticipates: store.tutorParticipates,
          hasMinors: store.hasMinors
        }
        await api.post('/registration/submit', payload, { 
          params: store.isEditMode ? { update_id: store.editRegistrationId } : {} 
        })
      }
    }

    $q.notify({ type: 'positive', message: t.value.summary.success })
    router.push(store.isEditMode ? '/registrazioni' : '/')
  } catch(e) {
    console.error(e)
    const detail = e.response?.data?.detail
    $q.notify({ type: 'negative', message: typeof detail === 'string' ? detail : t.value.summary.error_submit })
  } finally { submitting.value = false }
}
</script>

<style scoped>
.legal-scroll {
  height: 200px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; background: #f9f9f9; white-space: pre-wrap;
}
.transition-all { transition: all 0.3s ease; }
.border-primary { border: 1px solid var(--q-primary); }
.border-orange { border: 1px solid var(--q-warning); }
</style>
<FILE_END>

<FILE_START path="web-app\src\router\index.js">
import { defineRouter } from '#q-app/wrappers'
import {
  createRouter,
  createMemoryHistory,
  createWebHistory,
  createWebHashHistory,
} from 'vue-router'
import routes from './routes'

/*
 * If not building with SSR mode, you can
 * directly export the Router instantiation;
 *
 * The function below can be async too; either use
 * async/await or return a Promise which resolves
 * with the Router instance.
 */

export default defineRouter(function (/* { store, ssrContext } */) {
  const createHistory = process.env.SERVER
    ? createMemoryHistory
    : process.env.VUE_ROUTER_MODE === 'history'
      ? createWebHistory
      : createWebHashHistory

  const Router = createRouter({
    scrollBehavior: () => ({ left: 0, top: 0 }),
    routes,

    // Leave this as is and make changes in quasar.conf.js instead!
    // quasar.conf.js -> build -> vueRouterMode
    // quasar.conf.js -> build -> publicPath
    history: createHistory(process.env.VUE_ROUTER_BASE),
  })

  return Router
})
<FILE_END>

<FILE_START path="web-app\src\router\routes.js">
const routes = [
  {
    path: '/',
    component: () => import('layouts/MainLayout.vue'),
    children: [
      // La Home √® la Dashboard
      { path: '', component: () => import('pages/DashboardPage.vue') },

      // Registrazione guidata (Scanner)
      { path: 'scanner/:id?', component: () => import('pages/ScannerPage.vue') },

      // Archivio registrazioni 
      // FIX: Puntiamo al file ESISTENTE 'RegistrationPage.vue' (che ora contiene la tabella)
      { path: 'registrazioni', component: () => import('pages/RegistrationPage.vue') }
    ]
  },

  {
    path: '/:catchAll(.*)*',
    component: () => import('pages/ErrorNotFound.vue')
  }
]

export default routes
<FILE_END>

<FILE_START path="web-app\src\services\ImageQualityService.js">
/**
 * ImageQualityService.js
 *
 * Implementazione leggera di algoritmi di Computer Vision lato client.
 * L'obiettivo √® filtrare immagini di bassa qualit√† (sfocate, buie, mosse)
 * direttamente nel browser prima dell'invio al backend.
 *
 * Riferimento Strategia: Sezione 3 (Algoritmi di Validazione) [cite: 65]
 */

export default {
  /**
   * Converte i dati RGBA del Canvas in Scala di Grigi (Luminanza).
   * Formula: L = 0.299R + 0.587G + 0.114B [cite: 77]
   * @param {Uint8ClampedArray} data - Dati pixel (R, G, B, A, R, G, B, A...)
   * @returns {Uint8Array} Array di sola luminanza
   */
  convertToGrayscale (data) {
    const gray = new Uint8Array(data.length / 4)
    for (let i = 0; i < data.length; i += 4) {
      // i = Red, i+1 = Green, i+2 = Blue
      gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]
    }
    return gray
  },

  /**
   * Calcola la luminosit√† media dell'immagine.
   * Utile per rilevare immagini sottoesposte o sovraesposte.
   * @param {Uint8Array} grayData - Array scala di grigi
   * @returns {number} Valore medio 0-255
   */
  calculateBrightness (grayData) {
    let sum = 0
    for (let i = 0; i < grayData.length; i++) {
      sum += grayData[i]
    }
    return Math.floor(sum / grayData.length)
  },

  /**
   * Rileva la nitidezza utilizzando una simulazione del filtro Laplaciano.
   * Calcola la varianza delle differenze tra pixel adiacenti (rilevamento bordi).
   * Una varianza alta indica bordi netti (a fuoco). Una bassa indica sfocatura.
   * Riferimento: Sezione 3.1 [cite: 70, 83]
   *
   * @param {Uint8Array} grayData - Array scala di grigi
   * @param {number} width - Larghezza immagine
   * @param {number} height - Altezza immagine
   * @returns {number} Punteggio di nitidezza (Varianza)
   */
  calculateBlurScore (grayData, width, height) {
    let sum = 0
    let sumSq = 0
    let count = 0

    // Kernel Laplaciano semplificato (croce):
    //  0  1  0
    //  1 -4  1
    //  0  1  0
    // Iteriamo saltando i bordi per evitare out-of-bounds
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const i = y * width + x

        // Convoluzione manuale per performance [cite: 78]
        const val =
          grayData[i - width] + // Top
          grayData[i - 1] +     // Left
          grayData[i + 1] +     // Right
          grayData[i + width] - // Bottom
          4 * grayData[i]       // Center

        sum += val
        sumSq += val * val
        count++
      }
    }

    const mean = sum / count
    const variance = (sumSq / count) - (mean * mean)
    return Math.floor(variance)
  },

  /**
   * Calcola la differenza quadratica media (MSE) tra due frame consecutivi.
   * Usato per rilevare se l'utente sta muovendo il telefono (Motion Detection).
   * Riferimento: Sezione 3.3 [cite: 97]
   *
   * @param {Uint8Array} currentGray - Frame corrente
   * @param {Uint8Array} previousGray - Frame precedente
   * @returns {number} Punteggio MSE (pi√π √® basso, pi√π √® stabile)
   */
  calculateStabilityMSE (currentGray, previousGray) {
    if (!previousGray || currentGray.length !== previousGray.length) return 9999

    // Ottimizzazione: campioniamo 1 pixel ogni 4 per velocit√† (downsampling implicito)
    // Non serve analizzare ogni pixel per rilevare il movimento macroscopico
    let errorSum = 0
    let count = 0
    const step = 4

    for (let i = 0; i < currentGray.length; i += step) {
      const diff = currentGray[i] - previousGray[i]
      errorSum += diff * diff
      count++
    }

    return errorSum / count
  },

  /**
   * Metodo helper che esegue l'analisi completa su dati ImageData.
   */
  analyzeFrame (imageData, previousGray = null) {
    const gray = this.convertToGrayscale(imageData.data)
    const brightness = this.calculateBrightness(gray)
    const blurScore = this.calculateBlurScore(gray, imageData.width, imageData.height)
    const stability = this.calculateStabilityMSE(gray, previousGray)

    return {
      grayBuffer: gray, // Da salvare per il prossimo ciclo come "previousGray"
      metrics: {
        brightness,
        blurScore,
        stability
      }
    }
  }
}
<FILE_END>

<FILE_START path="web-app\src\services\VisionService.js">
import { api } from 'src/boot/axios'

export default {
  /**
   * Invia i documenti al backend per l'analisi OCR.
   * Prova prima /registration/scan, poi fallback su /vision/analyze (compatibilit√†).
   */
  async analyzeDocument (frontFile, backFile = null, docType = 'AUTO') {
    const buildFormData = () => {
      const formData = new FormData()
      formData.append('front', frontFile)
      if (backFile) formData.append('back', backFile)

      // Compatibilit√† con endpoint legacy
      formData.append('use_local', 'true')
      formData.append('doc_type', docType)

      return formData
    }

    const postMultipart = async (url) => {
      const formData = buildFormData()
      return api.post(url, formData, { headers: { 'Content-Type': 'multipart/form-data' } })
    }

    try {
      // 1) Endpoint nuovo
      try {
        const res = await postMultipart('/registration/scan')
        const data = res.data
        return (data && typeof data === 'object' && data.extracted) ? data.extracted : data
      } catch (e) {
        const status = e?.response?.status
        if (status !== 404 && status !== 405) throw e
      }

      // 2) Fallback legacy
      const res = await postMultipart('/vision/analyze')
      return res.data
    } catch (error) {
      console.error('VisionService Error:', error)
      if (error?.response?.data?.detail) throw new Error(error.response.data.detail)
      throw new Error('Impossibile connettersi al server di Analisi.')
    }
  }
}
<FILE_END>

<FILE_START path="web-app\src\stores\index.js">
import { defineStore } from '#q-app/wrappers'
import { createPinia } from 'pinia'

/*
 * If not building with SSR mode, you can
 * directly export the Store instantiation;
 *
 * The function below can be async too; either use
 * async/await or return a Promise which resolves
 * with the Store instance.
 */

export default defineStore((/* { ssrContext } */) => {
  const pinia = createPinia()

  // You can add Pinia plugins here
  // pinia.use(SomePiniaPlugin)

  return pinia
})
<FILE_END>

<FILE_START path="web-app\src\stores\registration-store.js">
import { defineStore } from 'pinia'
import VisionService from 'src/services/VisionService'
import { api } from 'src/boot/axios'

// Helper per struttura dati persona vuota
const createEmptyPerson = (sourceType = 'MANUALE') => ({
  nome: '',
  cognome: '',
  data_nascita: '',

  // Geografici
  stato_nascita: 'ITALIA',
  comune_nascita: '',
  stato_residenza: 'ITALIA',
  comune_residenza: '',
  codice_fiscale: '',

  // Documento
  tipo_documento: 'CIE',
  numero_documento: '',
  scadenza_documento: '',

  // Fonte del dato (OCR_AUTO, MANUALE, CAMERA_SMART, ecc.)
  source: sourceType,

  // Dati di Debug e Warning
  debug: null,
  warning_mismatch: false,

  // Consensi SPECIFICI per questa persona
  legal: {
    privacy: false,
    informedConsent: false,
    tesseramento: false,
    photoConsent: null, // true/false/null
    newsletterConsent: null, // true/false/null
    isComplete: false // Helper flag
  },

  signature: null,
  // NUOVO: Dati vettoriali per FEA (Coordinate, Pressione, Tempo)
  signatureBiometrics: null
})

export const useRegistrationStore = defineStore('registration', {
  state: () => ({
    // Edit Mode State
    editRegistrationId: null, // Se popolato, siamo in modifica

    // Step 1
    language: 'it',

    // Step 2
    tutorParticipates: true,
    hasMinors: false,

    // Modalit√† di Input: 'SCAN' (Default) o 'MANUAL' (Fallback/Emergency)
    inputMode: 'SCAN',

    guardian: {
      frontFile: null,
      backFile: null,
      ocrData: createEmptyPerson('MANUALE'),
      ocrPromise: null,
      isAnalyzed: false
    },

    minors: [], // Array di oggetti { id, frontFile, backFile, ocrData: createEmptyPerson(), ... }

    // Step 3
    contact: {
      email: '',
      prefix: '+39',
      telefono: ''
    },

    // Global settings
    tesseramentoRequired: true,

    // Step 5 (Firma principale/tutore)
    signatureBase64: null
  }),

  getters: {
    isEditMode: (state) => !!state.editRegistrationId,
    isManualMode: (state) => state.inputMode === 'MANUAL'
  },

  actions: {
    setLanguage (lang) {
      // Supporto per IT, EN, FR
      const supported = ['it', 'en', 'fr']
      this.language = supported.includes(lang) ? lang : 'it'
    },

    /**
     * Imposta la modalit√† di inserimento.
     * Se MANUAL, inizializza i dati vuoti e bypassa le richieste di file.
     * Escape Hatch implementation.
     */
    setInputMode (mode) {
      this.inputMode = mode
      if (mode === 'MANUAL') {
        this.guardian.ocrData = createEmptyPerson('MANUALE')
        this.guardian.isAnalyzed = true // Consideriamo "analizzato" (skip OCR)
        // Reset file se presenti
        this.guardian.frontFile = null
        this.guardian.backFile = null
      } else {
        // Reset stato se torniamo a SCAN
        this.guardian.isAnalyzed = false
      }
    },

    addMinor () {
      if (this.minors.length >= 10) return
      // Se siamo in manual mode, il minore nasce gi√† "analizzato" e manuale
      const isManual = this.inputMode === 'MANUAL'
      this.minors.push({
        id: Date.now(),
        frontFile: null,
        backFile: null,
        ocrData: createEmptyPerson(isManual ? 'MANUALE' : 'OCR_AUTO'),
        ocrPromise: null,
        isAnalyzed: isManual
      })
    },

    removeMinor (index) {
      this.minors.splice(index, 1)
    },

    resetGuardianScanState () {
      this.guardian.isAnalyzed = false
      this.guardian.ocrPromise = null
    },

    resetMinorScanState (index) {
      const minor = this.minors[index]
      if (!minor) return
      minor.isAnalyzed = false
      minor.ocrPromise = null
    },

    startGuardianScan () {
      if (!this.guardian.frontFile) return

      // Passiamo il tipo documento come hint
      const docHint = this.guardian.ocrData.tipo_documento || 'AUTO'

      this.guardian.ocrPromise = VisionService.analyzeDocument(
        this.guardian.frontFile,
        this.guardian.backFile,
        docHint
      ).then(data => {
        const mapped = this.mapOcrToForm(data)
        // Merge dati mantenendo legal esistente
        this.guardian.ocrData = {
          ...this.guardian.ocrData,
          ...mapped,
          source: 'OCR_HYBRID', // Tracciamo che viene dall'AI
          legal: this.guardian.ocrData.legal
        }
        this.guardian.isAnalyzed = true
        return data
      }).catch(err => {
        console.error('Errore background Guardian:', err)
      })
    },

    startMinorScan (index) {
      const minor = this.minors[index]
      if (!minor?.frontFile) return

      const docHint = minor.ocrData.tipo_documento || 'AUTO'

      minor.ocrPromise = VisionService.analyzeDocument(
        minor.frontFile,
        minor.backFile,
        docHint
      ).then(data => {
        const mapped = this.mapOcrToForm(data)
        minor.ocrData = {
          ...minor.ocrData,
          ...mapped,
          source: 'OCR_HYBRID',
          legal: minor.ocrData.legal
        }
        minor.isAnalyzed = true
        return data
      }).catch(err => {
        console.error('Errore background Minore:', err)
      })
    },

    mapOcrToForm (data) {
      if (!data || data.error) return {}

      // Logica di fallback cittadinanza (usata solo se il backend non √® esplicito)
      const nat = (data.cittadinanza || data.mrz_nationality || '').toString().toUpperCase().trim()
      const isItalian = !nat || nat === 'ITA' || nat === 'IT' || nat === 'ITALIANA'

      return {
        nome: data.nome || '',
        cognome: data.cognome || '',
        data_nascita: data.data_nascita || '',

        // Mappatura esplicita backend o fallback
        stato_nascita: data.stato_nascita || (isItalian ? 'ITALIA' : (data.nazione_nascita || '')),
        stato_residenza: data.stato_residenza || (isItalian ? 'ITALIA' : ''),

        comune_nascita: data.comune_nascita || data.luogo_nascita || '',
        comune_residenza: data.comune_residenza || '',

        codice_fiscale: data.codice_fiscale || '',

        tipo_documento: data.tipo_documento || 'ALTRO',
        numero_documento: data.numero_documento || '',
        scadenza_documento: data.scadenza_documento || data.data_scadenza || '',

        source: data.source || 'OCR_AUTO',
        debug: data._debug_info || null,
        warning_mismatch: !!data.warning_mismatch
      }
    },

    async resolveAllOcr () {
      // Se siamo in manual mode, non c'√® nulla da attendere
      if (this.inputMode === 'MANUAL') return

      const promises = []
      if (this.guardian.ocrPromise) promises.push(this.guardian.ocrPromise)
      this.minors.forEach(m => {
        if (m.ocrPromise) promises.push(m.ocrPromise)
      })
      await Promise.allSettled(promises)
    },

    // --- LOGICA EDIT MODE ---
    async fetchRegistration (id) {
      this.resetStore()
      this.editRegistrationId = id

      try {
        const res = await api.get(`/registration/details/${id}`)
        const data = res.data

        // 1. Setta Lingua e Contatti
        this.language = data.language || 'it'
        if (data.contact) {
          this.contact.email = data.contact.email || ''
          this.contact.telefono = data.contact.telefono || ''
          // Gestione prefisso basic se presente nel numero
          if (this.contact.telefono.startsWith('+')) {
            this.contact.prefix = this.contact.telefono.substring(0, 3)
            this.contact.telefono = this.contact.telefono.substring(3)
          }
        }

        // Helper per mappare i dati anagrafici nel form
        const mapPersonData = (source) => {
          const empty = createEmptyPerson(source.source || 'DB_FETCH')
          if (!source) return empty

          // Mappatura diretta campi
          const dest = { ...empty, ...source }

          // Mappatura sub-oggetti geografici (gestione retrocompatibilit√†)
          if (source.italian) {
            dest.comune_nascita = source.italian.comune_nascita || source.comune_nascita
            dest.comune_residenza = source.italian.comune_residenza || source.comune_residenza
            dest.codice_fiscale = source.italian.codice_fiscale || source.codice_fiscale
          }

          // Mappatura Consensi:
          const oldLegal = source.legal_consents || source.legal || {}
          dest.legal = {
            privacy: true, // Pre-accettato
            informedConsent: true, // Pre-accettato
            tesseramento: true,
            photoConsent: oldLegal.photo,
            newsletterConsent: oldLegal.newsletter,
            isComplete: false // Forziamo l'utente a confermare
          }

          return dest
        }

        // 2. Popolamento Persone
        const isMinorReg = data.is_minor || false

        if (!isMinorReg) {
          // Caso Adulto
          this.tutorParticipates = true
          this.hasMinors = false
          this.guardian.ocrData = mapPersonData(data.participant)
          this.guardian.isAnalyzed = true // Evita OCR
        } else {
          // Caso Minore
          this.hasMinors = true
          this.tutorParticipates = data.tutor_participates // Dovrebbe venire dal payload

          // Popola Tutore
          if (data.guardian) {
            this.guardian.ocrData = mapPersonData(data.guardian)
            this.guardian.isAnalyzed = true
          }

          // Popola Minore
          this.addMinor()
          this.minors[0].ocrData = mapPersonData(data.participant)
          this.minors[0].isAnalyzed = true
        }

      } catch (e) {
        console.error("Errore fetch registration", e)
        throw e
      }
    },

    resetStore () {
      this.$reset()
      // Assicuriamoci che inputMode torni al default
      this.inputMode = 'SCAN'
    }
  }
})
<FILE_END>

